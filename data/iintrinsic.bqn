# https://www.intel.com/content/dam/develop/public/us/en/include/intrinsics-guide/data-3-6-1.xml
xml â† â€¢FChars â€¢wdpath â€¢file.At âŠ‘â€¢args

#âŒœ
# An xml parser good enough for our use case
# Accept xml; return (as three lists):
# - Parent index of each tag
# - Contents of open tag
# - Text after last child tag
E â† +`âŠ¸Ã—âŸœÂ¬-âŠ¢
ParseXml â† {
  textâ€¿tags â† ('?'=Â·âŠ‘Â·âŠ‘1âŠ¸âŠ‘)âŠ¸(â†“Â¨) <Ë˜â‰âŒŠâ€¿2â¥Š((+âŸœÂ»Eâˆ¨)Ë"<>"=âŒœâŠ¢)âŠ¸âŠ”ğ•©
  dâ†+`ttâ†1-(+ËœâŠ¸+Â´'/'=0â€¿Â¯1âŠ¸âŠ)Â¨tags    # Tag type: Â¯1 close, 0 void, 1 open
  tpâ†(â‹âŠâŸœd)âŠ¸âŠâˆ˜/Ë˜ 1â€¿Â¯1=âŒœtt            # Tag pairs
  ! (âˆ§`' 'âŠ¸â‰ )âŠ¸/Â¨âŠ¸â‰¡âŸœ(1âŠ¸â†“Â¨)ËtpâŠtags    # Tag matching
  oiâ†(0<tt)(âŒˆ`â†•âˆ˜â‰ âŠ¸Ã—)âŠ¸âŠâŒ¾((â‹d)âŠ¸âŠ)â†•â‰ tt  # Open index, for closed and void tags
  ciâ†â‹âŠ¸âŠâ—‹(âˆ¾âŸœ(/0=tt))Ëtp
  piâ†(/0â‰¤tt)(1-Ëœâ‹)Â¯1âŒ¾âŠ‘ciâŠoi          # Parent index
  âŸ¨pi,(0â‰¤tt)/tags,ciâŠtextâŸ©
}
ParseAttr â† {
  nameâ€¿a â† (âŠ‘â‹ˆ1âŠ¸â†“) (EËœ' 'âŠ¸=>Â·â‰ `'"'âŠ¸=)âŠ¸âŠ”ğ•©
  âŸ¨name, >(EËÂ·âˆ¨`"="""=âŒœâŠ¢)âŠ¸âŠ”Â¨aâŸ©
}

#âŒœ
# Now process the contents
isaList â† "SSE"â€¿"SSE2"â€¿"SSE3"â€¿"SSSE3"â€¿"SSE4.1"â€¿"SSE4.2"â€¿"AVX"â€¿"AVX2"â€¿"FMA"

namesâ€¿GetContâ€¿GetVoidâ€¿svml â† {
  parentâ€¿openâ€¿cont â† ParseXml xml
  findOpen â† {(â·ğ•©)âŠ¸âŠâŠ(âŠ”âŠğ•©)Ë™} (âˆ§`' 'âŠ¸â‰ )âŠ¸/Â¨ open
  _on_ â† {ğ”½â—‹((âˆ¾FindOpenğ•˜)âŠ¸âŠ)}
  child â† âŠ” parent
  intr â‡ cont âˆŠâŸœisaListâŠ¸/_on_âŸ¨"CPUID"âŸ© parent
  IG â† intrâŠâŠ”
  GetCont â‡ { parent IG _on_ğ•© cont }
  GetVoid â‡ { parent IGâŸœ((Â¯1âŠ‘Â·ParseAttr Â¯1âŠ¸â†“)Â¨)_on_ğ•© open }
  at â† (1âŠ‘ParseAttr)Â¨ intrâŠopen
  names â‡ â‰¡Â¨âŸœ(<"name")âŠ¸(âŠ‘âˆ˜/)Ëâˆ˜â‰Â¨ at
  svml â‡ (âŠ‘"tech"â€¿"SVML"âˆŠâŠ¢)Â¨ at
}

ProcType â† {
  IsDig â† 1=0â€¿10â‹-âŸœ'0'
  Nat â† 10âŠ¸Ã—âŠ¸+ËœÂ´âˆ˜âŒ½ -âŸœ'0'
  Num â† {ğ•Šâ¼:â€¢Reprğ•©; (0<â‰ )â—¶1â€¿Nat IsDigâŠ¸/ğ•©}
  tâ€¿nâ€¿e â† ((1âŠË˜ğ•©)âˆ¾<"")âŠËœ(âŠË˜ğ•©)âŠ"type"â€¿"varname"â€¿"etype"
  pre â† ""
  t â†© " const" {câ†ğ•¨â‰¡(-â‰ ğ•¨)â†‘ğ•©â‹„preâˆ¾â†©câŠ"&*"â‹„(-cÃ—â‰ ğ•¨)â†“ğ•©}âŸœ((-1+' '=Â¯2âŠ¸âŠ‘)âŠ¸â†“)âŸ('*'â‰¡Â¯1âŠ¸âŠ‘) t
  {ğ•¤â‹„preâ€¿tâ†©"IMM"â€¿""}âŸ("IMM"âŠ¸â‰¡) e
  EP â† (âˆ¾Â·((â¥ŠÂ¨"uifbm")âŠ‘Ëœ"UI"â€¿"SI"â€¿"FP"â€¿"M"â€¿"MASK"âŠ¸âŠâŒ¾<)âŒ¾âŠ‘IsDigâŠ¸âŠ”) eË™
  tpâ€¿act â† <Ë˜â‰âˆ˜â€¿2â¥ŠâŸ¨
    "void"   , âŠ¢
    "int"    , "i32"
    "float"  , "f32"
    "double" , "f64"
    "__m"    , (âˆŠâŸœ"bm"âŒ¾<âŠ‘âˆ˜âŠ¢)â—¶âŸ¨("["âˆ¾"]"âˆ¾ËœÃ·âŒ¾Num)âˆ¾âŠ¢, âŠâˆ˜âŠ¢âˆ¾Â·IsDigâŠ¸/âŠ£âŸ©âŸœEP
    ""       , âŠ¢
  âŸ©
  act âˆ¾â†© âŸ¨EPâŸ© # Various integer types
  âŸ¨n, preâˆ¾(tpâŠ¸âŠâŒ¾<(âˆ§`âˆ˜Â¬IsDig)âŠ¸/)â—¶act tâŸ©
}

proto â† (Â¯1â†“âŸ(""â€¿"void"â‰¡âŠ‘)ProcTypeÂ¨)Â¨ GetVoid "return"â€¿"parameter"
cpuidâ€¿cat â† GetContâˆ˜(â¥Š<)Â¨ "CPUID"â€¿"category"
cpuid â†© isaList âŠ âŠ‘Â¨cpuid
#instrs â† 0â€¿1âŠ¸âŠ‘Â¨Â¨ GetVoid âŸ¨"instruction"âŸ©  # x86 instruction name

filter â† âˆ§Â´ filters â† âŸ¨
  Â¬ âˆ¨Ë"_ss"â€¿"_sd"(âŠ£â‰¡-âˆ˜â‰ âŠ¸â†‘)âŒœnames
  svml < cpuid<â‰ isaList
  Â¬ (âˆ¨Â´Â·("&b"âˆ§Â´âˆ˜âˆŠâŠ¢)Â¨1âŠ‘Â¨âŠ¢)Â¨ proto
  (âŠ‘'b'âˆŠ1âŠ‘âŠ‘)â—¶âŸ¨1,âŠ‘Â·(âŠâˆŠ1âŠ¸â†“)1âŠ‘Â¨âŠ¢âŸ©Â¨ proto
âŸ©
namesâ€¿protoâ€¿cpuidâ€¿cat filterâŠ¸/Â¨â†©

_seg â† {(ğ”½Â·+`'_'âŠ¸=)âŠ¸/}
sname â† 3âŠ¸=_segâŠ¸(âˆ¾Ëœ)âŸ("_mask"âŠ¸â‰¡)âŸœ(2âŠ¸=_seg)Â¨ names
id â† âŠ sname â‰Ë˜ 1â†“Â¨proto
Disamb â† { Uâ†{Â¬âˆ§Â´âˆŠğ•©} â‹„ ğ•© 2âŠ¸<_segÂ¨âŠ¸(âˆ¾Â¨ËœâŸUËœ)âŸU ("_"âˆ¾Â·Â¬âˆ˜âˆŠâŸœ"[]"âŠ¸/1âŠ‘âŠ‘)Â¨ğ•¨ }
sname âˆ¾Â¨â†© proto (1<â‰ âˆ˜âŠ¢)â—¶âŸ¨""Â¨,DisambâŸ©Â¨âŒ¾(idâŠ¸âŠ”) names

#âŒœ
# Format as Singeli definition
MakeDef â† {instr ğ•Š prot:
  # Utilities
  Brâ†"{"âˆ¾âˆ¾âŸœ"}" â‹„ Aâ†âˆ¾âŸœBr â‹„ Mâ†{"match"Aâˆ¾ğ•¨â€¿","â€¿ğ•©}
  Intâ†<âŠ¸(â‰Ë˜) â‹„ Jâ†âˆ¾1â†“Â·â¥ŠInt
  # Test if ğ•© is of type ğ•¨
  IsT â† (âˆŠâŸœ"bm"âŒ¾<âŠ‘âˆ˜âŠ¢)â—¶Mâ€¿{ "ii_intvec"Aâˆ¾âŸ¨1â†“ğ•©,",",ğ•¨âŸ© }
  # Type handling and formatting
  pnâ€¿pt â† <Ë˜â‰> prot
  anâ†1â†“pn â‹„ ! âˆŠâŸœ""â€¿"dst"â€¿"k"âŒ¾< âŠ‘pn
  pt ("__pnt" A 1âŠ¸â†“)âŸ(âˆŠâŸœ"*&"âŒ¾<âŠ‘)Â¨â†©
  rtâ€¿at â† (âŠ‘â‹ˆ1âŠ¸â†“) pt
  vf â† Â¬ if â† "IMM"âŠ¸â‰¡Â¨ at
  tn â† â¥ŠÂ¨'T'-âŠvf/at
  vars â† an (âˆ¾âŸœ":"âŠ¸âˆ¾Â¨âŸœtn â‹ˆ tn IsTÂ¨â—‹â·âŠ¢)â—‹(vfâŠ¸/) at
  imms â† (âŠ¢ â‹ˆ "ii_num"âŠ¸AÂ¨) if/an
  rt â†© (â‰ at)âŠ¸=â—¶âŸ¨âŠ‘âŸœtn, rtâŸ© atâŠ¸âŠâŒ¾< rt
  âˆ¾âŸ¨
    Br âˆ¾ 1â†“â¥Š âˆ¾ âŸ¨", "," & "âŸ© IntÂ¨ vars âˆ¾Â¨ imms
    " = emit"
    Br ", "J âŸ¨rt, "'"(âˆ¾âˆ¾âŠ£)instrâŸ© âˆ¾ an
  âŸ©
}
defs â† cpuid âŠ”â—‹((â‹cat)âŠ¸âŠ) sname {âˆ¾"def _"â€¿ğ•¨â€¿ğ•©}Â¨ names MakeDefÂ¨ proto
â€¢Out 1âŒ½"
def ii_intvec{w,T} = 0
def ii_intvec{w,T & match{'vector',typekind{T}} & isint{eltype{T}} & match{w,width{T}}} = 1
def ii_num{T} = match{'number',kind{T}}"
â€¢OutÂ¨ âˆ¾ 1â†“â¥Š(<2â¥Š<âŸ¨âŸ©) âˆ¾Ë˜ ("#"âŠ¸âˆ¾Â¨isaList) <âŠ¸â‰Ë˜ defs
