# https://www.intel.com/content/dam/develop/public/us/en/include/intrinsics-guide/data-3-6-1.xml
xml â† â€¢FChars â€¢wdpath â€¢file.At âŠ‘â€¢args

#âŒœ
# An xml parser good enough for our use case
# Accept xml; return (as three lists):
# - Parent index of each tag
# - Contents of open tag
# - Text after last child tag
E â† +`âŠ¸Ã—âŸœÂ¬-âŠ¢
ParseXml â† {
  textâ€¿tags â† ('?'=Â·âŠ‘Â·âŠ‘1âŠ¸âŠ‘)âŠ¸(â†“Â¨) <Ë˜â‰âŒŠâ€¿2â¥Š((+âŸœÂ»Eâˆ¨)Ë"<>"=âŒœâŠ¢)âŠ¸âŠ”ğ•©
  dâ†+`ttâ†1-(+ËœâŠ¸+Â´'/'=0â€¿Â¯1âŠ¸âŠ)Â¨tags    # Tag type: Â¯1 close, 0 void, 1 open
  tpâ†(â‹âŠâŸœd)âŠ¸âŠâˆ˜/Ë˜ 1â€¿Â¯1=âŒœtt            # Tag pairs
  ! (âˆ§`' 'âŠ¸â‰ )âŠ¸/Â¨âŠ¸â‰¡âŸœ(1âŠ¸â†“Â¨)ËtpâŠtags    # Tag matching
  oiâ†(0<tt)(âŒˆ`â†•âˆ˜â‰ âŠ¸Ã—)âŠ¸âŠâŒ¾((â‹d)âŠ¸âŠ)â†•â‰ tt  # Open index, for closed and void tags
  ciâ†â‹âŠ¸âŠâ—‹(âˆ¾âŸœ(/0=tt))Ëtp
  piâ†(/0â‰¤tt)(1-Ëœâ‹)Â¯1âŒ¾âŠ‘ciâŠoi          # Parent index
  âŸ¨pi,(0â‰¤tt)/tags,ciâŠtextâŸ©
}
ParseAttr â† {
  nameâ€¿a â† (âŠ‘â‹ˆ1âŠ¸â†“) (EËœ' 'âŠ¸=>Â·â‰ `'"'âŠ¸=)âŠ¸âŠ”ğ•©
  âŸ¨name, >(EËÂ·âˆ¨`"="""=âŒœâŠ¢)âŠ¸âŠ”Â¨aâŸ©
}

#âŒœ
# Now process the contents
isaList â† "SSE"â€¿"SSE2"â€¿"SSE3"â€¿"SSSE3"â€¿"SSE4.1"â€¿"SSE4.2"â€¿"AVX"â€¿"AVX2"â€¿"FMA"

namesâ€¿GetContâ€¿GetVoid â† {
  parentâ€¿openâ€¿cont â† ParseXml xml
  findOpen â† {(â·ğ•©)âŠ¸âŠâŠ(âŠ”âŠğ•©)Ë™} (âˆ§`' 'âŠ¸â‰ )âŠ¸/Â¨ open
  _on_ â† {ğ”½â—‹((âˆ¾FindOpenğ•˜)âŠ¸âŠ)}
  child â† âŠ” parent
  intr â‡ cont âˆŠâŸœisaListâŠ¸/_on_âŸ¨"CPUID"âŸ© parent
  IG â† intrâŠâŠ”
  GetCont â‡ { parent IG _on_ğ•© cont }
  GetVoid â‡ { parent IGâŸœ((Â¯1âŠ‘Â·ParseAttr Â¯1âŠ¸â†“)Â¨)_on_ğ•© open }
  names â‡ â‰¡Â¨âŸœ(<"name")âŠ¸(âŠ‘âˆ˜/)Ëâˆ˜(â‰1âŠ‘ParseAttr)Â¨ intrâŠopen
}

ProcType â† {
  IsDig â† 1=0â€¿10â‹-âŸœ'0'
  tâ€¿nâ€¿e â† ((1âŠË˜ğ•©)âˆ¾<"")âŠËœ(âŠË˜ğ•©)âŠ"type"â€¿"varname"â€¿"etype"
  pre â† ""
  t â†© " const" {câ†ğ•¨â‰¡(-â‰ ğ•¨)â†‘ğ•©â‹„preâˆ¾â†©câŠ"&*"â‹„(-cÃ—â‰ ğ•¨)â†“ğ•©}âŸœ((-1+' '=Â¯2âŠ¸âŠ‘)âŠ¸â†“)âŸ('*'â‰¡Â¯1âŠ¸âŠ‘) t
  {ğ•¤â‹„preâ€¿tâ†©"IMM"â€¿""}âŸ("IMM"âŠ¸â‰¡) e
  EP â† âˆ¾Â·((â¥ŠÂ¨"uifbm")âŠ‘Ëœ"UI"â€¿"SI"â€¿"FP"â€¿"M"â€¿"MASK"âŠ¸âŠâŒ¾<)âŒ¾âŠ‘IsDigâŠ¸âŠ”
  tpâ€¿act â† <Ë˜â‰âˆ˜â€¿2â¥ŠâŸ¨
    "void"   , âŠ¢
    "int"    , "i32"
    "float"  , "f32"
    "double" , "f64"
    "__m"    , (("["âˆ¾"]"âˆ¾ËœÂ·â€¢ReprÃ·â—‹((0<â‰ )â—¶1â€¿â€¢BQN))â—‹(IsDigâŠ¸/)âˆ¾EPâˆ˜âŠ¢)âŸœe
    ""       , âŠ¢
  âŸ©
  act âˆ¾â†© âŸ¨EPâˆ˜eâŸ© # Various integer types
  âŸ¨n, preâˆ¾(tpâŠ¸âŠâŒ¾<(âˆ§`âˆ˜Â¬IsDig)âŠ¸/)â—¶act tâŸ©
}

proto â† (Â¯1â†“âŸ(""â€¿"void"â‰¡âŠ‘)ProcTypeÂ¨)Â¨ GetVoid "return"â€¿"parameter"
cpuidâ€¿cat â† GetContâˆ˜(â¥Š<)Â¨ "CPUID"â€¿"category"
cpuid â†© isaList âŠ âŠ‘Â¨cpuid
#instrs â† 0â€¿1âŠ¸âŠ‘Â¨Â¨ GetVoid âŸ¨"instruction"âŸ©  # x86 instruction name

#âŒœ
# Format as Singeli definition
MakeDef â† {name ğ•Š prot:
  pnâ€¿pt â† <Ë˜â‰> prot
  anâ†1â†“pn â‹„ ! âˆŠâŸœ""â€¿"dst"â€¿"k"âŒ¾< âŠ‘pn
  rtâ€¿at â† (âŠ‘â‹ˆ1âŠ¸â†“) pt
  at ("__pnt{"âˆ¾1âŠ¸â†“âˆ¾"}"Ë™)âŸ('*'=âŠ‘)Â¨â†©
  vf â† Â¬ if â† "IMM"âŠ¸â‰¡Â¨ at
  tn â† â¥ŠÂ¨'T'-âŠvf/at
  vars â† an (âˆ¾âŸœ":"âŠ¸âˆ¾Â¨âŸœtn â‹ˆ tn{âˆ¾"match{"â€¿ğ•¨â€¿","â€¿ğ•©â€¿"}"}Â¨â—‹â·âŠ¢)â—‹(vfâŠ¸/) at
  imms â† (âŠ¢ â‹ˆ ("match{'number',kind{"âˆ¾âˆ¾âŸœ"}}")Â¨) if/an
  rt â†© (â‰ at)âŠ¸=â—¶âŸ¨âŠ‘âŸœtn, rtâŸ© atâŠ¸âŠâŒ¾< rt
  Br â† "{"âˆ¾âˆ¾âŸœ"}"
  âˆ¾âŸ¨
    "def "
    "_"âˆ¾(2=Â·+`'_'âŠ¸=)âŠ¸/âŸ(0<â‰ an) name
    Br âˆ¾ 1â†“â¥Š âˆ¾ âŸ¨", "," & "âŸ© <âŠ¸(â‰Ë˜)Â¨ vars âˆ¾Â¨ imms
    " = emit"
    Br âˆ¾1â†“â¥Š(<", ")â‰Ë˜âŸ¨rt, "'"(âˆ¾âˆ¾âŠ£)nameâŸ© âˆ¾ an
  âŸ©
}
filter â† Â¬ (âˆ¨Ë"_ss"â€¿"_sd"(âŠ£â‰¡-âˆ˜â‰ âŠ¸â†‘)âŒœnames) âˆ¨ (âˆ¨Â´"&bm"âˆŠÂ·âˆ¾1âŠ‘Â¨âŠ¢)Â¨ proto
filter âˆ§â†© cpuid<â‰ isaList
defs â† (cpuidâ‰Ë˜cat) â‹âŠ¸âŠâ—‹(filterâŠ¸/) names MakeDefÂ¨ proto
â€¢OutÂ¨ âˆ¾ 1â†“â¥Š(<2â¥Š<âŸ¨âŸ©) âˆ¾Ë˜ ("#"âŠ¸âˆ¾Â¨isaList) <âŠ¸â‰Ë˜ (âˆ§filter/cpuid) âŠ” defs
