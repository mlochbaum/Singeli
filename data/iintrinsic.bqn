# https://www.intel.com/content/dam/develop/public/us/en/include/intrinsics-guide/data-3-6-1.xml
xml â† â€¢FChars â€¢wdpath â€¢file.At âŠ‘â€¢args

#âŒœ
# An xml parser good enough for our use case
# Accept xml; return (as three lists):
# - Parent index of each tag
# - Contents of open tag
# - Text after last child tag
E â† +`âŠ¸Ã—âŸœÂ¬-âŠ¢
ParseXml â† {
  textâ€¿tags â† ('?'=Â·âŠ‘Â·âŠ‘1âŠ¸âŠ‘)âŠ¸(â†“Â¨) <Ë˜â‰âŒŠâ€¿2â¥Š((+âŸœÂ»Eâˆ¨)Ë"<>"=âŒœâŠ¢)âŠ¸âŠ”ğ•©
  dâ†+`ttâ†1-(+ËœâŠ¸+Â´'/'=0â€¿Â¯1âŠ¸âŠ)Â¨tags    # Tag type: Â¯1 close, 0 void, 1 open
  tpâ†(â‹âŠâŸœd)âŠ¸âŠâˆ˜/Ë˜ 1â€¿Â¯1=âŒœtt            # Tag pairs
  ! (âˆ§`' 'âŠ¸â‰ )âŠ¸/Â¨âŠ¸â‰¡âŸœ(1âŠ¸â†“Â¨)ËtpâŠtags    # Tag matching
  oiâ†(0<tt)(âŒˆ`â†•âˆ˜â‰ âŠ¸Ã—)âŠ¸âŠâŒ¾((â‹d)âŠ¸âŠ)â†•â‰ tt  # Open index, for closed and void tags
  ciâ†â‹âŠ¸âŠâ—‹(âˆ¾âŸœ(/0=tt))Ëtp
  piâ†(/0â‰¤tt)(1-Ëœâ‹)Â¯1âŒ¾âŠ‘ciâŠoi          # Parent index
  âŸ¨pi,(0â‰¤tt)/tags,ciâŠtextâŸ©
}
ParseAttr â† {
  nameâ€¿a â† (âŠ‘â‹ˆ1âŠ¸â†“) (EËœ' 'âŠ¸=>Â·â‰ `'"'âŠ¸=)âŠ¸âŠ”ğ•©
  âŸ¨name, >(EËÂ·âˆ¨`"="""=âŒœâŠ¢)âŠ¸âŠ”Â¨aâŸ©
}

#âŒœ
# Now process the contents
isaList â† "SSE"â€¿"SSE2"â€¿"SSE3"â€¿"SSSE3"â€¿"SSE4.1"â€¿"SSE4.2"â€¿"AVX"â€¿"AVX2"â€¿"FMA"

namesâ€¿GetContâ€¿GetVoidâ€¿svml â† {
  parentâ€¿openâ€¿cont â† ParseXml xml
  findOpen â† {(â·ğ•©)âŠ¸âŠâŠ(âŠ”âŠğ•©)Ë™} (âˆ§`' 'âŠ¸â‰ )âŠ¸/Â¨ open
  _on_ â† {ğ”½â—‹((âˆ¾FindOpenğ•˜)âŠ¸âŠ)}
  child â† âŠ” parent
  intr â‡ cont âˆŠâŸœisaListâŠ¸/_on_âŸ¨"CPUID"âŸ© parent
  IG â† intrâŠâŠ”
  GetCont â‡ { parent IG _on_ğ•© cont }
  GetVoid â‡ { parent IGâŸœ((Â¯1âŠ‘Â·ParseAttr Â¯1âŠ¸â†“)Â¨)_on_ğ•© open }
  at â† (1âŠ‘ParseAttr)Â¨ intrâŠopen
  names â‡ â‰¡Â¨âŸœ(<"name")âŠ¸(âŠ‘âˆ˜/)Ëâˆ˜â‰Â¨ at
  svml â‡ (âŠ‘"tech"â€¿"SVML"âˆŠâŠ¢)Â¨ at
}

ProcType â† {
  IsDig â† 1=0â€¿10â‹-âŸœ'0'
  Nat â† 10âŠ¸Ã—âŠ¸+ËœÂ´âˆ˜âŒ½ -âŸœ'0'
  Num â† {ğ•Šâ¼:â€¢Reprğ•©; (0<â‰ )â—¶1â€¿Nat IsDigâŠ¸/ğ•©}
  tâ€¿nâ€¿e â† ((1âŠË˜ğ•©)âˆ¾<"")âŠËœ(âŠË˜ğ•©)âŠ"type"â€¿"varname"â€¿"etype"
  pre â† ""
  t â†© " const" {câ†ğ•¨â‰¡(-â‰ ğ•¨)â†‘ğ•©â‹„preâˆ¾â†©câŠ"&*"â‹„(-cÃ—â‰ ğ•¨)â†“ğ•©}âŸœ((-1+' '=Â¯2âŠ¸âŠ‘)âŠ¸â†“)âŸ('*'â‰¡Â¯1âŠ¸âŠ‘) t
  {ğ•¤â‹„preâ€¿tâ†©"IMM"â€¿""}âŸ("IMM"âŠ¸â‰¡) e
  EP â† (âˆ¾Â·((â¥ŠÂ¨"uifbm")âŠ‘Ëœ"UI"â€¿"SI"â€¿"FP"â€¿"M"â€¿"MASK"âŠ¸âŠâŒ¾<)âŒ¾âŠ‘IsDigâŠ¸âŠ”) eË™
  tpâ€¿act â† <Ë˜â‰âˆ˜â€¿2â¥ŠâŸ¨
    "void"   , âŠ¢
    "int"    , "i32"
    "float"  , "f32"
    "double" , "f64"
    "__m"    , (âˆŠâŸœ"bm"âŒ¾<âŠ‘âˆ˜âŠ¢)â—¶âŸ¨("["âˆ¾"]"âˆ¾ËœÃ·âŒ¾Num)âˆ¾âŠ¢, âŠâˆ˜âŠ¢âˆ¾Â·IsDigâŠ¸/âŠ£âŸ©âŸœEP
    ""       , âŠ¢
  âŸ©
  act âˆ¾â†© âŸ¨EPâŸ© # Various integer types
  âŸ¨n, preâˆ¾(tpâŠ¸âŠâŒ¾<(âˆ§`âˆ˜Â¬IsDig)âŠ¸/)â—¶act tâŸ©
}

proto â† (Â¯1â†“âŸ(""â€¿"void"â‰¡âŠ‘)ProcTypeÂ¨)Â¨ GetVoid "return"â€¿"parameter"
cpuidâ€¿cat â† GetContâˆ˜(â¥Š<)Â¨ "CPUID"â€¿"category"
cpuid â†© isaList âŠ âŠ‘Â¨cpuid
#instrs â† 0â€¿1âŠ¸âŠ‘Â¨Â¨ GetVoid âŸ¨"instruction"âŸ©  # x86 instruction name

#âŒœ
# Singeli-specific adjustments; try to fix wrong signedness
_seg â† {(ğ”½Â·+`'_'âŠ¸=)âŠ¸/}
GetSname â† 3âŠ¸=_segâŠ¸(âˆ¾Ëœ)âŸ("_mask"âŠ¸â‰¡)âŸœ(2âŠ¸=_seg)
# Exclude intrinsics covered by basic.singeli
excl â† EËœâˆ˜=âŸœ' 'âŠ¸âŠ”"setr set set1 loadu load storeu store extract insert and or xor andnot add sub adds subs min max mullo mul slli srai srli sll sra srl sllv srav srlv cmpeq cmpgt cmp cmpneq cmpge cmplt cmple div sqrt floor ceil round abs sign avg shuffle shufflehi shufflelo permute permutevar permute2f128 permute2x128 permute4x64 permute8x32 permutevar8x32 unpacklo unpackhi bslli bsrli alignr blend blendv"
incl â† EËœâˆ˜=âŸœ' 'âŠ¸âŠ”"_mm_cmp_pd _mm_cmp_ps _mm256_set_m128 _mm256_set_m128d _mm256_set_m128i _mm256_setr_m128 _mm256_setr_m128d _mm256_setr_m128i _mm_mul_epu32 _mm_mul_epi32 _mm256_mul_epi32 _mm256_mul_epu32"
filter â† âˆ§Â´ âŸ¨
  (namesâˆŠincl) âˆ¨ Â¬((1â†“GetSname)Â¨ names)âˆŠexcl
  Â¬ âˆ¨Ë"_ss"â€¿"_sd"â€¿"1"(âŠ£â‰¡-âˆ˜â‰ âŠ¸â†‘)âŒœnames
  svml < cpuid<â‰ isaList
  Â¬ (âˆ¨Â´Â·("&b"âˆ§Â´âˆ˜âˆŠâŠ¢)Â¨1âŠ‘Â¨âŠ¢)Â¨ proto
  (âŠ‘'b'âˆŠ1âŠ‘âŠ‘)â—¶âŸ¨1,âŠ‘Â·(âŠâˆŠ1âŠ¸â†“)1âŠ‘Â¨âŠ¢âŸ©Â¨ proto
âŸ©
namesâ€¿protoâ€¿cpuidâ€¿cat filterâŠ¸/Â¨â†©

sname â† GetSnameÂ¨ names

pi â† ("pi"â‰¡Â¯2â†‘Â·(Â¬Â·âˆ¨`'0'âŠ¸â‰¤âˆ§'9'âŠ¸â‰¥)âŠ¸/(âˆ§`âŒ¾âŒ½'_'âŠ¸â‰ )âŠ¸/)Â¨names
pi âˆ§â†© Â¬snameâˆŠ"_mullo"â€¿"_srl"â€¿"_srli"â€¿"_srlv"â€¿"_abs"
proto ((-Â´"iu")Ã—(<<0â€¿1)Ã—'u'=âŠ¢)âŠ¸+âŒ¾(piâŠ¸/)â†©

id â† âŠ sname â‰Ë˜ 1â†“Â¨proto
Disamb â† { Uâ†{Â¬âˆ§Â´âˆŠğ•©} â‹„ ğ•© 2âŠ¸<_segÂ¨âŠ¸(âˆ¾Â¨ËœâŸUËœ)âŸU ("_"âˆ¾Â·Â¬âˆ˜âˆŠâŸœ"[]"âŠ¸/1âŠ‘âŠ‘)Â¨ğ•¨ }
sname âˆ¾Â¨â†© proto (1<â‰ âˆ˜âŠ¢)â—¶âŸ¨""Â¨,DisambâŸ©Â¨âŒ¾(idâŠ¸âŠ”) names

#âŒœ
# Format as Singeli definition
MakeDef â† {instr ğ•Š prot:
  # Utilities
  Brâ†"{"âˆ¾âˆ¾âŸœ"}" â‹„ Aâ†âˆ¾âŸœBr
  Intâ†â¥Š<âŠ¸(â‰Ë˜) â‹„ Jâ†âˆ¾1â†“Int
  # Type handling and formatting
  pnâ€¿pt â† <Ë˜â‰> prot
  anâ†1â†“pn â‹„ ! âˆŠâŸœ""â€¿"dst"â€¿"k"âŒ¾< âŠ‘pn
  pp â† "*&"âˆŠËœâŠ‘Â¨pt
  rtâ€¿at â† (âŠ‘â‹ˆ1âŠ¸â†“) ppâ†“Â¨pt
  ri â† "void"âŠ¸â‰¢â—¶âŸ¨â‰ at, atâŠ¸âŠâŒ¾<âŸ© rt
  iv â† "bm"âˆŠËœâŠ‘Â¨at â‹„ vf â† "IMM"âŠ¸â‰¢Â¨ at
  câ€¿i â† iv(<â‹ˆâˆ§)vfâˆ§âˆŠat # c for type constant, i for intvec
  uf â† vf âˆ§ (ri=â†•âˆ˜â‰ )âŠ¸âˆ¨ iv âˆ¨ Â¬(âˆŠâˆ§âˆŠâŒ¾âŒ½)at # Which types are named
  tn â† ufâ¥ŠÂ¨'T'- 1-Ëœ1â†“âŠ0âˆ¾ufÃ—1+âŠat
  vt â† at (0<â‰ âˆ˜âŠ£)â—¶âŸ¨"("âˆ¾")"âˆ¾ËœâŠ¢,âˆ¾âŸœ"=="âŠ¸âˆ¾âŸ©Â¨ËœâŒ¾(c/âŠ¢) tn
  par â† an âˆ¾Â¨ vf":"âŠ¸âˆ¾âŸâŠ£Â¨ (1â†“pp)"*"âŠ¸âˆ¾âŸâŠ£Â¨ vt
  conds â† (tn {"intvec"Aâˆ¾âŸ¨1â†“ğ•©,",",ğ•¨âŸ©}Â¨â—‹(i/âŠ¢) at) âˆ¾ "num"âŠ¸AÂ¨ vfÂ¬âŠ¸/an
  rt â†© "__pnt"âŠ¸AâŸ(âŠ‘pp) (â‰ at)âŠ¸=â—¶âŸ¨âŠ‘âŸœtn, rtâŸ© ri
  âˆ¾âŸ¨
    Br âˆ¾ 1â†“ (", " Int par) âˆ¾ " if "âŒ¾âŠ‘âŸ(0<â‰ ) " and " Int conds
    " = emit"
    Br ", "J âŸ¨rt, "'"(âˆ¾âˆ¾âŠ£)instrâŸ© âˆ¾ an
  âŸ©
}
defs â† cpuid âŠ”â—‹((â‹cat)âŠ¸âŠ) sname {âˆ¾"def _"â€¿ğ•¨â€¿ğ•©}Â¨ names MakeDefÂ¨ proto
â€¢Out 1âŒ½"
local {
  def intvec{w,T} = 0
  def intvec{(width{V}),V=[_]T if isint{T}} = 1
  def num{T} = is{'number',kind{T}}
}"
â€¢OutÂ¨ âˆ¾ 1â†“â¥Š(<2â¥Š<âŸ¨âŸ©) âˆ¾Ë˜ ("#"âŠ¸âˆ¾Â¨isaList) <âŠ¸â‰Ë˜ defs
