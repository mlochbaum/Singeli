# CPU architecture namespace, based on provided feature set argfeats
argfeatsâ€¿infer â† â‹ˆâŸœ0âŸ(0=â‰ ) â€¢args

archesâ€¿ReadDepsâ€¿ReadNativeâ€¿ToUpper â† â€¢Import "archutil.bqn"

# Process feature flags and detect architecture family
allfeats â† âˆ¾ archfeats â† {ğ•©.feats}Â¨ arches
AllNat â† âˆŠâŸœallfeatsâŠ¸/ ReadNative
MaybeNat â† "NATIVE"âŠ¸â‰¡Â¨ (Â¬âŠ¸/âˆ¾AllNat)âŸ((0=â‰ )âŠ¸(âˆ¨Â´)âŠ£) âŠ¢
arg â† âŸ¨"NONE"âŸ©âŠ¸â‰¢â—¶âŸ¨âŸ©â€¿MaybeNat ToUpper argfeats
all â† "ALL"âŠ¸â‰¡Â¨ arg
!âˆ˜(âˆ¾"Unknown features:"<âŠ¸âˆ¾' 'âˆ¾Â¨/âŸœarg)âŸ(âˆ¨Â´) Â¬allâˆ¨argâˆŠallfeats
"Incompatible features" ! âˆ¨Â´ supp â† (allÂ¬âŠ¸/arg)âŠ¸(âˆ§Â´âˆŠ)Â¨ archfeats
archDesc â† âŠ‘ supp / arches
widthâ€¿VecTypeâ€¿header â‡ âŸ¨anameâ‡nameâŸ© â† archDesc

# Parse dependencies for the chosen architecture
âŸ¨feats, matâŸ© â‡ {
  TSort â† {{ğ•ŠâŸ(ğ•©<â—‹â‰ âŠ¢)âŸœ(ğ•©âˆ¾Â·/ğ•¨âŠ¸<)ğ•¨âˆ¨âˆ§Â´âˆ˜âŠâŸœğ•¨Â¨p}âŸœ/0Â¨pâ†ğ•©} # Topological sort
  # d is a list of extension dependency chains
  u â† â·âˆ¾ d â† ReadDeps archDesc.ExtFile infer
  u âŠËœâ†© TSort âˆ¾Â¨ (âŠ¢âŠ”â—‹âˆ¾(Â¯1â†“â†‘)Â¨) (<u)âŠÂ¨d
  # Unique feature flags including arch name
  feats â‡ âŸ¨anameâŸ© âˆ¾ u
  # Make a dependency matrix: iâ€¿jâŠ‘m is 1 iff feature i depends on j
  m â† (â‰¥âŒœËœâ†•âˆ˜â‰ )âŠ¸Ã—âˆ¨Â´Ã—âŒœËœÂ¨(<u)âˆŠÂ¨d # Dependencies from file
  m âˆ¨Ëâˆ˜âˆ§â‰1â€¿âˆËœâŸ(âŒˆ2â‹†â¼â‰ )â†©        # Transitive closure
  mat â‡ 1 âˆ¾Ë˜ 0Â¨âˆ˜âŠâŠ¸âˆ¾ m         # Plus base architecture
}
baseArch â‡ âˆ¨Ëâˆ˜âˆ§âŸœmat (âˆ¨Â´all)â—¶âŸ¨âˆŠâŸœarg,1Â¨âŸ© feats

FeatInd â‡ { # ğ•¨ is 0 to allow features outside current architecture
  i â† feats âŠ ğ•©
  m â† (i=â‰ feats)/â—‹â¥Šğ•©
  !âˆ˜(âˆ¾"Unknown architecture features:"<âŠ¸âˆ¾' 'âˆ¾Â¨/âŸœm)âŸ(âˆ¨Â´) Â¬mâˆŠallfeats
  !âˆ˜(1â†“Â·âˆ¾' 'âˆ¾Â¨âŸ¨"Features not in",aname,"architecture:"âŸ©âˆ¾âŠ¢)âŸ(0<â‰ )âŸğ•¨ m
  i
}

# For external tools, return base architecture as C compiler flags
GetCFlags â‡ {ğ•Š:
  "-m"âŠ¸âˆ¾Â¨ ((-Â´"aA")Ã—'A'âŠ¸â‰¤âˆ§â‰¤âŸœ'Z')âŠ¸+ (baseArch âˆ§ (aname)âŠ¸â‰¢Â¨)âŠ¸/ feats
}
