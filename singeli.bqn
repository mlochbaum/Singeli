cpuâ€¿libpathsâ€¿configs â† â€¢args

tabâ€¿lfâ†@+9â€¿10

dig â† '0'+â†•10
alphâ† "_"âˆ¾â¥Š"aA"+âŒœâ†•26
wc  â† digâˆ¾alphâˆ¾"."       # Word characters
oc  â† "!$%&*+-/<=>?\^|~" # Operator characters that can stick together

# Source to list of token strings
Tokenizeâ†{
  ğ•©+â†©ğ•©(=Ã—lfâŠ¸-)@+13                          # Convert CR to LF
  ğ•©âˆ¾â†©lf(â‰ â¥ŠâŠ£)Â¯1â†‘ğ•©                            # Trailing newline
  # Resolve comments and strings
  sâ€¿dâ€¿câ€¿nâ†ğ•©âŠ¸=Â¨"'""#"âˆ¾lfâ‹„sdâ†/Â¨sâ€¿d
  gâ†â‹qâ†(Â¯1â†“Â¨sd)âˆ¾âŠ¸âˆ¾/c â‹„qâ†©gâŠq                 # Open indices
  eâ† gâŠ( 1â†“Â¨sd)âˆ¾âŠ¸âˆ¾-âŸœÂ»âˆ˜âŠâŸœ(0âˆ¾+`c)âŠ¸//nâˆ¾1       # Matching close indices
  Seâ†â‰ (>/âŠ¢)âˆ¾âŸœâ‰ {(âŠËœğ•¨)ğ•ŠâŸ(â‰ â—‹(Â¯1âŠ¸âŠ‘))ğ•©âˆ¾ğ•©âŠğ•¨}âŸ¨0âŸ©Ë™  # Find reachable openings
  aâ€¿bâ†((â‰ ğ•©)â†‘Â·/â¼(Se qâ‹e)âŠ¸âŠ)Â¨qâ€¿e              # Open/close masks
  kâ†Â»â‰ `abâ†aâˆ¨b                               # Token continuation mask
  {âŸ¨âŠ‘/ğ•©,"Unclosed quote"âŸ©!0}âŸ(âˆ¨Â´)(sâˆ¨d)>kâˆ¨a
  ignâ†(ğ•©âˆŠ" "âˆ¾tab)âˆ¨â‰ `abâˆ§câˆ¨n                  # Ignored characters
  # Other stuff
  daâ†(Â»ğ•©='.')âˆ§ğ•©âˆŠalph                        # Don't group ...word
  kâˆ¨â†©da<âˆ¨Â´(Â»âŠ¸âˆ§k<ğ•©âŠ¸âˆŠ)Â¨wcâ€¿oc                  # Group names, numbers, and ops
  btâ†(âŒˆ`â†•âˆ˜â‰ Ã—Â¬)k â‹„ xdâ†ğ•©âˆŠdig
  kâˆ¨â†©Â»âŠ¸âˆ¨(Â»(btâŠxd)âˆ§ğ•©='e')âˆ§(ğ•©='-')âˆ§Â«xd        # Negative exponents 12e-3
  tsâ†nâˆ¨Â¬kâˆ¨ign                               # Token start mask
  lcâ†(1+/ğ•©=lf){(âŠ¢â‹ˆÂ¨ğ•©-âŠâŸœ(0âˆ¾ğ•¨))ğ•¨â‹ğ•©}/ts        # Line/column numbers
  âŸ¨ğ•©âŠ”Ëœ1-Ëœ(ign>â‰ `abâˆ§sâˆ¨d)Â¬âŠ¸Ã—+`ts, ğ•¨ Source ğ•©â€¿lcâŸ©
}

# Position handler for error reporting
Source â† { ğ•¨ ğ•Š srcâ€¿lc: fileâ†ğ•¨âŠ£""
  { pos ğ•Š disp:
    râ€¿câ†<Ë˜â‰>posâŠlc
    â€¢Out âˆ¾âŸ¨file, ":", â€¢Repr 1+eâ†Â¯1âŠ‘r, ":"âŸ©
    â€¢Out src/Ëœ(src=lf)(âŠ£<+`âŠ¸=)e
    Tr â† {
      e â† (+`(ğ•©â‰¤Â¯1Â»ğ•¨â‰ âŠ¸+Â¨ğ•©))âŠ”ğ•©â‹ˆÂ¨ğ•¨
      l â† "^"âŒ¾(1âŠ‘Â¯1âŠ‘âŠ‘) âŒ½ "|"âŒ¾(1âŠ¸âŠ‘)Â¨âŠ¸âˆ¾` (1+â‰ e)â†‘e
      {âˆ¾((-âŸœÂ»ğ•¨)âˆ¾â‰ Â¯1âŠ‘ğ•©)â†‘Â¨""<âŠ¸âˆ¾ğ•©}Ëâˆ˜â‰âˆ˜>Â¨ l
    }
    â€¢OutÂ¨ disp Trâ—‹((r=e)âŠ¸/) c
  }
}
DispSource â† {ğ•ğ•©}Â´
Err â† { (ğ•©â‰ âŠ¸â¥Šâ€¢Outâ€¿DispSource) {ğ•ğ•©}Â¨ ğ•© â‹„ â€¢Exit 1 }

# Parameter checks for builtins (_p1 and _p2 to use BQN monad/dyad)
_e1 â† {ğ”½âŠ£"Expected one parameter" !1=â‰ } â‹„ _p1â†{ğ”½âŠ‘_e1}
_e2 â† {ğ”½âŠ£"Expected two parameters"!2=â‰ } â‹„ _p2â†{ğ”½Â´_e2}
_e3 â† {ğ”½âŠ£"Expected three parameters"!3=â‰ }
_v1 â† {ğ”½âŠ£"Expected at least one parameter"!1â‰¤â‰ }

numbers â† {knameâ‡"number"
  f â† â€¢Import "float2.bqn"
  NN â† 1â‰ â€¢Type  # Not native number
  Is â† knameâ‰¡{Kindğ•©}
  Wrap â† {kindâ‡knameâ‹„valueâ‡ğ•©â‹„Matchesâ‡Matchâ‹„Showsâ‡FmtLargeâˆ˜ğ•©}
  Unwrap â† {6=â€¢Typeğ•©?knameâ‰¡ğ•©.kind?ğ•©.value; !"Expected constant number"}
  Promote â† NNâ—¶f.Toâ€¿Unwrap
  From â‡ f.Fromâˆ˜UnwrapâŸNN
  GetBool â‡ {"Boolean expected"!âŠ‘ğ•©âˆŠ0â€¿1â‹„ğ•©}âˆ˜From
  Match â‡ âˆ§â—‹Isâ—¶âŸ¨0,â‰¡â—‹PromoteâŸ©

  _be â† {ğ•—âŠ¸Ã—âŠ¸+ËœÂ´âŒ½âˆ˜âŠ¢}
  Nat â† (10 _be âŠ£ "Ill-formed number"!Â·âˆ§Â´0âŠ¸â‰¤âˆ§â‰¤âŸœ9) -âŸœ'0'
  LC â† +âŸœ(32Ã—1="A["âŠ¸â‹) '_'âŠ¸â‰ âŠ¸/  # Lowercase, underscores removed
  da â† digâˆ¾'a'+â†•26
  Read â‡ {
    (â‰ ğ•©)>sâ†âŒŠÂ´ğ•©âŠ"bx" ? # Base n with 0x9abc or 31bNUMBER
      b â† ('b'=sâŠ‘ğ•©)â—¶âŸ¨16âŠ£Â·!"0"âŠ¸â‰¡,NatâŸ© sâ†‘ğ•©
      "Invalid base" ! bâ‰¤â‰ da
      d â† (bâ†‘da) (â‰ âˆ˜âŠ£(âŠ¢âŠ£"Invalid digits"!âˆ§Â´âˆ˜>)âŠ) (1+s)â†“ğ•©
      Eâ†b _be â‹„ EEâ†{hâ€¿lâ†f.Toâˆ˜EÂ¨ğ•¨-âŠ¸(â†“â‹ˆâ†‘)ğ•©â‹„Wrap l f.Add (f.To bâ‹†ğ•¨)f.Mul h}
      (âŒŠ53Ã·2â‹†â¼b) <âŸœâ‰ â—¶Eâ€¿EE d
    ;
      _n â† {('-'=âŠ‘)â—¶âŸ¨ğ”½, -âˆ˜ğ”½ 1âŠ¸â†“âŸ©}
      Pos â† âŠâŸœ"."âŠ¸(Natâˆ˜â†‘ + Â·(0<â‰ )â—¶âŸ¨0,NatÃ·10â‹†â‰ âŸ©+âŸœ1âŠ¸â†“)
      âŠâŸœ"e"âŠ¸(Pos _nâˆ˜â†‘ Ã— <âŸœâ‰ â—¶âŸ¨1,10â‹†Â·Nat _n+âŸœ1âŠ¸â†“âŸ©) ğ•©
  }âŸœLCâŠ{ErrâŸ¨â€¢CurrentError@,ğ•¨âŸ©}

  InRange â† {1=âŠ‘0â‹Ëœ-ËœÂ´âŸœ(âŒ½ğ•¨)Â¨ğ•©}
  FmtLarge â† {
    âŒŠâŠ¸â‰¡ğ•© ? (aâ†f.Abs ğ•©) InRange 2â‹†48â€¿64 ? ğ•© InRange -âŒ¾âŠ‘2â‹†63â€¿64 ?
      ((ğ•©â‰¢a)/"-")âˆ¾"0x"âˆ¾daâŠËœâŒ½ 16â€¿16 f._repr a ;
    FmtNum f.From ğ•©
  }

  Cast â‡ {'f'â€¿lğ•Šn:1; qâ€¿lğ•Šn: # 1 if valid; error otherwise
    n NNâ—¶â‹ˆâ€¿Unwrapâ†©
    "Cannot cast float to integer"!âŒŠâŠ¸â‰¡n
    "Constant doesn't fit"!n InRange -âŸœ(1âŠ¸âŠ‘Ã·2Ë™)âŸ(q='i') âŸ¨0,2â‹†lâŸ©
  }
  builtins â‡ {
    Wâ†Wrap â‹„ Pâ†{ğ•Š:Promoteğ•© ; ğ•Šâ¼:Wğ•©} â‹„ Bâ†f.Bitsâˆ˜P
    Eâ†f.To 2â‹†From
    prâ€¿val â† <Ë˜â‰âˆ˜â€¿2â¥Š âŸ¨
      âŠ¢        ,âŸ¨"neg",NNâ—¶âŸ¨-,Wâˆ˜f.Negâ—‹UnwrapâŸ©âŸ©â€¿âŸ¨"not",Â¬GetBoolâŸ©
      {ğ•âŒ¾P}    ,âŸ¨"add"â€¿f.Add, "sub"â€¿f.Sub, "mul"â€¿f.Mul, "div"â€¿f.Div, "mod"â€¿f.ModâŸ©
      {W PâŠ¸ğ•âŸœE},âŸ¨"shl", f.MulâŸ©â€¿âŸ¨"shr", f.Floor f.DivâŸ©
      {ğ•âŒ¾B}    ,âŸ¨ "and"â€¿âˆ§, "or"â€¿âˆ¨, "xor"â€¿â‰  âŸ©
    âŸ©
    arg â† 1â€¿3/{ğ•_p1}â€¿{ğ•_p2}
    â‰>âˆ¾ (arg {ğ•âˆ˜ğ•}Â¨ {{ğ•âš‡0}âˆ˜ğ•âš‡0}Â¨ pr) {âŸ¨"__"âŠ¸âˆ¾,ğ•âŸ©âŠ¸({ğ•ğ•©}Â¨)Â¨ğ•©}Â¨ val
  }
  _cmp â‡ {(f.Cmp ğ”½ 0Ë™)â—‹Promote}
}

ptrWidth â† cpu.width
architecture â† {
  featsâ€¿matâ€¿FeatInd â† cpu
  init â‡ cpu.baseArch
  # Look up a list of symbols
  Id â† {ğ•¨ FeatInd "Expected symbol for architecture feature"âŠ¸symbols.FromÂ¨ğ•©}
  # An architecture is a mask of supported features
  New â‡ { ğ•¨ âˆ¨Ë (1 Id ğ•©) âŠ mat }
  Contains â‡ âˆ§Â´â‰¥
  Intersect â‡ âˆ§ â‹„ Union â‡ âˆ¨
  Has â‡ âˆ§Â´{(0 Id ğ•©)âŠğ•¨âˆ¾0}  # Has all in list ğ•©
  List â‡ /âŸœfeats
  ListExt â‡ List initâŠ¸<
  # Architecture to be used for the next function created
  next â† init
  SeeNext â‡ {ğ•Š:next}
  NewFunction â‡ {ğ•Š: râ†next â‹„ nextâ†©init â‹„ r }
  With â‡ { NewFunction âŠ¢ (âŠ‘ğ•©){ğ”½} âŠ£ {nextâ†©ğ•©}âˆ˜(New 1â†“ğ•©) }_v1
}

MakeStack â† {ğ•¤
  stâ†@ â‹„ dâ†0
  Pushâ‡{   stâ†©ğ•©â€¿st â‹„ d+â†©1}
  Pop â‡{ğ•¤â‹„ râ€¿sâ†st â‹„ stâ†©s â‹„ d-â†©1 â‹„ r}
  Arr â‡{ğ•¤â‹„ âŠ‘Â¨ âŒ½ 1âŠ¸âŠ‘âŸ(â†•d) st}
  _while_â‡{Pop âŠ¢ ğ”½ âŠ£ Â·Pushğ•˜Ë™}
}

MakeStream â† {
  lenâ†â‰ srcâ†ğ•© â‹„ iâ†0
  Pos  â‡ {ğ•¤â‹„i}
  Inc  â† {ğ•¤â‹„i+â†©1}
  Rem  â‡ {ğ•¤â‹„i<len}
  Peek â‡ {ğ•¤â‹„iâŠ‘src}
  Next â‡ Inc âŠ¢ Peek
  Dec  â‡ {ğ•¤â‹„i-â†©1}
}

Parse â† {ğ•Š tokensâ€¿ShowTrace:
  sep â† âŸ¨";", â¥ŠlfâŸ©
  ! âŠ‘ (Â¯1âŠtokens) âˆŠ sep

  Asrt â† {ğ•¨ğ•Š1:@;
    lâ†{(c â€¢ns.GetÂ¨ ğ•©)âŠ¸âŠ âŠ ğ•©Ë™} â€¢ns.Keys c
    ShowTraceâŸœLÂ´ <Ë˜â‰>DumpStack@
    â€¢Out ""
    F â† (â¥Šlf)âŠ¸â‰¡â—¶â€¢Reprâ€¿"end of line"
    â€¢Out {âˆ¾"Expected "â€¿ğ•¨â€¿" but saw "â€¿ğ•©}âŸœFÂ´âŸ(1<â‰¡) ğ•¨
    â€¢Exit 1
  }
  MakeTokStream â† {
    iâ†âŠğ•© â‹„ uâ†ğ•©/Ëœi>Â¯1Â»âŒˆ`i
    âŸ¨Incâ‡Next,PeekRawâ‡PeekâŸ©â†âŸ¨Pos,Rem,Backâ‡DecâŸ©â‡MakeStream i
    PeekRaw â†© PeekRaw âŠ£ "File ended unexpectedly" Asrt Rem
    Peek â† âŠ‘âŸœuâˆ˜PeekRaw
    Try  â‡ 1âˆ˜IncâŸâŠ¢ PeekâŠ¸â‰¡
    Get  â‡ Inc (â€¢ReprâŠ¸â‹ˆ Asrt 0Ë™)âŸâ‰¢âŸœPeek
    # Faster tests on raw tokens
    _test â‡ {(ğ”½Â¨u)âŠ‘ËœPeekRaw}
    firstâ†âŠ‘Â¨u
    _begin_ â‡ {tâ†ğ”½ first â‹„ Inc âŠ¢ (âŠ‘âŸœu (âŠ£ âŠ£ ğ•˜âŠ¸â‹ˆâŠ¸Asrt) âŠ‘âŸœt)âˆ˜PeekRaw}
    GetS â† âŠ¢ {Inc (((â€¢Reprğ•¨)â‹ˆâŠ‘âŸœu) Asrt 0Ë™)âŸ(ğ•©âŠ¸â‰¢)âˆ˜PeekRaw}Â¨ uâŠ¸âŠ
    _seq â‡ {aâ†0=â€¢TypeÂ¨ğ•— â‹„ (Â¬a)/{ğ•@}Â¨âˆ˜(GetSâŒ¾(aâŠ¸/)ğ•—) }
    _opt_ â‡ {@_ğ•£_ğ•˜:
      tâ€¿c â† (1âŒ¾(Â¯1âŠ¸âŠ‘)2|â†•âˆ˜â‰ )âŠ¸âŠ” ğ•˜
      exp â† "one of "âˆ¾âˆ¾âŸœ", "âŠ¸âˆ¾Â´â€¢ReprÂ¨t
      (âŠ‘(uâŠt)âŠPeekRaw)â—¶(câˆ¾âŸ¨(expâ‹ˆPeek) Asrt 0Ë™âŸ©)
    }
    _optGet_ â‡ {@_opt_({ğ•âŠ£Inc}Â¨âŒ¾((2|â†•âˆ˜â‰ ğ•˜)âŠ¸/)ğ•˜)}
    _any â‡ {âŠ‘(uâŠğ•—)âˆŠËœPeekRaw}
    _anyTry â‡ {1âˆ˜IncâŸâŠ¢âˆ˜(ğ•—_any)}
  }
  âŸ¨Get,Try,Rem,Pos,Back,_test,_begin_,_seq,_opt_,_optGet_,_anyTry,_anyâŸ© â† MakeTokStream tokens

  # Node creation and error tracking
  c â† nodes
  âŸ¨_whileParse_â‡_while_, DumpStackâ‡ArrâŸ© â† MakeStack@
  _node_ â† {pâ†Pos@ â‹„ (ShowTraceâ—‹â‹ˆâŸœ""âŠ¢)â€¿p ğ”½ ğ”¾_whileParse_âŸ¨p,ğ•—âŸ© ğ•©}

  When  â† {Testâ€¿Cont:       ( â¥Šâˆ˜< Cont)âŸTest   âŸ¨âŸ©  }
  While â† {Testâ€¿Contâ€¿init: {(ğ•Šâˆ¾âŸœ<âŸœCont)âŸTestğ•©} ContÂ¨â†•init}

  _ifASCII â† {(@+128)âŠ¸â‰¤âˆ¨ğ”½}
  Name â† âˆŠâŸœalph _begin_ "name"
  Oper â† âˆŠâŸœoc _ifASCII _begin_ "operator"
  Symbol â† c.symbol _node_ ('''âŠ¸=_begin_"symbol")
  IsLogic â† âˆŠâŸœ"and"â€¿"or"â€¿"not"âŒ¾<

  LFs â† {ğ•ŠâŸTry âŸ¨lfâŸ©}
  Div â† {LFs@ â‹„ 1âˆ˜LFsâŸâŠ¢ Try ğ•©}  # Divider, allowing surrounding newlines
  TrySep â† sep _anyTry
  Seps â† {Rem@ ? TrySep@ ? ğ•Šğ•©â‹„1 ; 0}

  _decl_ â† { ğ”½"Declaration" â‹„ Declare ğ”¾ ğ•© }
  _exprStmt â† {AsrtStmt _ğ•£: @_opt_âŸ¨
  "if",     { StIf ğ•© }
  "while",  { StWhile ğ•© }
  "do",     { DoWhile ğ•© }
  "@",      { For ğ•© }
  "extend", { Extend ğ•© }
  "def",    { Define ğ•© } âŠ£ AsrtStmt
  "fn",     { DefFun ğ•© } âŠ£ AsrtStmt
  "oper",   { OpDef ğ•© }  âŠ£ AsrtStmt
  "{",      @_optGet_âŸ¨"=>", c.lambda _node_ (â‹ˆâŸœ{Blockğ•©})
                      ":",  AsrtStmt _decl_ âŠ¢           âŸ© {Paramsğ•©}
            { AsrtStmt _decl_ ToIdâŸ(Try":") SimpExpr ğ•© }
  âŸ©}
  Expr â† (âˆ¾âŸœ" must appear on its own line" Asrt 0Ë™) _exprStmt
  Stmt â† âŠ¢ _exprStmt

  Vec â† c.run _node_ (c.wordâˆ˜"__vec" â‹ˆ "["â€¿Exprâ€¿"]"â€¿{Expr0ğ•©} _seq)
  Par â† âŠ‘ "("â€¿Exprâ€¿")" _seq
  EWord â† c.token _node_ (âˆŠâŸœ('''âˆ¾wcâˆ¾oc)_ifASCII _begin_ "expression")
  Expr0 â† @_opt_âŸ¨"[",Vec, "(",Par, EWordâŸ©

  _spreadable â† {<âˆ˜âŠ¢âŸâŠ£âŸœğ”½âˆ˜Tryâˆ˜"..."}
  _args â† {ğ•— _argsFn_ (Expr _spreadable)}
  _argsFn_ â† {ğ•¤
    Get âŠ‘ğ•—
    Try 1âŠ‘ğ•— ? âŸ¨âŸ© ;
    LFs@
    a â† While âŸ¨Divâˆ˜",", ğ”¾, 1âŸ©
    Get 1âŠ‘ğ•—
    a
  }
  AddParams â† @_opt_âŸ¨"{", {AddParamsâˆ˜(c.run  _node_ (âŠ¢â‹ˆ"{"â€¿"}"_args)) ğ•©}, âŠ¢âŸ©
  AddArgs   â† @_opt_âŸ¨"(", {          (c.call _node_ (âŠ¢â‹ˆ"("â€¿")"_args)) ğ•©}, âŠ¢âŸ©
  Callable â† AddParamsâˆ˜Expr0
  CanCall â† (Â¬IsLogicâˆ¨Â´(ocâˆ¾"[")=âŠ) _test
  StartsOp â† (IsLogic âˆ¨ Â·âŠ‘âˆŠâŸœoc _ifASCIIâˆ˜âŠ‘) _test
  Call â† { câ†CanCall @ â‹„ AddArgsâŸc Callableğ•© }

  ExprFromEnd â† {ğ•Š endTok:
    End â† (endTokâˆ¾sepâˆ¾â¥ŠÂ¨",:)}]")_any
    {
      o â† StartsOp ğ•©
      Cont â† {pâ†o â‹„ pâˆ¨oâ†©StartsOp ğ•©}_and_(Â¬End)
      c.phrase _node_ (Whileâˆ˜âŸ¨Cont, Call, 1âŸ©) ğ•©
    }
  }
  SimpExprâ€¿TypeExprâ€¿CondExpr â† ExprFromEndÂ¨ âŸ¨âŸ©â€¿âŸ¨"="âŸ©â€¿âŸ¨"&"âŸ©

  # ğ•© is the expression preceding ":"
  Declare â† c.declare _node_ {
    n â† ğ•©
    t â† When âŸ¨Â¬Try"=", Getâˆ˜"=" âŠ¢ TypeExprâŸ©
    âŸ¨n,t,Expr@âŸ©
  }
  ToId â† {ğ•©.IsDef@â‹„ğ•©} c.PhraseTryWord

  _lines_ â† { Line _ğ•£_ Cont ğ•©:
    Seps @ â‹„ s â† 1
    SepLine â† {"Expected separator" Asrt s â‹„ lâ†Lineğ•© â‹„ sâ†©Seps@ â‹„ l}
    While âŸ¨Cont, SepLine, 0âŸ©
  }
  _blockLines â† { âŠ‘ âŸ¨"{", ğ”½ _lines_ (Â¬Tryâˆ˜"}")âŸ©_seq }
  Body â† Stmt _blockLines
  Block â† @_opt_âŸ¨"{",c.body _node_ Body, ExprâŸ©

  _if â† {
    TrySeps â† {sâ†Seps@ â‹„ BackâŠ¸âŠ¢âŸ(s>âŠ¢) Remâ—¶0â€¿Try ğ•©}
    "if"â€¿"("â€¿Exprâ€¿")"â€¿ğ”½â€¿(Whenâˆ˜âŸ¨TrySepsâˆ˜"else",ğ”½âŸ©)_seq
  }
  StIf â† c.if _node_ (Block _if) 
  StWhile â† c.while _node_ (1 âˆ¾   "while"â€¿"("â€¿Exprâ€¿")"â€¿Block _seq)
  DoWhile â† c.while _node_ (0 âˆ¾âŸœâŒ½ "do"â€¿Blockâ€¿"while"â€¿"("â€¿Exprâ€¿")" _seq)

  For â† c.for _node_ {ğ•¤
    OAâ† "@for: multiple variables must use ""over"""âŠ¸Asrt
    TAâ† "@for: ""from"" missing ""to"""âŠ¸Asrt
    NAâ† "@for: loop variable must be a name"âŠ¸Asrt
    Get "@"
    f â† Callable@
    Get "("
    toâ† SimpExpr@
    NEâ† {ğ•¤â‹„ nâ†â‹ˆâˆ˜{NA@â‰¢ğ•©â‹„ğ•©}âˆ˜c.PhraseTryNameâŸğ•© to â‹„ toâ†©SimpExpr@ â‹„ n}
    {Try"in"? toâ†©âŸ¨âŠ‘NE 1,toâŸ©; @}
    peâ† While âŸ¨Tryâˆ˜",", Tryâˆ˜"in"â—¶âŸ¨â‹ˆ,â‹ˆâŸœSimpExprâŸ© Name, 0âŸ©
    psâ† {Try"over"?(<NE 0==to)âˆ¾ğ•©; OA 0=â‰ ğ•©â‹„âŸ¨âŸ©} pe          # Pointers
    frâ† When âŸ¨Try"from", SimpExprâŸ©                        # Start index
    i â† {Â¬Try"to"?TA 0=â‰ frâ‹„âŸ¨âŸ©; 0<=to?psâˆ¾â†©<NE 0â‹„âŸ¨âŸ©; NE 1}  # Index variable
    Get ")"
    b â† Block@
    âŸ¨f,ps,i,fr,to,bâŸ©
  }

  # ğ•© indicates if preceding token was =
  Result â† c.body _node_ (@_opt_âŸ¨
    "{", Body
    "@", â‹ˆFor
         â‹ˆâˆ˜Expr "Missing = before body?"AsrtâŠ¢
  âŸ©)

  Params â† c.params _node_ {ğ•¤
    Get "{"
    Try "}" ? (0â¥Š<â†•4)â€¿âŸ¨âŸ© ;
    Param â† {ğ•¤
      v â† Try "..."
      n â† Name@
      e â† When âŸ¨     Try "==", CondExprâŸ©
      t â† When âŸ¨(â‰ e)â—¶Tryâ€¿0":", CondExprâŸ©
      vâ€¿nâ€¿eâ€¿t
    }
    vm â† "At most one variable-length parameter allowed"
    LFs@
    a â† While âŸ¨Divâˆ˜",", Param, 1âŸ© â‹„ vm Asrt 1â‰¥+Â´âŠ‘Â¨a
    c â† While âŸ¨Divâˆ˜"&", CondExpr, 0âŸ©
    Get "}"
    aâ€¿c
  }
  _withParams â† {
    Rec â† @_opt_âŸ¨"{",c.lambda _node_ (Paramsâ€¿{Recğ•©} _seq), ğ”½âŸ©
  }
  IdTarget â† c.newId _node_ Name
  Target â† @_opt_âŸ¨"{",Params, IdTargetâŸ©

  Arg â† c.arg _node_ ((Tryâˆ˜"...")â€¿Nameâ€¿":"â€¿SimpExpr _seq)
  Function â† c.function _node_ {ğ•¤
    a â† "("â€¿")" _argsFn_ Arg @
    r â† When âŸ¨Try":", TypeExprâŸ©
    b â† Result Try"="
    âŸ¨a,r,bâŸ©
  } _withParams
  DefFun â† c.define _node_ ("fn"â€¿IdTargetâ€¿Function  _seq)
  
  ExtPar â† "{"â€¿"}" _argsFn_ Name
  Extender â† c.extender _node_ (ExtParâ€¿"="â€¿Body _seq)
  Extend â† c.extend _node_ ("extend"â€¿Expr0â€¿ExtPar _seq)

  Generator â† {ğ•¤â‹„ Get"=" â‹„ Result 1} _withParams
  Define â† c.define _node_ {
    Get "def" â‹„ e â† Try "extend"
    âŸ¨Target, eâ—¶Generatorâ€¿ExtenderâŸ©_seq ğ•©
  }
  confNameâ€¿confVal â† (âŠ‘Â¨â‹ˆ1âŠ¸âŠ‘Â¨)configs
  Config â† c.define _node_ {
    Get "config"
    tâ€¿r â† âŸ¨IdTarget, "=", Resultâˆ˜1âŸ©_seq ğ•©
    n â† t.name
    tâ€¿{ (â‰ confName) > iâ†confNameâŠ¸âŠâŒ¾<n ? ("config "âˆ¾n) ast.Build iâŠ‘confVal ; r }
  }

  OpType â† @_optGet_âŸ¨
    "prefix", 'p'
    "infix",  @_optGet_(âŸ¨'n'âŸ©âˆ¾Ëœâˆ¾â‹ˆâŸœâŠ‘Â¨"none"â€¿"left"â€¿"right")
  âŸ©
  Number â† c.number _node_ (âˆŠâŸœdig _begin_ "number")
  OpDef â† c.opDef _node_ ("oper"â€¿Operâ€¿Nameâ€¿OpTypeâ€¿Number _seq)

  Include â† c.include _node_ ("include"â€¿Symbol _seq)

  MultiLine â† {Lineğ•©} _blockLines
  TopIf â† c.topif _node_ (âˆ¾âŒ¾(Â¯1âŠ¸âŠ‘) @_opt_âŸ¨"{",MultiLine, â‹ˆ{Lineğ•©}âŸ© _if)
  SubLine â† @_opt_âŸ¨"include",Include, "if",TopIf, "config",Config, StmtâŸ©
  LocLine â† @_opt_âŸ¨"if","localizable line"âŠ¸â‹ˆ Asrt 0Ë™, SubLineâŸ©
  Line â† @_optGet_âŸ¨
    "local", @_opt_âŸ¨"{",c.body _node_ MultiLine, LocLineâŸ©
             {ğ•©.NonLocal@â‹„ğ•©}âˆ˜SubLine
  âŸ©

  Program â† c.body _node_ (Line _lines_ Rem)

  Program @
}

operator â† {
  Parse â‡ {
  âŸ¨opâŸ© ğ•Š âŸ¨vâŸ©: vâŠ£Â´{ğ•©.V@}Â¨@âŠ¸â‰¢Â¨âŠ¸/op.leftâ€¿op.null ;
  ops ğ•Š val:
    Peekâ€¿Nextâ€¿Rem â† MakeStream ops {nullâ€¿leftâ€¿bindâ€¿Râ‡ğ•¨ â‹„ valueâ‡ğ•©}Â¨ val
    E â† {ğ•Štest: {ğ•Šâˆ˜{ğ•© LeD Next@}âŸ(Test Peek)âŸRem ğ•©} NuD Remâ—¶Misâ€¿Next@ }
    NuD â† { ğ•©.null â‰¢âŸœ@â—¶{ğ•©.value}â€¿{ğ•© Run âŸ¨ğ•©.R ğ•¨.V@, âŸ¨E ğ•¨.tâŸ©âŸ©} ğ•© }
    LeD â† { UnkâŸ(@â‰¡lâ†ğ•©.left)ğ•© â‹„ ğ•© Run âŸ¨ğ•©.R l.V@, âŸ¨ğ•¨, E l.tâŸ©âŸ© }
    Run â† {ğ•©.value.pos}âŠ¸nodes.Run
    Unk â† { Err "Unknown infix operator"â€¿ğ•©.value.pos }
    Mis â† {ğ•Š: Err "Missing right operand"â€¿(Â¯1âŠ‘val).pos }
    E 1
  }
  Run â‡ {ğ•¨ğ•ŠâŸ¨op,paramsâŸ©:
    Par â† ğ•¨ nodes.Run â‹ˆâŸœparams
    nullâ€¿left â‡ {âŸ¨TâŸ©â‡ğ•© â‹„ Vâ‡Parâˆ˜ğ•©.V}âŸ(@âŠ¸â‰¢)Â¨ op.nullâ€¿op.left
    bindâ€¿Râ‡op
  }
  Compose â† {preğ•Šin: âŸ¨nullâŸ©â‡pre â‹„ leftâ€¿bindâ‡in â‹„ Râ‡âŠ¢ }
  nil â‡ { nullâ‡leftâ‡@ â‹„ bindâ‡Â¯âˆ â‹„ Râ‡âŠ¢ }

  Tab â‡ { par ğ•Š new:
    pâ†nâ†oâ†âŸ¨âŸ©  # pos, name, output
    Ind â† { nâŠ¸âŠâŒ¾<ğ•© }
    Add â‡ {
      i â† Ind 1âŠ‘ğ•©
      i<â‰ n ? ErrâŸ¨"Duplicate operator definition:",âŠ‘ğ•©,"Previously defined here:",iâŠ‘pâŸ© ;
      pâ€¿nâ€¿o âˆ¾âŸœ<Â¨â†© râ†(1âŠ‘ğ•©)âŠ¸NewâŒ¾(2âŠ¸âŠ‘)ğ•© â‹„ 2âŠ‘r
    }
    Get â‡ { iâ†Indğ•© â‹„ (i=â‰ n)â—¶âŸ¨iâŠ‘oË™,par.GetâŸ© ğ•© }
  }
  NewScope â‡ {
    parent â‡ ğ•©
    Op â† {nameğ•Švalâ€¿pâ€¿câ€¿a:
      V â‡ nodes.Wordâˆ˜val
      AC â† { Err ("Associativity for operator "âˆ¾nameâˆ¾" must be disambiguated")â€¿ğ•¨.value.pos }âŸ(0âŠ¸>)
      T â‡ (p C {ğ•©.bind}){{âŠ£ACğ•}âŸağ•—}
    }
    tabs â‡ nulâ€¿lef â† parent.tabs TabÂ¨ âŸ¨
      {ğ•¨ğ•ŠâŸ¨value, precâŸ©: null â‡ ğ•¨ Op âŸ¨value, prec, <, 0âŸ© }
      {ğ•¨ğ•ŠâŸ¨value, prec, assocâŸ©:
        bind â‡ prec
        left â‡ ğ•¨ Op âŸ¨value, prec, ("lrn"âŠ¸âŠâŒ¾<assoc)âŠ‘âŸ¨<,â‰¤,<-=âŸ©, 'n'=assocâŸ©
      }
    âŸ©
    Add â‡ {ğ•¨ğ•Štypeâ€¿nameâ€¿valueâ€¿prec:
      lâ†typeâ‰ 'p'
      (lâŠ‘tabs).Add âŸ¨ğ•¨, name, valueâ€¿precâˆ¾lâ¥ŠtypeâŸ©
    }
    Lookup â‡ nul.Get Compose lef.Get
  }
  nilScope â‡ { tabs â‡ 2â¥Š{Getâ‡nilË™} } # Lookup â‡ nilË™
  CondScope â‡ { ğ•Š par:
    parentâ€¿tabsâ€¿Add â‡ par
    Lookup â‡ {@â‰¢câ†nodes.CondOpğ•©?c; par.Lookup ğ•©}
  }
}


# Runtime
# Kinds are:
# - BQN values tuple (list), number, generator (function)
# - Classes symbols, types, registers, constants, functions, blocks
_and_ â† { ğ”½â—¶âŸ¨0,ğ”¾âŸ© }
IsNum â† 1=â€¢Type
IsInt â† IsNum _and_ (âŒŠâŠ¸=)
IsNat â† IsInt _and_ (0âŠ¸â‰¤)
IsTup â† 0=â€¢Type
FmtNum â† 'Â¯'(âŠ¢+=Ã—'-'-âŠ£)â€¢Repr

_tsel â† {â€¢Typeâˆ˜âŠ£â—¶(Â¯1((â†“Â»(6â¥ŠâŸ¨!âˆ˜"Unhandled kind"âŸ©)Ë™)âˆ¾â†‘)ğ•—)}
Kind  â† âŸ¨"tuple","number",@,"generator",{ğ•©.kind}âŸ©_tsel
Show  â† {âŸ¨"tup{"âˆ¾"}"âˆ¾Ëœ1â†“Â·âˆ¾(","âˆ¾ğ•Š)Â¨, FmtNum, !, {(ğ•Ëœ@).name}, {ğ•©.Shows@}âŸ©_tsel ğ•©}
Match â† {ğ•¨ âŸ¨â‰¡â—‹â‰¢â—¶âŸ¨0,âˆ§Â´ğ•ŠÂ¨âŸ©, numbers.Match,â‰¡,â‰¡, {ğ•¨ğ•¨.Matchesğ•©}âŸ©_tsel ğ•©}
IsTypedâ†âˆŠâŸœ"register"â€¿"constant"â€¿"function"âŒ¾< Kind
TypeOfâ† {âŸ¨types.Tup ğ•ŠÂ¨, {ğ•©.Type@}âŸ©_tsel ğ•©}

types â† {knameâ‡"type"
  New â† {kğ•Šd:
    kindâ‡kname
    typeKindâ€¿datâ‡ğ•¨â€¿ğ•©
    Tâ†"("âˆ¾")"âˆ¾Ëœ1â†“Â·âˆ¾(","âˆ¾Show)Â¨  # Display type tuple
    Showsâ‡typeKindâ—¶âŸ¨
      "void"               # Void:                     void
      âˆ¾âŸœâ€¢ReprÂ´             # Primitive:   qualâ€¿len     u8
      {âˆ¾"["â€¿ğ•¨â€¿"]"â€¿ğ•©}â—‹ShowÂ´ # Vector:      countâ€¿t      [4]â€¦
      "*"âˆ¾Show             # Pointer:     t            *â€¦
      TâŠ¸{âˆ¾ğ•¨â€¿"->"â€¿ğ•©}âŸœShowÂ´  # Function:    âŸ¨qâ€¿râ€¿s, tâŸ©   (â€¦,â€¦,â€¦) -> â€¦
      T                    # Tuple:       qâ€¿râ€¿s        (â€¦,â€¦,â€¦)
    âŸ©âˆ˜dat
    Matchesâ‡{ğ•¨Isâˆ˜âŠ¢â—¶0â€¿Equivğ•©}
  }
  tVOIDâ€¿tPRIMâ€¿tVECâ€¿tPTRâ€¿tFUNâ€¿tTUP â† â†•6
  TypeKindâ‡{
    "typekind argument must be type"!Is ğ•©
    ğ•©.typeKindâŠ‘"void"â€¿"primitive"â€¿"vector"â€¿"pointer"â€¿"function"â€¿"tuple"
  }
  IsVoid â‡ {tVOIDâ‰¡ğ•©.typeKind}

  primTypes â‡ (tVOID New âŸ¨âŸ©) âˆ¾ tPRIM NewÂ¨ qw â† âˆ¾â‹ˆÂ¨Â¨Ëâ‰ âˆ˜â€¿2â¥ŠâŸ¨
    'u', 2â‹†0âˆ¾3+â†•4  # 1/8/16/32/64
    'i', 2â‹†  3+â†•4  #   8/16/32/64
    'f', 2â‹†  5+â†•2  #        32/64
  âŸ©
  _getPrim â† {{ğ•@} (âŸ¨!âˆ˜ğ•—âŸ©Â«primTypes) âŠ‘Ëœ qwâŠ¸âŠâŒ¾<}

  Is â‡ knameâ‰¡Kind
  Vec â† {nğ•Št: "Vector size should be a constant integer"!IsNat n â‹„ !Is t â‹„ tVEC New âŸ¨n,tâŸ©}
  Ptr â† { ğ•Št: "Pointer type wasn't type"!Is t â‹„ tPTR New t}
  Tup â‡ { ğ•Št: !IsTup t â‹„ !âˆ§Â´IsÂ¨ t â‹„ tTUP New t}
  Fun â‡ tFUN New â‹ˆ
  _getâ‡ {IsTup ğ•© ? Tup ğ•ŠÂ¨ğ•© ; !âˆ˜(ğ•—âˆ¾" type must be a type"Ë™)âŸ(Â¬Is) ğ•©}

  _cases â† {
    Kindâ†{ğ•©.typeKind} â‹„ Datâ†{ğ•©.dat}
    c â† âŒŠâ€¿2â¥Šğ•—
    k â† âŠË˜c
    d â† (1âŠË˜c) âˆ¾ ((â‰ â¥Šc)â†“ğ•—)Â»âŸ¨!âˆ˜0âŸ©
    (kâŠ¸âŠâŒ¾< âŠ¢âŠ˜(â‰ â—¶âŠ¢â€¿Â¯1)â—‹Kind)â—¶({ğ•â—‹Dat}Â¨âŒ¾((â‰ k)âŠ¸â†‘)d) âŠ£ @â—‹(!Is)
  }

  Quality â† âŸ¨tPRIM,{symbols.New â‹ˆâŠ‘ğ•©}, !âˆ˜"Non-primitive type"âŸ©_cases
  _isQual â† {âŸ¨tPRIM,ğ”½âŠ‘,0âŸ©_cases TypeOfâŸ(Â¬Is)}

  Unpack â‡ âŸ¨tTUP,{UnpackÂ¨ğ•©},âŠ¢âŸ©_cases
  Ungather â‡ âŸ¨tTUP,âŠ¢,!âˆ˜"Gathered argument must have a tuple type"âŸ©_cases
  Deref â‡ { Is ğ•© ? tPTR=ğ•©.typeKind ? ğ•©.dat ; !"Expected pointer" }

  Width â† âŸ¨
    tPRIM, 1âŠ¸âŠ‘
    tVEC,  Ã—âŸœ{Widthğ•©}Â´
    tTUP,  +Â´{Widthğ•©}Â¨
    tPTR,  ptrWidth
    {!âˆ¾âŸ¨"Can't find width of ",TypeKindğ•©," types"âŸ©}
  âŸ©_cases

  VCount â† âŸ¨ tVEC,âŠ‘, 1 âŸ© _cases
  VType â† âŸ¨ tVEC,1âŠ¸âŠ‘, tPTR,âŠ¢ âŸ© _cases

  FnCast â‡ {
    argsâ€¿ret â† âŸ¨tFUN,âŠ¢, !âˆ˜"Calling non-function"âŸ©_cases ğ•¨
    args(("Wrong number of arguments: expected "âˆ¾â€¢Reprâˆ˜âŠ£)!â‰¡)â—‹â‰ ğ•©
    âŸ¨args CastÂ¨ ğ•©, retâŸ©
  }

  _typeRel_ â† {
    ğ•¨ âŸ¨
      tVOID, 1
      tPRIM, ğ”½
      tVEC,  =â—‹âŠ‘ _and_ (ğ•Šâ—‹(Â¯1âŠ¸âŠ‘))
      tPTR,  (@â‰¢ğ•˜)âŠ‘ğ•Šâ€¿ğ•˜
      tTUP,  MTup â† =â—‹â‰  _and_ (âˆ§Â´ğ•ŠÂ¨)
      tFUN,  ğ•Šâ—‹(1âŠ¸âŠ‘) _and_ (MTupâ—‹âŠ‘)
      0
    âŸ© _cases ğ•©
  }
  _cmpPrim â† {
    Lâ†Â¯1âŠ¸âŠ‘ â‹„ â‰ â—‹âŠ‘â—¶âŸ¨ğ”½â—‹L, ('f'â‰ âŠ‘âˆ˜âŠ£)_and_(<â—‹L)âŸ©
  }
  Equiv    â† â‰¡          _typeRel_ @
  Subtype  â‡ â‰¤ _cmpPrim _typeRel_ 1
  SSubtype â‡ < _cmpPrim _typeRel_ 0

  _asCast â† {
    "Can't cast to non-type"!Isğ•¨
    Fail â† {!âˆ¾âŸ¨"Can't cast ",Kindğ•©," to ",Showğ•¨âŸ©}
    Num â† {tğ•Šn:
      âŸ¨ tPRIM,numbers.CastâŸœn, FailâŸœn âŸ© _cases t
      t constants.New n
    }
    Cast â† ğ•Š
    Tup â† {
      ptr â† 0
      c â† âŸ¨ tTUP,âŠ¢, tPTR,{ptrâ†©1â‹„ğ•©}, FailâŸœğ•© âŸ©_casesâŸ(0â‰ â€¢Type) ğ•¨
      ğ•¨ functions.ArrayâŸptr c CastÂ¨ ğ•©
    }
    Obj â† ("number"â‰¢{ğ•©.kind})â—¶âŸ¨Num,IsTypedâˆ˜âŠ¢â—¶âŸ¨FailËœ,ğ”½âŸ©âŸ©
    # _tsel selects on ğ•¨; swap to use ğ•©
    ğ•¨ âŸ¨TupËœ, NumËœ, FailËœ, FailËœ, ObjËœâŸ©_tselËœ ğ•©
  }
  _cc â† { Testâ€¿Convâ€¿Fail _ğ•£:
    (Conv âŠ£ Failâ—‹ShowâŸ(Â¬TestËœ)âŸœTypeOf)_asCast
  }
  Cast â‡ âŸ¨
    Equiv, âŠ¢
    {!âˆ¾âŸ¨"Explicit conversion required to change ",ğ•©," to ",ğ•¨âŸ©}
  âŸ©_cc
  Promote â† âŸ¨
    Subtype, {functions.EmitâŸ¨ğ•¨, symbols.New "^promote", ğ•¨, ğ•©âŸ©}
    {!âˆ¾âŸ¨"Can't promote from type ",ğ•©," to non-subset ",ğ•¨âŸ©}
  âŸ©_cc
  Reinterpret â† âŸ¨
    â‰¡â—‹Width, {functions.EmitâŸ¨ğ•¨, symbols.New "^promote", ğ•¨, ğ•©âŸ©}
    {!âˆ¾âŸ¨"Can't reinterpret type ",ğ•©," as different-width type ",ğ•¨âŸ©}
  âŸ©_cc

  IncWidth â† {
    "First parameter of promote must be a type or number"!"number"â‰¡Kindğ•¨
    nâ†numbers.From ğ•¨
    tâ†TypeOf ğ•©
    (1 + n Ã—âˆ˜- Width t)â—¶âŸ¨
      !âˆ˜"Can't decrease width in promotion"
      âŠ¢
      âŸ¨
        tPRIM, "Invalid width"_getPrim ğ•¨âŒ¾(1âŠ¸âŠ‘)
        !âˆ˜"Can't increase width of non-primitive type"
      âŸ©_casesâˆ˜tâŠ¸Promote
    âŸ© ğ•©
  }
  GetQual â† {
    e â† "Quality must be a single-letter symbol (i,u,f)"
    n â† e symbols.From ğ•© â‹„ e!1=â‰ n
    âŠ‘n
  }
  PrimType â† "Invalid primitive type specification"_getPrim âŸ¨GetQual,numbers.FromâŸ© {ğ•ğ•©}Â¨ âŠ¢

  builtins â‡ âˆ¾Ë˜â‰âˆ˜â€¿2â¥ŠâŸ¨
    âŸ¨"cast"   ,             "promote"   ,"reinterpret"âŸ©
    âŸ¨ Cast _p2,Isâˆ˜âŠ£â—¶IncWidthâ€¿Promote _p2, Reinterpret _p2âŸ©
    âŸ¨"eltype"   ,"vcount"   ,"width"   ,          "__vec"   ,"__pnt"âŸ©
    âŸ¨ VType _p1 , VCount _p1, Width _p1,numbers.FromâŠ¸Vec _p2,   Ptr _p1âŸ©
    âŸ¨"primtype"   ,"quality","isfloat","issigned","isint"âŸ©
    âŸ¨ PrimType _e2, Quality _p1âŸ©âˆ¾{ğ•©_isQual _p1}Â¨âŸ¨'f'âŠ¸â‰¡ â‹„ 'i'âŠ¸â‰¡ â‹„ âŠ‘âˆ˜âˆŠâŸœ"iu"âŸ©
  âŸ©
}

registers â† {knameâ‡"register"
  Is â† kname â‰¡ Kind
  Transient â‡ {
    ownerâ‡functions.current â‹„ labcâ‡owner.labc
    kindâ‡kname â‹„ showsâ‡"(temp)" â‹„ typeâ‡ğ•© â‹„ fmtTypeâ‡1 â‹„ Matchesâ‡â‰¡
    nameâ†âŸ¨âŸ© â‹„ AddNameâ‡{nameâˆ¾â†©<ğ•©}
    mutâ‡0 â‹„ refâ‡0 â‹„ Useâ‡{ğ•¤â‹„ref+â†©1} â‹„ SetMutâ‡!
    ShowRegâ‡{showRegâ†©âˆ¾âŸ¨ğ•@âŸ©âˆ¾"_"âŠ¸âˆ¾Â¨(ref=1)/name}
  }
  Declare â‡ { name ğ•Š typeâ€¿val:
    ownerâ‡functions.current â‹„ labcâ‡owner.labc
    kindâ‡kname â‹„ showsâ‡name â‹„ typeâ‡ â‹„ fmtTypeâ‡1 â‹„ Matchesâ‡â‰¡
    addNameâ‡@ â‹„ {ğ•©.AddName name}âŸIs val
    mutâ‡0 â‹„ refâ‡0 â‹„ Useâ‡{ğ•¤â‹„ref+â†©1}
    SetMutâ‡{ğ•¤â‹„mutâ†©1}  # Changed (for blocks, and transient elimination)
    ShowRegâ‡{showRegâ†©ğ•©}âˆ˜{
      Is val? Â¬val.mut? (Â¬mut)âˆ¨1=val.ref? labc=val.labc?
        ref+â†©val.ref-1 â‹„ val.ShowRegğ•© ;
      âˆ¾âŸ¨ğ•@,"_",nameâŸ©
    }
  }
  Mutable â‡ { Is ğ•© ? {!}â‰¢ğ•©.setMut ; 0 }
  Mutated â‡ { Is ğ•© ? ğ•©.mut ; 0 }
  MarkUse â‡ {ğ•©.Use@}âŸIs
  CheckAppend â‡ { "Register used outside its owning function"!ğ•¨â‰¡ğ•©.owner }âŸ(IsâŠ¢)
}
constants â† {knameâ‡"constant"
  New â‡ {
    kindâ‡kname â‹„ typeâ‡ğ•¨ â‹„ valueâ‡ğ•©
    showsâ‡âˆ¾"!:"âˆ¾Â¨ShowÂ¨ğ•©â€¿ğ•¨ â‹„ fmtTypeâ‡0 â‹„ Matchesâ‡â‰¡
  }
  Static â‡ {
    kindâ‡kname â‹„ typeâ€¿handleâ‡ğ•©
    showsâ‡"$c"âˆ¾(""âŠ¢"_"âˆ¾ğ•¨)âˆ¾Ëœâ€¢Repr handle â‹„ fmtTypeâ‡1 â‹„ Matchesâ‡â‰¡
  }
  Undefined â‡ {
    kindâ‡kname â‹„ showsâ‡"?:"âˆ¾Show typeâ‡ğ•© â‹„ fmtTypeâ‡0 â‹„ Matchesâ‡â‰¡
  }
  Exportable â‡ (knameâ€¿"function"âŠ¸âŠâŒ¾< Kind)â—¶{"?:"â‰¢2â†‘ğ•©.shows}â€¿1â€¿0
}

labels â† {knameâ‡"label"
  New â‡ { kindâ‡kname â‹„ showsâ‡"l"âˆ¾â€¢Reprğ•© â‹„ Matchesâ‡â‰¡ }
}
symbols â† {knameâ‡"symbol"
  Is â† kname â‰¡ Kind
  From â‡ {!âŸœ(Isğ•©Ë™)ğ•¨ â‹„ ğ•©.symstr}
  M â† Isâˆ˜âŠ¢_and_(â‰¡â—‹From)
  Enc â† "'"(âˆ¾âˆ¾âŠ£)âŠ¢+128Ã—' 'âŠ¸= # Space to non-breaking space
  New â‡ { kindâ‡kname â‹„ symstrâ‡ğ•© â‹„ Showsâ‡Encâˆ˜symstr â‹„ Matchesâ‡M }
}

functions â† {knameâ‡"function"
  currentâ‡nofnâ†{
    Appendâ‡NextLabelâ‡Returnâ‡SetArchâ‡!âˆ˜"No function active"
    arch â‡ architecture.init
  }
  New â† {ğ•¤
    kindâ‡kname â‹„ showsâ‡"$f"âˆ¾(â€¢Repr idâ‡ğ•©)âˆ¾"_"âŠ¸âˆ¾âŸ(0<â‰ )ğ•¨ â‹„ Matchesâ‡â‰¡ â‹„ typeâ‡@
    archâ‡architecture.NewFunction@ â‹„ SetArchâ‡{archâ†©ğ•©}
    labelâ†Â¯1 â‹„ slabelâ†âŸ¨âŸ© â‹„ argsâ†atypesâ†ctypesâ†âŸ¨âŸ© â‹„ rTypeâ‡@
    labcâ‡0 â‹„ IncLabâ‡{ğ•Š:labc+â†©1}  # Labels set: don't alias through label
    NextLabelâ‡{ğ•¤â‹„ labels.New label+â†©1 }
    UseSymLabelâ‡{
      âˆŠâŸœslabelâŒ¾<ğ•© ? !âˆ¾"Label "â€¿ğ•©â€¿" used in this function already" ;
      slabelâˆ¾â†©<ğ•© â‹„ ğ•©
    }
    NextArgâ‡{ nameâ€¿gather ğ•Š type:
      a â† (name registers.Declare â‹ˆâŸœ@)âš‡0 types.Unpack type
      atypesâˆ¾â†©<type â‹„ ctypesâˆ¾â†©gatherâ—¶<â€¿types.Ungather type â‹„ argsâˆ¾â†©<a
      a
    }
    âŸ¨Push,ArrâŸ©â†MakeStack@
    Instrsâ‡Arr
    Appendâ‡{ current registers.CheckAppendÂ¨ 1â†“ğ•© â‹„ Pushğ•© â‹„ @ }
    SetRTypeâ‡{
      SetRTypeâ†©!âˆ˜0 â‹„ !types.Is rTypeâ†©ğ•©
      type â†© ctypes types.Fun rType
    }
    _ret_â†{
      Void â† types.IsVoid
      r â† rType â‰¢âŸœ@â—¶âŸ¨ğ”½âˆ˜âŠ¢, Voidâˆ˜âŠ£â—¶âŸ¨types.Cast,âŠ‘types.primTypesË™âŸ©âŸ© ğ•©
      ğ•˜â—¶âŸ¨Â¬Void,1âŸ© rType ? Append âŸ¨"ret", râŸ© ; @
    }
    Returnâ‡{
      A â† !âˆ˜"Early return from function with no explicit result type"
      A _ret_ 1 @âŠ£Â´ğ•©
      {Showsâ‡!âˆ˜"Can't use return result as value"â‹„kindâ‡"error"}
    }
    Finishâ‡{"Explicit result type needed"!IsTyped ğ•©â‹„SetRtype TypeOf ğ•©â‹„ğ•©} _ret_ 0
    Protâ‡{ğ•Š showReg:
      ext â† (0<â‰ )â—¶âŸ¨âŸ©â€¿(â‹ˆÂ·'+'âŒ¾âŠ‘Â·âˆ¾','âŠ¸âˆ¾Â¨) architecture.ListExt arch
      at â† âˆ¾ args {IsTupğ•¨ ? âˆ¾ğ•¨ğ•ŠÂ¨ğ•© ; â‰âŸ¨ShowRegğ•¨,Showğ•©âŸ©}âŸœtypes.UnpackÂ¨ atypes
      1â†“âˆ¾" "âŠ¸âˆ¾Â¨âŸ¨1â†“shows,Show rTypeâŸ©âˆ¾((<âˆ˜â€¢Reprâˆ˜â‰ âˆ¾â¥Š)at)âˆ¾ext
    }
  }
  _with_ â‡ {
    uâ€¿name â† ğ•¨  # Passed in by nodes.Define, pretty hacky
    fsâ†current
    fâ†currentâ†©name program.AddFunction new
    u.Set f
    f (f.Finish ğ”½)program._trace_ ğ•˜ ğ•©
    currentâ†©fs
    f
  }
  NextArg â‡ { ğ•¨ current.NextArg ğ•© }
  Label â‡ { current.NextLabel ğ•© }
  UseSymLabel â‡ { current.UseSymLabel ğ•© }
  Append â† { current.Append ğ•© }
  _appendReg â† { (1âŠ¸âŠ‘âŠ£Append) âŸ¨"new",ğ”½ğ•¨âŸ©âˆ¾{kindâ‡@â‹„showsâ‡ğ•©}âŒ¾âŠ‘ğ•© }
  AppendNew â† registers.Transient _appendReg
  Return â‡ { current.Return ğ•© }
  GetArch â† {ğ•Š: current.arch }
  SetArch â† { current.SetArch ğ•© }
  Emit â‡ { (âŠ‘ğ•©) AppendNew "emit" <âŠ¸âˆ¾ ğ•© }
  Array â‡ {
    Â¬âˆ¨Â´("register"â‰¡Kind)Â¨ğ•© ? ğ•¨ constants.New ğ•© ;
    ğ•¨ AppendNew "array"â€¿ğ•¨ âˆ¾ ğ•©
  }
  Declare â‡ {
    currentâ‰¡nofn ? ğ•¨ program.AddConstant ğ•© ;
    tâ†TypeOfğ•© â‹„ ğ•¨ registers.DeclareâŸœtâ€¿ğ•© _appendReg "val"â€¿tâ€¿ğ•©
  }
  _destructure â† {
    0â‰ â€¢Typeğ•© ? ğ•¨ğ”½âš‡0ğ•©;
    "Single assignment target but multiple values" ! 0=â€¢Typeğ•¨
    "Assignment tuple length mismatch" ! ğ•¨ â‰¡â—‹â‰¢ ğ•©
    ğ•¨ğ•ŠÂ¨ğ•©
  }
  Mut  â‡ {
    "Can't assign to non-register" ! registers.Mutable ğ•¨
    Append "mut"â€¿ğ•¨â€¿(ğ•¨.type types.Cast ğ•©)
    ğ•¨.SetMut@
    ğ•¨
  }_destructure
  Call â‡ {
    f â† âŠ‘ğ•©
    "Calling non-function" ! IsTyped f
    aâ€¿t â† (TypeOf f) types.FnCast 1â†“ğ•©
    t AppendNew âŸ¨"call",t,fâŸ© âˆ¾ â‰ âŠ¸âˆ¾ {IsTupğ•© ? âˆ¾ğ•ŠÂ¨ğ•© ; âŸ¨ğ•©âŸ©} a
  }
  _instr â† { Append (ğ•¨ğ”½ğ•©)<âŠ¸âˆ¾ğ•¨â‹ˆğ•© â‹„ ğ•© }
  SetLabel â‡ "lbl"_instr âŠ£ { current.IncLab ğ•© }
  Goto     â‡ "goto"âŠ˜"gotoT"_instr
  GotoF    â‡ "gotoF"_instr
  ReadLabel â† {
    l â† "Label or symbol expected" symbols.From ğ•©
    symbols.New "l_" âˆ¾ UseSymLabelâŸğ•¨ l
  }âŸ("label"â‰¢Kindâˆ˜âŠ¢)
  builtins â‡ â‰> âŸ¨
    âŸ¨"call",Call _v1âŸ©, âŸ¨"emit",Emit _v1âŸ©, âŸ¨"return",ReturnâŸ©
    âŸ¨"makelabel",LabelâŸ©, âŸ¨"goto",(Goto 0âŠ¸ReadLabel) _p1âŸ©
    âŸ¨"setlabel",(SetLabel 1âŠ¸ReadLabel) _p1 â‹ˆâˆ˜LabelâŸ(0=â‰ )âŸ©
  âŸ© âˆ¾ { Newâ€¿Unionâ€¿Hasâ€¿List â† architecture â‹„ Sâ†SetArch â‹„ Gâ†GetArch â‹„ âŸ¨
    âŸ¨"setarch",S NewâŸ©
    âŸ¨"addarch",S G Union NewâŸ©
    âŸ¨"hasarch",GâŠ¸HasâŸ©
    âŸ¨"listarch",symbols.NewÂ¨Listâˆ˜GâŸ©
  âŸ©}
}

blocks â† {knameâ‡"block"
  New â‡ {ğ•Š indâ€¿ptrsâ€¿bodyâ€¿lsâ€¿e:
    kindâ‡kname
    showsâ‡"{block}" â‹„ Matchesâ‡â‰¡
    Execâ‡{
      "Wrong number of pointer arguments in block exec" ! ptrsâ‰¡â—‹â‰ 1âŠ‘ğ•©
      r â† body.Eval be â† âŸ¨â‰ ind,ls,ğ•©,ptrsâŸ© env.Block e
      be.Stores @
      r
    }
  }
  Exec â‡ {ğ•Š indâ€¿varsâ€¿block:
    "Executing non-block" ! "block"â‰¡Kind block
    block.Exec indâ€¿vars
  }
}
AccessPtr â† { (âŠ¢âŠ£ "Can't access void pointer" ! Â·Â¬types.IsVoid) types.Deref TypeOf ğ•© }
Load â† {  ğ•Š ptrâ€¿i: functions.Emit âŸ¨AccessPtr ptr, symbols.New "^load", ptr, iâŸ© }
Storeâ† {v ğ•Š ptrâ€¿i: functions.Emit âŸ¨AccessPtr ptr, symbols.New "^store", ptr, i, vâŸ© }


builtins â† {
  Kinds â† {
    E â† "Unhandled type" ! 0Ë™
    (e{kâ€¿oâ†ğ•¨â‹„âˆ§â—‹(kâ‰¡âŠ¢)â—¶âŸ¨ğ•,OË™âŸ©}Â´ğ•©){oâ†ğ•¨ğ”½â—‹Kindğ•©â‹„ğ•¨Oğ•©}
  }
  Ty2 â† {ğ•âš‡0 _p2}âˆ˜Kinds âŠ£âˆ¾âŸœ(<Â·"symbol"âŒ¾âŠ‘âŠ¢Â´)âˆ˜âŠ¢âŸ(âŠ‘âˆŠâŸœ=â€¿â‰ )"number"â€¿"type"â‹ˆÂ¨{ğ•numbers._cmp}âŠ¸â‹ˆ
  TypeSuff â† IsTypedâ—¶0â€¿{ğ•©.fmtType}â—¶""â€¿{":"âˆ¾Fmt TypeOfğ•©}
  UnEsc â† âŠ¢-128Ã—(' '+128)âŠ¸= # Non-breaking space to space
  Fmt â† 2â†“Â·âˆ¾Â·", "âŠ¸âˆ¾Â¨(UnEscâˆ˜Showâˆ¾TypeSuff)âŠ("("âˆ¾")"âˆ¾ËœKindâŠ"unknown")Â¨
  Merge â† {
    0<âŒˆÂ´=Â¨ğ•© ? âˆ¾ğ•© ;
    mâ†"merge: parameters must include at least one tuple or all be symbols"
    symbols.New âˆ¾ mâŠ¸symbols.FromÂ¨ğ•©
  }
  Slice â† {
    "slice: one or two slicing values expected"!(2âŠ¸â‰¤âˆ§â‰¤âŸœ3)â‰ ğ•©
    sâ†Â¬=lâ†âŠ‘ğ•©
    l "slice: first parameter must be a tuple or symbol"âŠ¸symbols.FromâŸsâ†©
    iâ†lâ‰ âŠ¸(0âŒˆâŠ£âŒŠ+âŸ(0âŠ¸>)Â¨)numbers.FromÂ¨1â†“ğ•© â‹„ symbols.NewâŸs (âŠ‘i)â†“(1â†“i)â†‘Â´Ëœl
  }
  namesâ€¿values â‡ <Ë˜âˆ¾â‰âŸ¨
    ShowÂ¨âŠ¸â‰ types.primTypes
    â‰> âŸ¨
      âŸ¨"__set",functions.Mut _p2âŸ©
      âŸ¨"show",(1â‰ â‰ )â—¶âŠ‘â€¿{Showsâ‡!âˆ˜"Multiple show used improperly"}âŠ£â€¢Outâˆ˜FmtâŸ©
      âŸ¨"exec",blocks.Exec _e3âŸ©
      âŸ¨"match",Match _p2âŸ©
      âŸ¨"undefined",(constants.UndefinedâŠ£"undefined: expected type"!"type"â‰¡Kind)_p1âŸ©
      âŸ¨"hastype",IsTypedâˆ˜âŠ‘ _and_ ({ğ•©.type}âŠ¸MatchÂ´)_e2âŸ©
      âŸ¨"type",TypeOf _p1âŸ©, âŸ¨"kind",symbols.New Kind _p1âŸ©
      âŸ¨"typekind",symbols.New types.TypeKind _p1âŸ©
      âŸ¨"load",Load _e2âŸ©, âŸ¨"store",Â¯1âŠ¸(âŠ‘Storeâ†“)_e3âŸ©
      âŸ¨"tup",âŠ¢âŸ©, âŸ¨"tupsel",numbers.FromâŠ¸âŠ‘âš‡0â€¿âˆ _p2âŸ©, âŸ¨"tuplen",â‰ _p1âŸ©
      âŸ¨"merge",MergeâŸ©, âŸ¨"slice",SliceâŸ©
      âŸ¨"symchars",(symbols.Newâˆ˜â‹ˆÂ¨"symchars: expected symbol"âŠ¸symbols.From)_p1âŸ©
      âŸ¨"bind",âŠ‘{ğ•ğ•©âŠ¸âˆ¾}1âŠ¸â†“_v1âŸ©, âŸ¨"each",âŠ‘{ğ•Â¨<Ë˜â‰>ğ•©}1âŠ¸â†“_v1âŸ©
      âŸ¨"apply",{"apply: second parameter must be a tuple"!1==ğ•©â‹„ğ•ğ•©}_p2âŸ©
      âŸ¨"export",{ğ•¨ symbols.FromâŠ¸program.Exportâš‡0 ğ•©}_p2âŸ©
      âŸ¨"require",{program.Requireâˆ˜symbols.Fromâš‡0 ğ•©}âŸ©
      âŸ¨"witharch",architecture.WithâŸ©
    âŸ©
    functions.builtins
    numbers.builtins
    types.builtins
    >âŸ¨
      "__eq"â€¿"__ne"â€¿"__lt"â€¿"__gt"â€¿"__le"â€¿"__ge"
      =â€¿â‰ â€¿<â€¿>â€¿â‰¤â€¿â‰¥ Ty2Â¨ âŸ¨Match,Â¬MatchâŸ© âˆ¾ Â·â¥Šâ‰Ë˜âŸœ({ğ•Ëœ}Â¨) âŸ¨types.SSubtype,types.SubtypeâŸ©
    âŸ©
  âŸ©
  values {nameâ‡ğ•©}âŠ¸{ğ•âŠ˜ğ•¨}âŸ(3=â€¢Typeâˆ˜âŠ¢)Â¨Ëœâ†© names
}

var â† {
  Getâ‡{ğ•©.Get ğ•¨}
  Fixedâ‡{ kindâ‡"var" â‹„ Getâ‡ğ•©Ë™ }
  Newâ‡{ğ•Š: NGâ†"generator"â‰¢Kind â‹„ kindâ‡"var"
    Getâ‡{! program._trace_ ğ•© "Variable definition not yet reached"}
    Setâ‡{
      {ğ•Š:Setâ†©!âˆ˜"Can't extend a non-generator"}âŸNG ğ•©
      Get â†© ğ•©Ë™
      ğ•©
    }
  }
}
scopes â† {
  noLambda â† var.Fixed {!âˆ˜"Unhandled case"}
  nullâ†{Getâ‡{ErrâŸ¨"Undefined name: "âˆ¾ğ•©,ğ•¨âŸ©} â‹„ GetLamâ‡noLambdaË™}
  Newâ‡{
    pâ†@Â¨nâ†ğ•¨âŠ£âŸ¨âŸ© â‹„ Namesâ‡{ğ•¤â‹„n}
    parent â‡ ğ•©  # For nonlocal
    Sel â†{ğ•©âŠ‘env.Vars}
    Makeâ†{câ†â‰ nâ‹„pâ€¿nâˆ¾âŸœ<Â¨â†©ğ•©â‹„c}
    Dup â†{ErrâŸ¨"Duplicate definition:",âŠ‘ğ•©,"Previously defined here:",ğ•¨âŠ‘pâŸ©}
    Par â†{ğ•âˆ˜env.Parent}
    _find â† { (nâŠ¸âŠâŒ¾<ğ•©) =âŸœ(â‰ n)â—¶ğ•— ğ•¨â€¿ğ•© }
    Get â‡ âŸ¨SelâŠ£, Par ğ•©.GetÂ´âˆ˜âŠ¢âŸ© _find
    Add â‡ Sel Dupâ€¿Make _find
    Lam â† ParâŸ(noLambdaâŠ¸â‰¢) ğ•©.GetLamÂ´âˆ˜âŠ¢
    AddLam â‡ âŸ¨â‹ˆËœSelâˆ˜âŠ£, Lamâ‹ˆSelâˆ˜MakeâŸ© _find
    GetLam â‡ âŸ¨SelâŠ£, LamâŸ© _find
  }
  Initâ‡New nullË™

  queue â† âŸ¨âŸ©
  _defer â‡ { queueâˆ¾â†©<ğ”½â€¿ğ•© }
  _run â‡ {
    ğ”½ _defer ğ•©
    _while_ â† {ğ”½âŸğ”¾âˆ˜ğ”½_ğ•£_ğ”¾âˆ˜ğ”½âŸğ”¾ğ•©}
    {ğ•Š:dâ†âŠ‘queueâ‹„queueâ†“Ëœâ†©1â‹„{ğ•ğ•©}Â´d}_while_{ğ•Š:0<â‰ queue} @
  }
}
env â† {
  Vars  â‡{ğ•©.vars}
  Parentâ‡{ğ•©.parent}
  Make â†{ varsâ‡ğ•¨ â‹„ parentâ‡ğ•© }
  Aliasâ‡Make
  New  â‡{ (var.NewÂ¨   ğ•¨) Make ğ•© }
  Fixedâ‡{ (var.FixedÂ¨ ğ•¨) Make ğ•© }
  Blockâ‡{âŸ¨ni,Loadâ€¿Store,indâ€¿ptrs,namesâŸ© ğ•Š par:
    Reg â† "register"â‰¡Kind
    pv â† names functions.DeclareâŸ(RegâŠ¢)âš‡âˆâ€¿0âŸœ(Loadâˆ˜â‹ˆâŸœind)Â¨ ptrs
    varsâ€¿parent â‡ (var.FixedÂ¨(niâ¥Š<ind)âˆ¾pv) Make par
    Stores â‡ {ğ•¤
      ptrs {registers.Mutated ğ•© ? Store ğ•¨â€¿indâ€¿ğ•© ;@}âš‡0 pv
    }
  }
}

program â† {
  AddFunctionâ‡AddConstantâ‡Exportâ‡Requireâ‡!âˆ˜0 â‹„ traceâ‡@
  _with â‡ {
    fnsâ†âŸ¨âŸ© â‹„ AddFunction â†© { f â† ğ•¨ ğ• â‰ fns â‹„ fnsâˆ¾âŸœ<â†©f â‹„ f }
    cnsâ†âŸ¨âŸ© â‹„ AddConstant â†© { c â† ğ•¨ constants.Static âŸ¨tâ†TypeOfğ•©, â‰ cnsâŸ© â‹„ cnsâˆ¾âŸœ<â†©âŸ¨Show c,t,ğ•©âŸ© â‹„ c }
    expâ†âŸ¨âŸ© â‹„ Export â†© { CheckExport ğ•© â‹„ exp âˆ¾âŸœ<â†© ğ•¨â€¿ğ•© }
    reqâ†âŸ¨âŸ© â‹„ Require â†© { req âˆ¾âŸœ<â†© ğ•© }
    âŸ¨_trace_âŸ©â†©sâ†Stack@
    ğ•¨ ğ”½âŠs.Report ğ•©
    AddFunctionâ†©AddConstantâ†©Exportâ†©!âˆ˜0
    âˆ¾ âŸ¨DispHeaderÂ¨req, DispConstants cns, âˆ¾DispFunctionÂ¨fns, DispExportÂ¨expâŸ©
  }
  CheckExport â† {
    "Exports must be typed" ! IsTyped ğ•©
    "Exports must be global fixed values" ! constants.Exportable ğ•©
  }
  Stack â† {ğ•¤
    âŸ¨_trace_â‡_while_âŸ© â‡ âŸ¨Dumpâ‡ArrâŸ© â† MakeStack@
    Report â‡ {ğ•¤
      â€¢Out (âˆ§`lfâŠ¸â‰ )âŠ¸/âŠâ€¢Repr â€¢CurrentError@
      â€¢Out ""
      # DispSourceÂ¨ âŒ½ Dump@
      # ^ would be the easy way, but we want to compress repeats
      l â† â‰ s â† Dump@
      n â† (â†•l)-Ëœ lâŠ¸=âŠ¸+ â·âŠ¸(âŠ£â‰ âŠ¸â†“âŠ¢âŠ’âˆ¾)âŠs  # Distance to next repetition
      n âŠËœâ†© i â† /Â»âŠ¸â‰ n                 # Split into blocks of equal distance
      e â† n+lÂ«i                       # Last possible endpoint
      Sc â† {ğ•¨ğ•Šnâ€¿iâ€¿e:e-n|âŸ(+ËœâŠ¸â‰¤)e-ğ•¨âŒˆi} # Full reps (if â‰¥2) not overlapping previous
      i âŒˆâ†©Â» e â†© 0 Sc` <Ë˜â‰>âŸ¨n,i,eâŸ©     # Adjust start and end
      iâ€¿nâ€¿e (i<e)âŠ¸/Â¨â†©                 # Filter out empties
      f â† i+n                         # End of displayed reps
      df â† {DispSource ğ•©Ë™}Â¨ s
      rt â† (1<n) ("Repeated "âˆ¾â€¢Reprâˆ˜âŠ¢âˆ¾" times:"âˆ¾/âŸœ" {{{")Â¨ (e-i)Ã·n
      df rtâŠ¸({ğ•âŠ£Â·â€¢Outğ•¨Ë™}Â¨)âŒ¾((f-1)âŠ¸âŠ)â†©
      df {â€¢Outâˆ˜("}}}"âˆ¾@+10)âŠ¢ğ•}Â¨âŒ¾((i/Ëœ1<n)âŠ¸âŠ)â†©
      {ğ•@}Â¨ âŒ½ df /Ëœ 1â‰ `eâ‰ â—‹(lâ†‘/â¼)f     # Remove extra iterations
      â€¢Exit 1
    }
  }
  J â† 1â†“Â·âˆ¾" "âŠ¸âˆ¾Â¨
  DispHeaderâ†{ "require " âˆ¾ "'"(âˆ¾âˆ¾âŠ£)ğ•© }
  DispConstantsâ†{ âˆ¾âŸœ(<âŸ¨âŸ©)âŸ(0<â‰ ) (J"constant"<âŠ¸âˆ¾ShowÂ¨âŒ¾(1âŠ¸â†“))Â¨ ğ•© }
  DispFunctionâ†{
    ShowReg â† {hâ†Â¯1â‹„{ğ•Š:"v"âˆ¾â€¢Repr h+â†©1}}{ğ•©.ShowRegğ•—}
    ProcInstrs â† {
      # Mark each register with the number of times it's used after definition
      (registers.MarkUseÂ¨(1+âŠâˆŠ"new"â€¿"mut"Ë™)â†“âŠ¢)Â¨ ğ•©
      # Combine new into next mut call if that's the only use
      nm â† / âˆ§âŸœÂ«Ë "new"â€¿"mut" â‰¡âŒœ âŠ‘Â¨ğ•©
      nm (â‰¡â—¶0â€¿{1=ğ•©.ref}Â¨Ë1â€¿2âŠ‘Â¨ğ•©âŠËœ0â€¿1+âŒœâŠ¢)âŠ¸/â†©
      ğ•© â†© (Â¬(â‰ ğ•©)â†‘/â¼1+nm) / (1âŒ½ğ•©) (âŠ£âŒ¾(2âŠ¸â†‘)Â¨âŒ¾(nmâŠ¸âŠ)) ğ•©
      # Convert to names, performing register numbering
      ğ•© ("register"â‰¡Kind)â—¶Showâ€¿ShowRegÂ¨âŒ¾(1âŠ¸â†“)Â¨â†©
      # Registers are aliased when possible, leading to no-op new
      # instructions removed here
      {"new"â‰¡âŠ‘ğ•© ? "val"â‰¡2âŠ‘ğ•© ? â‰¡Â´1â€¿4âŠğ•© ? 0 ; 1}Â¨âŠ¸/ ğ•©
    }
    âˆ¾âŸ¨
      âŸ¨"beginFn "âˆ¾ğ•©.Prot showRegâŸ©
      JÂ¨ ProcInstrs ğ•©.Instrs@
      âŸ¨"endFn",""âŸ©
    âŸ©
  }
  DispExportâ†{ "export " âˆ¾ J (<"'"âŠ¸(âˆ¾âˆ¾âŠ£))âŠ¸âˆ¾âŸœ(TypeOfâ‹ˆâ—‹ShowâŠ¢)Â´ ğ•© }
}

nodes â† {
  # Node operations
  o â† {
    Verify â‡ {ğ•©.node}
    Dump â‡ {ğ•©.Dump@}
    Disp â‡ {ğ•©.Disp@}
    Oper â‡ {ğ•Šop :{ğ•©.Oper  op }}
    Scopeâ‡ {ğ•Šsc :{ğ•©.Scope sc }}
    Eval â‡ {ğ•Šenv:{ğ•©.Eval  env}}
  }
  Defaults â† {
    nodeâ€¿visit â‡ ğ•©
    Visit o.verify
    Dump â‡ {ğ•¤â‹„âŸ¨node,Visit o.dumpâŸ©}
    Disp â‡ {ğ•¤â‹„node <âŠ¸âˆ¾ "  "âŠ¸âˆ¾Â¨ âˆ¾âˆ¾ @ â¥Šâˆ˜<âˆ˜âŠ¢âŸ((2Ã—â‰¡)+â‰¡âŸœ@)Â¨â—‹Visit o.disp}
    Oper â‡ {Visit o.Oper  ğ•© â‹„ operator.nil}
    Scopeâ‡ {Visit o.Scope ğ•©â‹„@}
    Eval â‡ {Visit o.Eval  ğ•©}
    NonLocal â‡ âŠ¢
  }

  # Node types
  Word â‡ {
    nameâ‡ğ•© â‹„ posâ‡ğ•¨âŠ£@
    âŸ¨node,Dump,NonLocalâŸ©â‡dâ†Defaults "word"â€¿âŸ¨âŸ©
    Dispâ‡{ğ•¤â‹„âŸ¨nameâŸ©}
    Operâ‡{ğ•©.Lookup name}
    Evalâ‡!âˆ˜0 â‹„ Scopeâ‡{Evalâ†©pos var.Get (pos ğ•©.Get name){ğ”½}}
    # Modify so it defines the variable instead of getting the value
    v0â†@â‹„Vâ†!âˆ˜0 â‹„ IsDefâ‡{ğ•Š:
      âŸ¨OperâŸ©â†©d
      Scopeâ†©{
        1ğ•Šğ•©: v0â€¿v â†© pos ğ•©.AddLam name ;
        v â†© pos ğ•©.Add name
      }
      Evalâ†©{valâ€¿decl ğ•Š ğ•©: uâ†Vğ•© â‹„ u.Set nameâŠ¸functions.Declareâš‡0âŸdecl val}
    }
    # If fâ‰¡1, set value in Eval for function recursion
    DefEval â‡ { fâ€¿ValEval ğ•Š e:
      uâ†V e â‹„ u.Set program._trace_ posâŸ(Â¬f) ValEval âŸ¨fâ—¶âŸ¨V0,uË™âŸ© e, nameâŸ©
    }
  }
  NewId â‡ {ğ•©.IsDef@â‹„ğ•©}âˆ˜Word
  _value â† {
    nameâ†ğ•© â‹„ posâ‡ğ•¨âŠ£@
    Evalâ‡(ğ•¨ğ”½ğ•©)Ë™
    âŸ¨node,Dump,NonLocal,Oper,ScopeâŸ©â‡Defaults "value"â€¿âŸ¨âŸ©
    Dispâ‡{ğ•¤â‹„âŸ¨nameâŸ©}
  }
  Number â‡ numbers.Read _value
  Symbol â‡ (symbols.New 1â†“Â¯1â†“âŠ¢)_value
  Token â‡ ('''â‰ âŠ‘âˆ˜âŠ¢)â—¶âŸ¨Symbol,(âŠ‘âŠâˆ˜âŠ¢âˆŠdigË™)â—¶Wordâ€¿NumberâŸ©
  Run â‡ {
    ğ•¨ğ•ŠâŸ¨âŸ¨infixâŸ©,paramsâŸ©: CondNodeÂ´ ğ•©;
    âŸ¨caller,paramsâŸ©â†ğ•© â‹„ posâ‡ğ•¨
    spread â† 0=â€¢TypeÂ¨params â‹„ params âŠ‘Â¨â†©
    deSpread â† (âˆ¨Â´spread)âŠ‘âŠ¢â€¿{
      âˆ¾ spread âŠ£â—¶âŸ¨â‹ˆâŠ¢,("Spread input must be tuple"!IsTup)âŠ¸âŠ¢âŠ¢âŸ©Â¨ğ•©
    }
    Visitâ†{âŸ¨ğ•caller,ğ•Â¨paramsâŸ©}
    âŸ¨node,Dump,Disp,NonLocal,ScopeâŸ©â‡dâ†Defaults "run"â€¿visit
    Oper â‡ {ğ•¤â‹„ pos operator.Run âŸ¨âŠ‘Visit o.Oper ğ•©, paramsâŸ©}
    Eval â‡ {
      (3=â€¢Typeğ•¨)â—¶âŸ¨!âˆ˜"Running non-generator", ğ•âˆ˜DeSpreadâŸ© program._trace_ pos ğ•©
    }Â´ d.Eval
  }
  Call â‡ { ğ•¨ Run âŸ¨Word"call" , <âŠ¸âˆ¾Â´ğ•©âŸ© }
  Phrase â‡ {
    thingsâ†ğ•© â‹„ posâ‡ğ•¨
    ToWordâ‡{ğ•¤â‹„ (1=â‰ )â—¶âŸ¨@,@âŸ("word"â‰¢{ğ•©.node})âŠ‘âŸ© things }
    Visitâ†{âŸ¨ğ•Â¨thingsâŸ©}
    âŸ¨node,Dump,Disp,NonLocal,Scope,EvalâŸ©â‡Defaults "phrase"â€¿visit
    Operâ‡{
      âŸ¨nodeâŸ©â†©n â† (o.Oper ğ•©)Â¨âŠ¸operator.Parse things
      Scopeâ†©{ğ•¨n.Scopeğ•©} â‹„ Evalâ†©{ğ•¨(Evalâ†©n.Eval)ğ•©} â‹„ Dispâ†©{ğ•¨n.Dispğ•©} # fields of n can change
      operator.nil
    }
  }
  PhraseTryWord â‡ {"phrase"â‰¡ğ•©.node}â—¶@â€¿{ğ•©.ToWord@}
  PhraseTryName â‡ {ğ•©.name}âŸ(@âŠ¸â‰¢)PhraseTryWord
  notTypeVar â† types.primTypesâ‰ âŠ¸â†‘builtins.names
  Params â‡ {
    âŸ¨paramsPlus,condsâŸ© â† ğ•© â‹„ posâ†ğ•¨
    pgatherâ€¿paramsâ€¿pmatchâ€¿ptype â† <Ë˜â‰>paramsPlus
    tname â† (Â¬âˆ˜âˆŠâŸœ(âŸ¨@âŸ©âˆ¾notTypeVar)âŠ¸/ PhraseTryNameÂ¨)Â¨ ptype
    uTypâ€¿iTypâ†(â·âˆ˜âˆ¾ â‹ˆ âŠâˆ˜âˆ¾âŠ”Â·/â‰ Â¨)tname
    _pc â† {nâ†ğ•¨â‹„fâ†ğ•— â‹„ {pos Run âŸ¨Word f,âŸ¨Word n,ğ•©âŸ©âŸ©}Â¨ğ•©}
    condsâˆ¾Ëœâ†©âˆ¾(params "hastype"_pcÂ¨ tnameâ‰ âŠ¸â†“Â¨ptype)âˆ¾(params "match"_pcÂ¨ pmatch)
    uParâ€¿iParâ†(â·â‹ˆâŠ)params
    ns â† posâŠ¸NewIdÂ¨ uParâˆ¾uTyp
    Visitâ†{âŸ¨ğ•Â¨ns,ğ•Â¨condsâŸ©}
    âŸ¨node,Dump,Disp,NonLocal,Oper,ScopeâŸ©â‡Defaults "params"â€¿visit
    VisitLambda â‡ {âŸ¨(iParâŠuPar)âˆ¾âŸœ(âˆ¾""<âŠ¸âˆ¾":"âŠ¸âˆ¾Â¨)Â¨tname,ğ•Â¨condsâŸ©}
    ScopeLambda â‡ {(uParâˆ¾uTyp) scopes.New ğ•©}
    AllEq â† âˆ§Â´âŠMatchÂ¨1âŠ¸â†“
    proc â† {âŠ¢} {eâ€¿Fâ€¿Nğ•Šğ•©:eâ€¿Fğ•ŠâŠ‘âŸ¨ğ•NâŸ©; eâ€¿1ğ•Šğ•©:ğ•; eâ€¿Fğ•Šğ•©:fâ—¶âŸ¨<e,ğ•âŸ©}Â´ âŸ¨
      âŸ¨"lengths don't match"âŸ©âˆ¾(+Â´Â¬)âŠ¸{
        Â¬âˆ¨Â´ğ•© ? âŸ¨ğ•¨=â‰ âŸ© ;
        âŸ¨ğ•¨â‰¤â‰ , (0â€¿ğ•¨-Ëœâ‹ˆâ¼/ğ•©)âŠ¸(âˆ¾0â€¿2â€¿1âŠâ†‘Â¨âŸœ<âˆ¾âŸœ<Â·<â†“Â´Ëœ)âŸ©
      } pgather
      âŸ¨"values given the same name don't match",
       {âˆ§Â´âˆŠğ•©?1 ; {ğ•âˆ§ğ•}Â´{AllEqğ•©âŠ¸âŠ}Â¨(1<â‰ Â¨)âŠ¸/âŠ”ğ•©}iParâŸ©
      âŸ¨"specified types don't match",
       {0=â‰ ğ•©?1 ; {ğ•âˆ§ğ•}Â´{1=â‰ ğ•© ? IsTyped(âŠ‘ğ•©)âŠ¸âŠ‘
                       ;(âˆ§Â´IsTypedÂ¨)_and_(AllEq{ğ•©.type}Â¨)ğ•©âŠ¸âŠ}Â¨ğ•©}iTypâŸ©
    âŸ©
    ToVals â† {(iParâˆŠâŠ¸/ğ•©)âˆ¾{ğ•©.type}Â¨iTypâŠ‘Â¨âŠ¸âŠğ•©}
    GetTry â‡ {ğ•Š e:
      Try â‡ {
        0==ğ•© ? @ ; # Error from static checking
        t â† {âŠ¢} {numbers.GetBoolâˆ˜ğ•¨.Evalâ—¶@â€¿ğ•}Â´ conds
        T (ToVals ğ•©) env.Fixed e
      }âˆ˜Proc
    }
    Evalâ‡{ valâ€¿decl ğ•Š e:
      A â† ! program._trace_ pos
      "Destructuring non-tuple" A IsTup val
      Aâˆ˜("Destructuring: "âˆ¾âŠ‘)âŸ(0==) pâ†Proc val
      ns {ğ•©â€¿decl ğ•¨.Eval e}Â¨ ToVals p
      {"Destructuring condition failed" A numbers.GetBool ğ•©.Eval e}Â¨ conds
    }
    DefEval â‡ { fâ€¿ValEval ğ•Š e: âŸ¨ValEval @,0âŸ© Eval e }
  }
  Lambda â‡ {
    âŸ¨par,resultâŸ©â†ğ•© â‹„ posâ†ğ•¨
    Visitâ†{(par.VisitLambda ğ•©)âˆ¾âŸ¨ğ•resultâŸ©}
    âŸ¨node,Dump,Disp,NonLocal,OperâŸ©â‡Defaults "lambda"â€¿visit
    Scopeâ‡{ Visit scopes._defer o.Scope par.ScopeLambda ğ•© }
    Evalâ‡{ğ•¨ ğ•Š e: # ğ•¨ is previous value and name, from Define
      next â† ({ğ•©.Get@}âŠ‘ğ•¨)âŠ£{"No matching generator definition"!0Ë™}
      name â† (1âŠ‘ğ•¨)âŠ£""
      âŸ¨TryâŸ©â†par.GetTry e
      Execâ€¿_cached â† { result.nodeâ‰¢"function"?
        Exec â‡ result.Evalâˆ˜âŠ¢ â‹„ _cached â‡ {ğ”½}
      ;
        argsâ†resâ†archesâ†âŸ¨âŸ© â‹„ ANâ†architecture.SeeNext
        Exec â‡ {
          argsâˆ¾â†©<ğ•¨ â‹„ archesâˆ¾â†©<AN@
          n â† (128âŒŠâ‰ )âŠ¸â†‘ nameâˆ¾âˆ¾('_'âˆ¾Â·âˆŠâŸœ(digâˆ¾1â†“alph)âŠ¸/Show)Â¨ğ•¨
          {Setâ‡{resâˆ¾â†©<ğ•©}}â€¿n result.Eval ğ•©
        }
        _cached â‡ {
          i â† (ğ•©âŠ¸((=â—‹â‰ )â—¶âŸ¨0,âˆ§Â´MatchÂ¨âŸ©)Â¨args) âˆ§ archesâ‰¡Â¨<AN@
          âˆ¨Â´i ? (âŠ‘/i)âŠ‘res ; ğ”½ğ•©
        }
      }
      {
        ğ•© @âŠ¸â‰¢â—¶âŸ¨NextâŠ£, ExecâŸ© Try ğ•©
      }_cachedâŠ˜{ğ•Š: {nameâ‡ğ•©} "(generator)"âŸ(0=â‰ ) name}
    }
  }
  Extender â‡ {
    âŸ¨names,resultâŸ©â†ğ•© â‹„ posâ†ğ•¨
    Visitâ†{namesâˆ¾âŸ¨ğ•Â¨resultâŸ©}
    âŸ¨node,Dump,Disp,NonLocal,OperâŸ©â‡Defaults "extender"â€¿visit
    Scopeâ‡{ Visit scopes._defer o.Scope names scopes.New ğ•© }
    Evalâ‡{ğ•¨ğ•Še: {
      A â† ! program._trace_ pos
      "Wrong number of parameters in extension" A namesâ‰¡â—‹â‰ ğ•©
      "Generator defined with extend must be called with extend" A âˆ§Â´ ("var"â‰¡Kind)Â¨ ğ•©
      Â¯1âŠ‘result {ğ•¨.Evalğ•©}Â¨ <ğ•© env.Alias e
    }âŠ˜{ğ•Š: {nameâ‡ğ•©} "(extender)"âŸ(0=â‰ ) (1âŠ‘ğ•¨)âŠ£""}}
  }
  Extend â‡ {
    âŸ¨ext,namesâŸ©â†ğ•© â‹„ posâ†ğ•¨
    Visitâ†{âŸ¨ğ•ext,namesâŸ©}
    âŸ¨node,Dump,Disp,OperâŸ©â‡Defaults "extend"â€¿visit
    Nâ†âŠ¢ â‹„ NonLocalâ‡{ğ•Š:Nâ†©{ğ•©.parent}}
    vâ†@ â‹„ Scope â‡ { ext.Scopeğ•© â‹„ v â†© posâŠ¸(Nğ•©).AddLamÂ¨ names }
    Eval â‡ {
      slots â† {ğ•©.Setğ•¨.Get@â‹„ğ•©}âŸâ‰¢â—‹({ğ•ğ•©}âŸœ(Nğ•©))Â´Â¨ v
      (ext.Evalğ•©){ğ”½} program._trace_ pos slots
    }
  }
  Arg â‡ {
    âŸ¨gather,name,typeâŸ©â†ğ•© â‹„ posâ†ğ•¨
    Visitâ†{âŸ¨name,ğ•typeâŸ©}
    âŸ¨node,Dump,Disp,NonLocal,OperâŸ©â‡Defaults "arg"â€¿visit
    vâ†@ â‹„ Scopeâ‡{ type.Scope ğ•© â‹„ v â†© pos ğ•©.Add name }
    Evalâ‡{
      u â† V ğ•©
      Add â† functions.NextArgâŸœ("Argument" types._get)
      u.Set nameâ€¿gather Add program._trace_ pos type.Eval ğ•©
    }
  }
  Function â‡ {
    âŸ¨args,type,resultâŸ©â†ğ•© â‹„ posâ†ğ•¨
    Visitâ†{âŸ¨ğ•Â¨args,ğ•Â¨type,ğ•resultâŸ©}
    âŸ¨node,Dump,Disp,NonLocal,OperâŸ©â‡Defaults "function"â€¿visit
    Scopeâ‡{ Visit scopes._defer o.Scope scopes.New ğ•© }
    Evalâ‡{
      evâ†o.Eval args env.New ğ•©
      EvÂ¨ args
      ğ•¨.SetRTypeâˆ˜EvÂ¨ type
      Ev result
    } functions._with_ pos
  }
  _setType â† { pos typeâ€¿env _ğ•£ v:
    { â‰ type ?
      t â† "Variable" types._get (âŠ‘type).Eval ğ•©
      t types.Cast v
    ;
      "Explicit type needed for untyped initial value" ! {=ğ•©?âˆ§Â´ğ•ŠÂ¨ğ•©;IsTypedğ•©} v
      v
    } program._trace_ pos env
  }
  Declare â‡ {
    âŸ¨name,type,valueâŸ©â†ğ•© â‹„ posâ†ğ•¨
    Visitâ†{Â¯1âŒ½âŸ¨":",ğ•Â¨type,ğ•value,ğ•nameâŸ©}
    âŸ¨node,Dump,Disp,OperâŸ©â‡Defaults "declare"â€¿visit
    Nâ†âŠ¢ â‹„ NonLocalâ‡{ğ•Š:Nâ†©{ğ•©.parent}}
    Scopeâ‡{ {ğ•Â¨type â‹„ ğ•value} o.Scope ğ•© â‹„ name.Scope N ğ•© }
    Evalâ‡{ vâ†pos typeâ€¿ğ•© _setType value.Eval ğ•© â‹„ vâ€¿1 name.Eval N ğ•© }
  }
  Define â‡ {
    âŸ¨name,valueâŸ©â†ğ•© â‹„ posâ†ğ•¨
    Visitâ†{âŸ¨ğ•name,ğ•valueâŸ©}
    âŸ¨node,Dump,Disp,OperâŸ©â‡Defaults "define"â€¿visit
    Nâ†âŠ¢ â‹„ NonLocalâ‡{ğ•Š:Nâ†©{ğ•©.parent}}
    Scope â‡ {
      value.Scope ğ•©
      ("lambda"â‰¡value.node) name.Scope N ğ•©
    }
    Evalâ‡{
      âŸ¨"function"â‰¡value.node, value.EvalâŸœğ•©âŸ© name.DefEval N ğ•©
    }
  }
  OpDef â‡ {
    âŸ¨op,fn,type,precâŸ©â†ğ•© â‹„ posâ†ğ•¨
    prec â†© prec.Eval@
    Visitâ†{ğ•¤â‹„âŸ¨type,op,fn,â€¢Repr precâŸ©}
    âŸ¨node,Dump,Disp,Scope,EvalâŸ©â‡Defaults "opdef"â€¿visit
    Nâ†âŠ¢ â‹„ NonLocalâ‡{ğ•Š:Nâ†©{ğ•©.parent}}
    Operâ‡{pos (Nğ•©).Add typeâ€¿opâ€¿fnâ€¿prec}
  }
  Include â‡ {
    # Top-level if statements resolve in operator pass; expand then
    âŸ¨filenameâŸ© â† ğ•© â‹„ posâ†ğ•¨
    file â† pos files.Resolve symbols.From filename.Eval@
    NLâ†âŠ¢ â‹„ NonLocalâ‡{ğ•Š:NLâ†©{ğ•©.NonLocal@â‹„ğ•©}}
    âŸ¨node,Dump,DispâŸ©â‡Defaults "include"â€¿{âŸ¨fileâŸ©} â‹„ Scopeâ‡Evalâ‡!
    Oper â‡ {ğ•¤
      b â† NL files.Include file
      âŸ¨node,Dump,Disp,Oper,Scope,EvalâŸ© â†© b # Always a body so fields can't change
      b.Oper ğ•©
    }
  }
  Body â‡ {
    statementsâ†ğ•©
    Visitâ†{âŸ¨ğ•Â¨statementsâŸ©}
    âŸ¨node,Dump,DispâŸ©â‡dâ†Defaults "body"â€¿visit
    Nâ†âŠ¢ â‹„ NonLocalâ‡{ğ•Š:Nâ†©{ğ•©.parent}}
    Operâ‡{ d.Oper operator.NewScope N ğ•© }
    scâ†@ â‹„ Scopeâ‡{ d.Scope sc â†© scopes.New N ğ•© }
    Evalâ‡{ (0<â‰ )â—¶âŸ¨emptyBody,âŠ¢Â´âŸ© âŠ‘ d.Eval (sc.Names@) env.New N ğ•© }
  }
  emptyBody â† {Showsâ‡!âˆ˜"Empty body has no result"â‹„kindâ‡"error"}

  LazyLabel â† {ğ•¤
    label â‡ ğ•©
    GotoC â‡ {
      label functions.LabelâŸ(@âŠ¸â‰¡)â†©
      GotoC â†© {ğ•© ğ•¨â—¶functions.GotoFâ€¿functions.Goto label}
      ğ•¨GotoCğ•©
    }
  }
  CondNode â† {
    terms â† ğ•©
    nameâ€¿_ev â† ğ•¨ â‹„ Evalâ‡terms _ev
    Visitâ†{âŸ¨name,ğ•Â¨termsâŸ©}
    âŸ¨node,Dump,Disp,NonLocal,ScopeâŸ©â‡dâ†Defaults "cond"â€¿visit
  }
  CondEval â† {
    "cond"â‰¡ğ•¨.node ? ğ•¨.Eval ğ•© ;
    nğ•ŠâŸ¨jvâ€¿label,eâŸ©:
    c â† n.Eval e
    { IsTyped c ? jv label.GotoC c â‹„ Â¬jv ; numbers.GetBool c }
  }
  CAccum â† {ğ•Šid: {
    âŸ¨jvâ€¿label,eâŸ©â†ğ•©
    l â† LazyLabel@
    i â† (âŠ‘ğ•—) CondEval âŸ¨Â¬id,lâŸ©âŒ¾âŠ‘âŸ(id=jv) ğ•©
    c â† (1âŠ‘ğ•—) CondEvalâŸœğ•©âŸ((Â¬id)â‰¢âŠ¢) i
    functions.SetLabelâŸ(@âŠ¸â‰¢) l.label
    c
  }}
  condNodes â† âŸ¨
    { nameâ‡"not" â‹„ infixâ‡0 â‹„ _ev â‡ { Â¬ (âŠ‘ğ•—) CondEval Â¬âŒ¾(âŠ‘âŠ‘)ğ•© } }
    { nameâ‡"and" â‹„ infixâ‡1 â‹„ ev â‡ CAccum 1 }
    { nameâ‡"or"  â‹„ infixâ‡1 â‹„ ev â‡ CAccum 0 }
  âŸ©
  CO â† {ğ•Šn: bindâ‡Â¯âˆâ‹„Râ‡âŠ¢â‹„nullâ€¿leftâ‡n.infixâŒ½{Vâ‡nË™ â‹„ Tâ‡Â¯âˆ<{ğ•©.bind}}â€¿@}
  condOp â‡ ({ğ•©.name}Â¨ {ğ•¨âŠ¸âŠâŒ¾< =âŸœ(â‰ ğ•¨)â—¶âŸ¨âŠ‘âŸœğ•©,@âŸ© âŠ¢} COÂ¨) condNodes
  If â‡ {
    âŸ¨cond,then,elseâŸ©â†ğ•© â‹„ posâ†ğ•¨
    Visitâ†{âŸ¨ğ•cond,ğ•then,ğ•Â¨elseâŸ©}
    âŸ¨node,Dump,Disp,NonLocal,ScopeâŸ©â‡Defaults "if"â€¿visit
    IfLabelâ†LazyLabel
    Oper â‡ { cond.Oper operator.CondScope ğ•© â‹„ {ğ•thenâ‹„ğ•Â¨else}o.Oper ğ•© â‹„ operator.nil }
    Eval â‡ {
      lf â† IfLabel@
      c â† cond CondEval âŸ¨0â€¿lf, eâ†ğ•©âŸ©
      { @â‰¢lf.label ?
        then.Eval e
        functions.GotoÂ¨ lt â† functions.LabelÂ¨ else
        functions.SetLabel lf.label
        lt { ğ•©.Eval e â‹„ functions.SetLabel ğ•¨ }Â¨ else
        {Showsâ‡!âˆ˜"Can't use runtime if statement result as value"â‹„kindâ‡"error"}
      ;
        numbers.GetBool c ? then.Eval e ;
        r â† {Showsâ‡!âˆ˜"Can't use if-0 statement result as value"â‹„kindâ‡"error"}
        r âŠ£Â´ { ğ•©.Eval e }Â¨ else
      }
    }
  }
  TopIf â‡ {
    âŸ¨cond,then,elseâŸ©â†ğ•© â‹„ posâ†ğ•¨
    Visitâ†{âŸ¨ğ•cond,ğ•Â¨then,ğ•Â¨elseâŸ©}
    âŸ¨node,Dump,Disp,NonLocalâŸ©â‡Defaults "topif"â€¿visit â‹„ Scopeâ‡Evalâ‡!
    Operâ‡{
      # Latest we can evaluate condition without scope circularity, so do it now
      lf â† { labelâ‡@ â‹„ GotoCâ‡{ğ•Š:!program._trace_ pos"Dynamic top-level if statement unsupported"} }
      cond.Oper operator.CondScope ğ•©
      c â† {ğ•¨ CondEval âŸ¨0â€¿lf, ğ•©âŸ©}ast._runIfCond cond
      body â† c Â¬âŠ¸âŠ‘ thenâ€¿else
      âŸ¨Scope,EvalâŸ© â†© d â† Defaults "topif"â€¿{âŸ¨ğ•Â¨bodyâŸ©}
      d.Oper ğ•©
      operator.nil
    }
  }
  While â‡ {
    âŸ¨testFirst,cond,stmtâŸ©â†ğ•©
    Visitâ†{âŸ¨ğ•cond,ğ•stmtâŸ©}
    âŸ¨node,Dump,Disp,NonLocal,ScopeâŸ©â‡Defaults "while"â€¿visit
    Oper â‡ { cond.Oper operator.CondScope ğ•© â‹„ stmt.Oper ğ•© â‹„ operator.nil }
    Eval â‡ {
      functions.GotoÂ¨ lc â† functions.LabelÂ¨â†•testFirst
      functions.SetLabel lt â† functions.Label@
      stmt.Eval ğ•©
      functions.SetLabelÂ¨ lc
      functions.Gotoâˆ˜ltâŸ(1â‰¡âŠ¢) cond CondEval âŸ¨1â€¿(LazyLabel lt), ğ•©âŸ©
      {Showsâ‡!âˆ˜"Can't use while statement result as value"â‹„kindâ‡"error"}
    }
  }

  n0 â† Number "0"
  For â‡ {
    âŸ¨fn,ptrs,ind,from,to,bodyâŸ©â†ğ•© â‹„ posâ†ğ•¨
    ptriâ†posâŠ¸WordÂ¨ptrnâ†âŠ‘Â¨ptrs
    ptrvâ†ptrs(1âŠ‘âˆ¾âŸœ<)Â¨ptri
    fromâ†©n0âŠ£Â´from
    vardispâ†1â†“âˆ¾(","âŠ¸âˆ¾Â¨ptrn)âˆ¾" over "âŠ¸âˆ¾Â¨ind
    Visitâ†{âŸ¨ğ•fn,vardispâŠ£ğ•Â¨ptriâ‰Ë˜ptrv,ğ•from,ğ•to,ğ•bodyâŸ©}
    âŸ¨node,Dump,Disp,NonLocal,OperâŸ©â‡dâ†Defaults "for"â€¿visit
    lsâ†@
    Scope â‡ {
      (o.Scope ğ•©)Â¨ âˆ¾âŸ¨fnâŸ©â€¿ptrvâ€¿âŸ¨from,toâŸ©
      ls â†© (<pos) {ğ•}âˆ˜ğ•©.GetÂ¨ "load"â€¿"store"
      body.Scope scopes._defer (indâˆ¾ptrn) scopes.New ğ•©
    }
    Eval â‡ {
      eâ†o.Eval ğ•©
      Forâ†(E fn) program._trace_ pos
      lsvâ†(pos var.Get {ğ•ğ•©}âŸœğ•©)Â¨ ls
      For âŸ¨EÂ¨ptrv, E from, E to, blocks.New indâ€¿ptrnâ€¿bodyâ€¿lsvâ€¿ğ•©âŸ©
    }
  }
}

files â† {
  pathâ†@ â‹„ logâ†âŸ¨âŸ©
  Load â† {
    path â†© (âˆ¨`âŒ¾âŒ½'/'âŠ¸=)âŠ¸/ ğ•©
    ğ•© ast.Build â€¢file.Chars ğ•©
  }
  lib â† ('/'âˆ¾ËœâŸ(â‰ âŸœ(Â¯1âŠ¸âŠ‘))âŸ(0<â‰ âˆ˜âŠ¢)âŒ¾âŠ‘Â¨libpaths)âˆ¾<âŸ¨"","include/"âŸ©
  Resolve â‡ {
    '/'=âŠ‘ğ•© ? â€¢file.Exists fâ†ğ•©âˆ¾".singeli" ? f ;
    search â† (â‰ â†‘ğ•©Ë™)âŠ¸â‰¡âˆ˜âŠ‘Â¨âŠ¸/ ('.'=âŠ‘ğ•©) âŠ‘ âŸ¨lib,âŸ¨""â€¿pathâŸ©âŸ©
    Get â† {preâ€¿pathğ•Šğ•©: path â€¢file.At pre â‰ âŠ¸(âŠ¢â†“ËœâŠ£+'/'=âŠ‘) ğ•©}âŸœ(ğ•©âˆ¾".singeli")
    fâ†@ â‹„ {fâ‰¡@? â€¢file.Exists ftâ†Getğ•©? fâ†©ft; @}Â¨ search
    Report â† {" (searched "âˆ¾"and Singeli library)"âˆ¾Ëœâˆ¾â¥Š(GetÂ¨Â¯1â†“ğ•©)âˆ¾Ë˜<", "}
    Errâˆ˜((1<â‰ )â—¶""â€¿Reportâˆ˜searchâŠ¸(âˆ¾Ëœ)âŒ¾âŠ‘)âŸ(fâ‰¡@) "File not found"â€¿ğ•¨
    f
  }
  Include â‡ { logâˆ¾â†©<ğ•© â‹„ pâ†path â‹„ aâ†Load ğ•© â‹„ pathâ†©p â‹„ a }
  Build â‡ { logâ†©âŸ¨âŸ© â‹„ Load ğ•© }
  WriteDeps â‡ { @â‰¢ğ•© ? ğ•© â€¢file.Lines log ; @ }
}

ast â† {
  Show â‡ {â€¢Out âˆ¾âˆ¾âŸœlfÂ¨ ğ•©.Disp @}
  baseScope â† builtins.names scopes.New scopes.Init@
  baseEnv   â† builtins.values env.Fixed @
  baseOper  â† operator.NewScope operator.nilScope
  @ baseOper.Add 'r'â€¿"="â€¿"__set"â€¿Â¯âˆ
  Build â‡ Parseâˆ˜Tokenize
  Compile â‡ {
    t â† files.Build ğ•©
    t.Oper operator.NewScope baseOper
    files.WriteDeps ğ•¨
    t.Scope scopes._run sc â† scopes.New baseScope
    t.Eval program._with (sc.Names@) env.New baseEnv
  }
  _runIfCond â‡ { # For top-level if condition
    ğ•©.Scope scopes._run baseScope
    eâ†@ â‹„ {eâ†©ğ•©}âˆ˜(ğ•©âŠ¸ğ”½) program._with baseEnv â‹„ e
  }
}

(âˆ¾âˆ¾âŸœlfÂ¨) ast.Compile
