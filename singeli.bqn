cpuâ€¿libpaths â† â€¢args

tabâ€¿lfâ†@+9â€¿10

dig â† '0'+â†•10
alphâ† "_"âˆ¾â¥Š"aA"+âŒœâ†•26
wc  â† digâˆ¾alphâˆ¾"."       # Word characters
oc  â† "!$%&*+-/<=>?\^|~" # Operator characters that can stick together

# Source to list of token strings
Tokenizeâ†{
  ğ•©+â†©ğ•©(=Ã—lfâŠ¸-)@+13                          # Convert CR to LF
  ğ•©âˆ¾â†©lf(â‰ â¥ŠâŠ£)Â¯1â†‘ğ•©                            # Trailing newline
  # Resolve comments and strings
  sâ€¿dâ€¿câ€¿nâ†ğ•©âŠ¸=Â¨"'""#"âˆ¾lfâ‹„sdâ†/Â¨sâ€¿d
  gâ†â‹qâ†(Â¯1â†“Â¨sd)âˆ¾âŠ¸âˆ¾/c â‹„qâ†©gâŠq                 # Open indices
  eâ† gâŠ( 1â†“Â¨sd)âˆ¾âŠ¸âˆ¾-âŸœÂ»âˆ˜âŠâŸœ(0âˆ¾+`c)âŠ¸//nâˆ¾1       # Matching close indices
  Seâ†â‰ (>/âŠ¢)âˆ¾âŸœâ‰ {(âŠËœğ•¨)ğ•ŠâŸ(â‰ â—‹(Â¯1âŠ¸âŠ‘))ğ•©âˆ¾ğ•©âŠğ•¨}âŸ¨0âŸ©Ë™  # Find reachable openings
  aâ€¿bâ†((â‰ ğ•©)â†‘Â·/â¼(Se qâ‹e)âŠ¸âŠ)Â¨qâ€¿e              # Open/close masks
  kâ†Â»â‰ `abâ†aâˆ¨b                               # Token continuation mask
  {âŸ¨âŠ‘/ğ•©,"Unclosed quote"âŸ©!0}âŸ(âˆ¨Â´)(sâˆ¨d)>kâˆ¨a
  ignâ†(ğ•©âˆŠ" "âˆ¾tab)âˆ¨â‰ `abâˆ§câˆ¨n                  # Ignored characters
  # Other stuff
  daâ†(Â»ğ•©='.')âˆ§ğ•©âˆŠalph                        # Don't group ...word
  kâˆ¨â†©da<âˆ¨Â´(Â»âŠ¸âˆ§k<ğ•©âŠ¸âˆŠ)Â¨wcâ€¿oc                  # Group names, numbers, and ops
  btâ†(âŒˆ`â†•âˆ˜â‰ Ã—Â¬)k â‹„ xdâ†ğ•©âˆŠdig
  kâˆ¨â†©Â»âŠ¸âˆ¨(Â»(btâŠxd)âˆ§ğ•©='e')âˆ§(ğ•©='-')âˆ§Â«xd        # Negative exponents 12e-3
  tsâ†nâˆ¨Â¬kâˆ¨ign                               # Token start mask
  lcâ†(1+/ğ•©=lf){(âŠ¢â‹ˆÂ¨ğ•©-âŠâŸœ(0âˆ¾ğ•¨))ğ•¨â‹ğ•©}/ts        # Line/column numbers
  âŸ¨ğ•©âŠ”Ëœ1-Ëœ(ign>â‰ `abâˆ§sâˆ¨d)Â¬âŠ¸Ã—+`ts, Source ğ•©â€¿lcâŸ©
}

# Position handler for error reporting
Source â† {
  srcâ€¿lcâ†ğ•©
  { pos ğ•Š disp:
    râ€¿câ†<Ë˜â‰>posâŠlc
    â€¢Out src/Ëœ(src=lf)(âŠ£<+`âŠ¸=)eâ†Â¯1âŠ‘r
    Tr â† {
      e â† (+`(ğ•©â‰¤Â¯1Â»ğ•¨â‰ âŠ¸+Â¨ğ•©))âŠ”ğ•©â‹ˆÂ¨ğ•¨
      l â† "^"âŒ¾(1âŠ‘Â¯1âŠ‘âŠ‘) âŒ½ "|"âŒ¾(1âŠ¸âŠ‘)Â¨âŠ¸âˆ¾` (1+â‰ e)â†‘e
      {âˆ¾((-âŸœÂ»ğ•¨)âˆ¾â‰ Â¯1âŠ‘ğ•©)â†‘Â¨""<âŠ¸âˆ¾ğ•©}Ëâˆ˜â‰âˆ˜>Â¨ l
    }
    â€¢OutÂ¨ disp Trâ—‹((r=e)âŠ¸/) c
  }
}
DispSource â† {ğ•ğ•©}Â´
Err â† { (ğ•©â‰ âŠ¸â¥Šâ€¢Outâ€¿DispSource) {ğ•ğ•©}Â¨ ğ•© â‹„ â€¢Exit 1 }

# Parameter checks for builtins (_p1 and _p2 to use BQN monad/dyad)
_e1 â† {ğ”½âŠ£"Expected one parameter" !1=â‰ } â‹„ _p1â†{ğ”½âŠ‘_e1}
_e2 â† {ğ”½âŠ£"Expected two parameters"!2=â‰ } â‹„ _p2â†{ğ”½Â´_e2}
_e3 â† {ğ”½âŠ£"Expected three parameters"!3=â‰ }
_v1 â† {ğ”½âŠ£"Expected at least one parameter"!1â‰¤â‰ }

numbers â† {knameâ‡"number"
  f â† â€¢Import "float2.bqn"
  NN â† 1â‰ â€¢Type  # Not native number
  Is â† knameâ‰¡{Kindğ•©}
  Wrap â† {kindâ‡knameâ‹„valueâ‡ğ•©â‹„Matchesâ‡Matchâ‹„Showsâ‡FmtLargeâˆ˜ğ•©}
  Unwrap â† {6=â€¢Typeğ•©?knameâ‰¡ğ•©.kind?ğ•©.value; !"Expected constant number"}
  Promote â† NNâ—¶f.Toâ€¿Unwrap
  From â‡ f.Fromâˆ˜UnwrapâŸNN
  GetBool â‡ {"Boolean expected"!âŠ‘ğ•©âˆŠ0â€¿1â‹„ğ•©}âˆ˜From
  Match â‡ âˆ§â—‹Isâ—¶âŸ¨0,â‰¡â—‹PromoteâŸ©

  _be â† {ğ•—âŠ¸Ã—âŠ¸+ËœÂ´âŒ½âˆ˜âŠ¢}
  Nat â† (10 _be âŠ£ "Ill-formed number"!Â·âˆ§Â´0âŠ¸â‰¤âˆ§â‰¤âŸœ9) -âŸœ'0'
  LC â† +âŸœ(32Ã—1="A["âŠ¸â‹) '_'âŠ¸â‰ âŠ¸/  # Lowercase, underscores removed
  da â† digâˆ¾'a'+â†•26
  Read â‡ {
    (â‰ ğ•©)>sâ†âŒŠÂ´ğ•©âŠ"bx" ? # Base n with 0x9abc or 31bNUMBER
      b â† ('b'=sâŠ‘ğ•©)â—¶âŸ¨16âŠ£Â·!"0"âŠ¸â‰¡,NatâŸ© sâ†‘ğ•©
      "Invalid base" ! bâ‰¤â‰ da
      d â† (bâ†‘da) (â‰ âˆ˜âŠ£(âŠ¢âŠ£"Invalid digits"!âˆ§Â´âˆ˜>)âŠ) (1+s)â†“ğ•©
      Eâ†b _be â‹„ EEâ†{hâ€¿lâ†f.Toâˆ˜EÂ¨ğ•¨-âŠ¸(â†“â‹ˆâ†‘)ğ•©â‹„Wrap l f.Add (f.To bâ‹†ğ•¨)f.Mul h}
      (âŒŠ53Ã·2â‹†â¼b) <âŸœâ‰ â—¶Eâ€¿EE d
    ;
      _n â† {('-'=âŠ‘)â—¶âŸ¨ğ”½, -âˆ˜ğ”½ 1âŠ¸â†“âŸ©}
      Pos â† âŠâŸœ"."âŠ¸(Natâˆ˜â†‘ + Â·(0<â‰ )â—¶âŸ¨0,NatÃ·10â‹†â‰ âŸ©+âŸœ1âŠ¸â†“)
      âŠâŸœ"e"âŠ¸(Pos _nâˆ˜â†‘ Ã— <âŸœâ‰ â—¶âŸ¨1,10â‹†Â·Nat _n+âŸœ1âŠ¸â†“âŸ©) ğ•©
  }âŸœLCâŠ{ErrâŸ¨â€¢CurrentError@,ğ•¨âŸ©}

  InRange â† {1=âŠ‘0â‹Ëœ-ËœÂ´âŸœ(âŒ½ğ•¨)Â¨ğ•©}
  FmtLarge â† {
    âŒŠâŠ¸â‰¡ğ•© ? (f.Abs ğ•©) InRange 2â‹†48â€¿64 ? "0x"âˆ¾daâŠËœâŒ½ 16â€¿16 f._repr ğ•© ;
    FmtNum f.From ğ•©
  }

  Cast â‡ {'f'â€¿lğ•Šn:1; qâ€¿lğ•Šn: # 1 if valid; error otherwise
    n NNâ—¶â‹ˆâ€¿Unwrapâ†©
    "Cannot cast float to integer"!âŒŠâŠ¸â‰¡n
    "Constant doesn't fit"!n InRange -âŸœ(1âŠ¸âŠ‘Ã·2Ë™)âŸ(q='i') âŸ¨0,2â‹†lâŸ©
  }
  builtins â‡ {
    Wâ†Wrap â‹„ Pâ†{ğ•Š:Promoteğ•© ; ğ•Šâ¼:Wğ•©} â‹„ Bâ†f.Bitsâˆ˜P
    Eâ†f.To 2â‹†From
    prâ€¿val â† <Ë˜â‰âˆ˜â€¿2â¥Š âŸ¨
      âŠ¢        ,âŸ¨"neg",NNâ—¶âŸ¨-,Wâˆ˜f.Negâ—‹UnwrapâŸ©âŸ©â€¿âŸ¨"not",Â¬GetBoolâŸ©
      {ğ•âŒ¾P}    ,âŸ¨"add"â€¿f.Add, "sub"â€¿f.Sub, "mul"â€¿f.Mul, "div"â€¿f.Div, "mod"â€¿f.ModâŸ©
      {W PâŠ¸ğ•âŸœE},âŸ¨"shl", f.MulâŸ©â€¿âŸ¨"shr", f.Floor f.DivâŸ©
      {ğ•âŒ¾B}    ,âŸ¨ "and"â€¿âˆ§, "or"â€¿âˆ¨, "xor"â€¿â‰  âŸ©
    âŸ©
    arg â† 1â€¿3/{ğ•_p1}â€¿{ğ•_p2}
    â‰>âˆ¾ (arg {ğ•âˆ˜ğ•}Â¨ {{ğ•âš‡0}âˆ˜ğ•âš‡0}Â¨ pr) {âŸ¨"__"âŠ¸âˆ¾,ğ•âŸ©âŠ¸({ğ•ğ•©}Â¨)Â¨ğ•©}Â¨ val
  }
  _cmp â‡ {(f.Cmp ğ”½ 0Ë™)â—‹Promote}
}

ptrWidth â† cpu.width
architecture â† {
  featsâ€¿matâ€¿FeatInd â† cpu
  init â‡ cpu.baseArch
  # Look up a list of symbols
  Id â† {ğ•¨ FeatInd "Expected symbol for architecture feature"âŠ¸symbols.FromÂ¨ğ•©}
  # An architecture is a mask of supported features
  New â‡ { ğ•¨ âˆ¨Ë (1 Id ğ•©) âŠ mat }
  Contains â‡ âˆ§Â´â‰¥
  Intersect â‡ âˆ§ â‹„ Union â‡ âˆ¨
  Has â‡ âˆ§Â´{(0 Id ğ•©)âŠğ•¨âˆ¾0}  # Has all in list ğ•©
  List â‡ /âŸœfeats
  ListExt â‡ List initâŠ¸<
  # Architecture to be used for the next function created
  next â† init
  SeeNext â‡ {ğ•Š:next}
  NewFunction â‡ {ğ•Š: râ†next â‹„ nextâ†©init â‹„ r }
  With â‡ { NewFunction âŠ¢ (âŠ‘ğ•©){ğ”½} âŠ£ {nextâ†©ğ•©}âˆ˜(New 1â†“ğ•©) }_v1
}

MakeStack â† {ğ•¤
  stâ†@ â‹„ dâ†0
  Pushâ‡{   stâ†©ğ•©â€¿st â‹„ d+â†©1}
  Pop â‡{ğ•¤â‹„ râ€¿sâ†st â‹„ stâ†©s â‹„ d-â†©1 â‹„ r}
  Arr â‡{ğ•¤â‹„ âŠ‘Â¨ âŒ½ 1âŠ¸âŠ‘âŸ(â†•d) st}
  _while_â‡{Pop âŠ¢ ğ”½ âŠ£ Â·Pushğ•˜Ë™}
}

MakeStream â† {
  lenâ†â‰ srcâ†ğ•© â‹„ iâ†0
  Pos  â‡ {ğ•¤â‹„i}
  Inc  â† {ğ•¤â‹„i+â†©1}
  Rem  â‡ {ğ•¤â‹„i<len}
  Peek â‡ {ğ•¤â‹„iâŠ‘src}
  Next â‡ Inc âŠ¢ Peek
}

Parse â† {ğ•Š tokensâ€¿ShowTrace:
  # Three kinds of token tests, distinguished by depth.
  Is â† â‰¡âˆ˜âŠ¢â—¶âŸ¨
    {ğ•ğ•¨}   # 0 Function to apply
    â‰¡      # 1 Token
    âŠ‘<âŠ¸âˆŠ   # 2 List of tokens
  âŸ©
  sep â† âŸ¨";", â¥ŠlfâŸ©

  ! (Â¯1âŠ‘tokens) Is sep

  Asrt â† {ğ•¨ğ•Š1:@;
    lâ†{ğ•¨âŠ¸âŠâŠğ•©Ë™}Ëâ‰âˆ˜â€¿2â¥ŠâŸ¨c.arg,"arg",c.assign,"assign",c.body,"body",c.call,"call",c.const,"const",c.define,"define",c.export,"export",c.extend,"extend",c.extender,"extender",c.for,"for",c.function,"function",c.if,"if",c.include,"include",c.lambda,"lambda",c.number,"number",c.opdef,"opdef",c.phrase,"phrase",c.require,"require",c.run,"run",c.symbol,"symbol",c.topif,"topif",c.while,"while",c.word,"word"âŸ©
    ShowTraceâŸœLÂ´ <Ë˜â‰>DumpStack@
    â€¢Out ""
    F â† (â¥Šlf)âŠ¸â‰¡â—¶â€¢Reprâ€¿"end of line"
    â€¢Out {âˆ¾"Expected "â€¿ğ•¨â€¿" but saw "â€¿ğ•©}âŸœFÂ´âŸ(1<â‰¡) ğ•¨
    â€¢Exit 1
  }
  MakeTokStream â† {
    âŸ¨Incâ‡NextâŸ©â†Posâ€¿Remâ€¿Peekâ‡MakeStream ğ•©
    Peek â†© Peek âŠ£ "File ended unexpectedly" Asrt Rem
    Next â‡ PeekâŠ¸Is
    Get  â‡ Inc âŠ¢ {ğ•© (âŠ¢ âŠ£ (ğ•¨â€¢ReprâŠ˜âŠ£âŠ¢)âŠ¸â‹ˆ Asrt IsËœ) Peek@}
    Try  â‡ 1âˆ˜IncâŸâŠ¢âˆ˜Next
  }
  âŸ¨Next,Get,Peek,Try,Rem,PosâŸ© â† MakeTokStream tokens

  # Node creation and error tracking
  c â† nodes
  âŸ¨_whileParse_â‡_while_, DumpStackâ‡ArrâŸ© â† MakeStack@
  _node_ â† {pâ†Pos@ â‹„ (ShowTraceâ—‹â‹ˆâŸœ""âŠ¢)â€¿p ğ”½ ğ”¾_whileParse_âŸ¨p,ğ•—âŸ© ğ•©}

  When  â† {Testâ€¿Cont:       ( â¥Šâˆ˜< Cont)âŸTest   âŸ¨âŸ©  }
  While â† {Testâ€¿Contâ€¿init: {(ğ•Šâˆ¾âŸœ<âŸœCont)âŸTestğ•©} ContÂ¨â†•init}
  _seq â† {â‰¡Â¨âŠ¸((â‰ âŸœ1âˆ§(<sep)â‰¢Â¨âŠ¢)/>âŸœ0â—¶{ğ•@}â€¿(GetâŠ¢)Â¨) ğ”½}

  _begin_ â† {ğ•˜ Get (âŠ‘âˆ˜ğ”½âŠ‘)Ë™}
  _ifASCII â† {(@+128)âŠ¸â‰¤â—¶ğ”½â€¿1}
  Name â† âˆŠâŸœalph _begin_ "name"
  Oper â† âˆŠâŸœoc _ifASCII _begin_ "operator"
  Word â† c.word _node_ (âˆŠâŸœ(wcâˆ¾oc)_ifASCII _begin_ "word")
  Symbol â† c.symbol _node_ ('''âŠ¸=_begin_"symbol")

  AddParams â† {ğ•Šâˆ˜(c.run  _node_ (âŠ¢â‹ˆ"{"â€¿"}"_args))âŸ(Next"{") ğ•©}
  AddArgs   â† {  (c.call _node_ (âŠ¢â‹ˆ"("â€¿")"_args))âŸ(Next"(") ğ•©}
  Expr0 â† {ğ•¤
    Vec â† c.run _node_ ((c.Word"__vec") â‹ˆ "["â€¿Exprâ€¿"]"â€¿Expr0 _seq)
    Par â† âŠ‘ "("â€¿Stmtâ€¿")" _seq
    AResâ† c.body _node_ (Nextâˆ˜"{"â—¶âŸ¨â‹ˆExpr, BodyâŸ©)
    Anonâ† c.lambda _node_ (Paramsâ€¿"=>"â€¿ARes _seq)
    (âŠ‘"[({'"âŠâŠ)â—¶Vecâ€¿Parâ€¿Anonâ€¿Symbolâ€¿Word Peek@
  }
  Callable â† AddParamsâˆ˜Expr0
  NoCall â† âˆŠâŸœ"and"â€¿"or"â€¿"not"âŒ¾<âˆ¨Â´(ocâˆ¾"[")=âŠ
  Call â† { câ†Â¬Next noCall â‹„ AddArgsâŸc Callableğ•© }
  _exprEnd â† {endTok _ğ•£:
    end â† endTokâˆ¾sepâˆ¾â¥ŠÂ¨",:=)}]"
    c.phrase _node_ (Whileâˆ˜âŸ¨Â¬Nextâˆ˜end, Call, 1âŸ©)
  }
  Expr â† âŸ¨âŸ©_exprEnd

  LFs â† {ğ•ŠâŸTry âŸ¨lfâŸ©}
  Div â† {LFs@ â‹„ 1âˆ˜LFsâŸâŠ¢ Try ğ•©}

  _spreadable â† {<âˆ˜âŠ¢âŸâŠ£âŸœğ”½âˆ˜Tryâˆ˜"..."}
  _args â† {ğ•— _argsFn_ (Expr _spreadable)}
  _argsFn_ â† {ğ•¤
    Get âŠ‘ğ•—
    Try 1âŠ‘ğ•— ? âŸ¨âŸ© ;
    LFs@
    a â† While âŸ¨Divâˆ˜",", ğ”¾, 1âŸ©
    Get 1âŠ‘ğ•—
    a
  }

  StSub â† {
  "def":    Define@ ;
  "extend": Extend@ ;
  "if":     c.if     _node_ ("if"â€¿"("â€¿Exprâ€¿")"â€¿Blockâ€¿(Whenâˆ˜âŸ¨Tryâˆ˜"else"âˆ˜Seps,BlockâŸ©)_seq)@ ;
  "while":  c.while  _node_ (1 âˆ¾   "while"â€¿"("â€¿Exprâ€¿")"â€¿Block _seq)@ ;
  "do":     c.while  _node_ (0 âˆ¾âŸœâŒ½ "do"â€¿Blockâ€¿"while"â€¿"("â€¿Exprâ€¿")"â€¿sep _seq)@ ;
  "@":      For@ ;
  ğ•©:
    n â† Expr@
    d â† Try ":"
    e â† Try "="
    t â† When âŸ¨d>e, {eâ†©Try"="â‹„ğ•©}âˆ˜ExprâŸ©
    ToName â† (Asrt@âŠ¸â‰¢)âŠ¸âŠ¢âˆ˜c.PhraseTryName
    c.assign _node_ {âŸ¨ToNameâŸd ğ•©,d,t,Expr@âŸ©}âŸe n
  }
  Stmt â† StSub Peek

  Seps â† {Tryâˆ˜sepâ—¶@â€¿ğ•ŠâŸRemğ•©}
  Body â† {ğ•¤
    Get "{"
    b â† While âŸ¨Â¬Tryâˆ˜"}"âˆ˜Seps, Stmt, 0âŸ©
    "Empty body" Asrt 0<â‰ b
    b
  }
  Block â† "{"âŠ¸â‰¡â—¶âŸ¨StSub, c.body _node_ BodyâŸ© Peek

  For â† c.for _node_ {ğ•¤
    OAâ† "@for: multiple variables must use ""over"""âŠ¸Asrt
    TAâ† "@for: ""from"" missing ""to"""âŠ¸Asrt
    NAâ† "@for: loop variable must be a name"âŠ¸Asrt
    Expr â† "in"â€¿"over"â€¿"from"â€¿"to"_exprEnd # Shadow
    Get "@"
    f â† Callable@
    Get "("
    toâ† Expr@ â‹„ NEâ†{ğ•¤â‹„ nâ†â‹ˆâˆ˜{NA@â‰¢ğ•©â‹„ğ•©}âˆ˜c.PhraseTryNameâŸğ•© to â‹„ toâ†©Expr@ â‹„ n}
    {Try"in"? toâ†©âŸ¨âŠ‘NE 1,toâŸ©; @}
    peâ† While âŸ¨Tryâˆ˜",", Tryâˆ˜"in"â—¶âŸ¨â‹ˆ,â‹ˆâŸœExprâŸ© Name, 0âŸ©
    psâ† {Try"over"?(<NE 0==to)âˆ¾ğ•©; OA 0=â‰ ğ•©â‹„âŸ¨âŸ©} pe # Pointers
    frâ† When âŸ¨Try"from", ExprâŸ©                   # Start index
    i â† {Â¬Try"to"?TA 0=â‰ frâ‹„âŸ¨âŸ©; 0<=to?psâˆ¾â†©<NE 0â‹„âŸ¨âŸ©; NE 1}  # Index variable
    Get ")"
    b â† Block@
    âŸ¨f,ps,i,fr,to,bâŸ©
  }

  # ğ•© indicates if preceding token was =
  Result â† c.body _node_ (("{"â€¿"@"âŠ¸âŠâŒ¾<Peek)â—¶âŸ¨
    Body
    â‹ˆFor
    Exprâ€¿sep _seq "Missing = before body?"AsrtâŠ¢
  âŸ©)

  Params â† {ğ•¤
    Get "{"
    Try "}" ? (0â¥Š<â†•4)â€¿âŸ¨âŸ© ;
    ExprA â† âŸ¨"&"âŸ©_exprEnd
    Param â† {ğ•¤
      v â† Try "..."
      n â† Name@
      e â† When âŸ¨     Try "==", ExprAâŸ©
      t â† When âŸ¨(â‰ e)â—¶Tryâ€¿0":", ExprAâŸ©
      vâ€¿nâ€¿eâ€¿t
    }
    vm â† "At most one variable-length parameter allowed"
    LFs@
    a â† While âŸ¨Divâˆ˜",", Param, 1âŸ© â‹„ vm Asrt 1â‰¥+Â´âŠ‘Â¨a
    c â† While âŸ¨Divâˆ˜"&", ExprA, 0âŸ©
    Get "}"
    aâ€¿c
  }
  _withParams â† {ğ•¤
    (Next"{")â—¶âŸ¨ğ”½, c.lambda _node_ (Paramsâ€¿ğ•Š _seq)âŸ©@
  }

  Function â† c.function _node_ {ğ•¤
    Arg â† c.arg _node_ (Nameâ€¿":"â€¿Expr _seq)
    a â† "("â€¿")" _argsFn_ Arg @
    r â† When âŸ¨Try":", ExprâŸ©
    b â† Result Try"="
    âŸ¨a,r,bâŸ©
  } _withParams
  Const â† c.const _node_ {ğ•¤
    t â† When âŸ¨Â¬Next"=", ExprâŸ©
    Get "="
    v â† Expr@
    tâ€¿v
  }
  FunConst â† (Tryâˆ˜":"â—¶Functionâ€¿Const)
  DefFun â† c.define _node_ (Nameâ€¿FunConst  _seq)
  
  ExtPar â† "{"â€¿"}" _argsFn_ Name
  Extender â† c.extender _node_ (ExtParâ€¿"="â€¿Body _seq)
  Extend â† c.extend _node_ ("extend"â€¿Expr0â€¿ExtPar _seq)

  Generator â† {ğ•¤â‹„ Get"=" â‹„ Result 1} _withParams
  Define â† c.define _node_ {
    Get "def" â‹„  e â† Try "extend"
    âŸ¨Name, eâ—¶Generatorâ€¿ExtenderâŸ©_seq ğ•©
  }

  Export â† c.export _node_ ((Whileâˆ˜âŸ¨Tryâˆ˜",",Symbol,1âŸ©)â€¿"="â€¿Callableâ€¿sep _seq)

  OpType â† {ğ•¤
    pre â† (âŠ‘â‰¢Get) "prefix"â€¿"infix"
    preâ—¶âŸ¨'p', Nextâ—¶âŸ¨'n', âŠ‘âˆ˜Getâˆ˜1âŸ©âŸ© "none"â€¿"left"â€¿"right"
  }
  Number â† c.number _node_ (âˆŠâŸœdig _begin_ "number")
  OpDef â† c.opDef _node_ ("oper"â€¿Operâ€¿Nameâ€¿OpTypeâ€¿Number _seq)

  Include â† c.include _node_ ("include"â€¿Symbol _seq)
  Require â† c.require _node_ ("require"â€¿Symbol _seq)

  TopIf â† c.topif _node_ {ğ•¤
    B â† Tryâˆ˜"{"â—¶âŸ¨â‹ˆLine, MultiLineâŸ©
    "if"â€¿"("â€¿Exprâ€¿")"â€¿Bâ€¿(âˆ¾Whenâˆ˜âŸ¨Tryâˆ˜"else"âˆ˜Seps,BâŸ©)_seq ğ•©
  }

  SubLine â† "def"â€¿"extend"â€¿"oper"â€¿"include"â€¿"require"â€¿"if"âŠ¸âŠâŒ¾<â—¶âŸ¨
    Define, Extend, OpDef, Include, Require, TopIf, ('''=âŠ‘)â—¶DefFunâ€¿Export
  âŸ©
  ChkLoc â† ("localizable line"âŠ¸â‹ˆ Asrt (Â¬"if"âŠ¸â‰¡âˆ¨'''=âŠ‘))âŠ¸âŠ¢âˆ˜Peek
  Line â† {ğ•¤
    Try "local" ? Tryâˆ˜"{"â—¶âŸ¨SubLineâˆ˜ChkLoc,c.body _node_ MultiLineâŸ©@ ;
    {ğ•©.NonLocal@â‹„ğ•©} SubLineâˆ˜Peek@
  }
  MultiLine â† Whileâˆ˜âŸ¨Â¬Tryâˆ˜"}"âˆ˜Seps, Line, 0âŸ©

  Program â† c.body _node_ {ğ•¤
    Seps@
    While âŸ¨Rem, SepsâŠ¢Line, 0âŸ©
  }

  Program @
}

operator â† {
  Parse â‡ {
  âŸ¨opâŸ© ğ•Š âŸ¨vâŸ©: vâŠ£Â´{ğ•©.V@}Â¨@âŠ¸â‰¢Â¨âŠ¸/op.leftâ€¿op.null ;
  ops ğ•Š val:
    Peekâ€¿Nextâ€¿Rem â† MakeStream ops {nullâ€¿leftâ€¿bindâ€¿Râ‡ğ•¨ â‹„ valueâ‡ğ•©}Â¨ val
    E â† {ğ•Štest: {ğ•Šâˆ˜{ğ•© LeD Next@}âŸ(Test Peek)âŸRem ğ•©} NuD Remâ—¶Misâ€¿Next@ }
    NuD â† { ğ•©.null â‰¢âŸœ@â—¶{ğ•©.value}â€¿{ğ•© Run âŸ¨ğ•©.R ğ•¨.V@, âŸ¨E ğ•¨.tâŸ©âŸ©} ğ•© }
    LeD â† { UnkâŸ(@â‰¡lâ†ğ•©.left)ğ•© â‹„ ğ•© Run âŸ¨ğ•©.R l.V@, âŸ¨ğ•¨, E l.tâŸ©âŸ© }
    Run â† {ğ•©.value.pos}âŠ¸nodes.Run
    Unk â† { Err "Unknown infix operator"â€¿ğ•©.value.pos }
    Mis â† {ğ•Š: Err "Missing right operand"â€¿(Â¯1âŠ‘val).pos }
    E 1
  }
  Run â‡ {ğ•¨ğ•ŠâŸ¨op,paramsâŸ©: nullâ€¿leftâ€¿bindâ‡op â‹„ Râ‡ğ•¨ nodes.Run op.Râ‹ˆparamsË™}
  Compose â† {preğ•Šin: âŸ¨nullâŸ©â‡pre â‹„ leftâ€¿bindâ‡in â‹„ Râ‡âŠ¢ }
  nil â‡ { nullâ‡leftâ‡@ â‹„ bindâ‡Â¯âˆ â‹„ Râ‡âŠ¢ }

  Tab â‡ { par ğ•Š new:
    pâ†nâ†oâ†âŸ¨âŸ©  # pos, name, output
    Ind â† { nâŠ¸âŠâŒ¾<ğ•© }
    Add â‡ {
      i â† Ind 1âŠ‘ğ•©
      i<â‰ n ? ErrâŸ¨"Duplicate operator definition:",âŠ‘ğ•©,"Previously defined here:",iâŠ‘pâŸ© ;
      pâ€¿nâ€¿o âˆ¾âŸœ<Â¨â†© râ†(1âŠ‘ğ•©)âŠ¸NewâŒ¾(2âŠ¸âŠ‘)ğ•© â‹„ 2âŠ‘r
    }
    Get â‡ { iâ†Indğ•© â‹„ (i=â‰ n)â—¶âŸ¨iâŠ‘oË™,par.GetâŸ© ğ•© }
  }
  NewScope â‡ {
    parent â‡ ğ•©
    Op â† {nameğ•Švalâ€¿pâ€¿câ€¿a:
      V â‡ nodes.Wordâˆ˜val
      AC â† { Err ("Associativity for operator "âˆ¾nameâˆ¾" must be disambiguated")â€¿ğ•¨.value.pos }âŸ(0âŠ¸>)
      T â‡ (p C {ğ•©.bind}){{âŠ£ACğ•}âŸağ•—}
    }
    tabs â‡ nulâ€¿lef â† parent.tabs TabÂ¨ âŸ¨
      {ğ•¨ğ•ŠâŸ¨value, precâŸ©: null â‡ ğ•¨ Op âŸ¨value, prec, <, 0âŸ© }
      {ğ•¨ğ•ŠâŸ¨value, prec, assocâŸ©:
        bind â‡ prec
        left â‡ ğ•¨ Op âŸ¨value, prec, ("lrn"âŠ¸âŠâŒ¾<assoc)âŠ‘âŸ¨<,â‰¤,<-=âŸ©, 'n'=assocâŸ©
      }
    âŸ©
    Add â‡ {ğ•¨ğ•Štypeâ€¿nameâ€¿valueâ€¿prec:
      lâ†typeâ‰ 'p'
      (lâŠ‘tabs).Add âŸ¨ğ•¨, name, valueâ€¿precâˆ¾lâ¥ŠtypeâŸ©
    }
    Lookup â‡ nul.Get Compose lef.Get
  }
  nilScope â‡ { tabs â‡ 2â¥Š{Getâ‡nilË™} } # Lookup â‡ nilË™
  CondScope â‡ { ğ•Š par:
    parentâ€¿tabsâ€¿Add â‡ par
    Lookup â‡ {@â‰¢câ†nodes.CondOpğ•©?c; par.Lookup ğ•©}
  }
}


# Runtime
# Kinds are:
# - BQN values tuple (list), number, generator (function)
# - Classes symbols, types, registers, constants, functions, blocks
_and_ â† { ğ”½â—¶âŸ¨0,ğ”¾âŸ© }
IsNum â† 1=â€¢Type
IsInt â† IsNum _and_ (âŒŠâŠ¸=)
IsNat â† IsInt _and_ (0âŠ¸â‰¤)
IsTup â† 0=â€¢Type
FmtNum â† 'Â¯'(âŠ¢+=Ã—'-'-âŠ£)â€¢Repr

_tsel â† {â€¢Typeâˆ˜âŠ£â—¶(Â¯1((â†“Â»(6â¥ŠâŸ¨!âˆ˜"Unhandled kind"âŸ©)Ë™)âˆ¾â†‘)ğ•—)}
Kind  â† âŸ¨"tuple","number",@,"generator",{ğ•©.kind}âŸ©_tsel
Show  â† {âŸ¨"tup{"âˆ¾"}"âˆ¾Ëœ1â†“Â·âˆ¾(","âˆ¾ğ•Š)Â¨, FmtNum, !, {(ğ•Ëœ@).name}, {ğ•©.Shows@}âŸ©_tsel ğ•©}
Match â† {ğ•¨ âŸ¨âˆ§Â´ğ•ŠÂ¨, numbers.Match,â‰¡,â‰¡, {ğ•¨ğ•¨.Matchesğ•©}âŸ©_tsel ğ•©}
IsTypedâ†âˆŠâŸœ"register"â€¿"constant"â€¿"function"âŒ¾< Kind
TypeOfâ† {âŸ¨types.Tup ğ•ŠÂ¨, {ğ•©.Type@}âŸ©_tsel ğ•©}

types â† {knameâ‡"type"
  New â† {kğ•Šd:
    kindâ‡kname
    typeKindâ€¿datâ‡ğ•¨â€¿ğ•©
    Tâ†"("âˆ¾")"âˆ¾Ëœ1â†“Â·âˆ¾(","âˆ¾Show)Â¨  # Display type tuple
    Showsâ‡typeKindâ—¶âŸ¨
      "void"               # Void:                     void
      âˆ¾âŸœâ€¢ReprÂ´             # Primitive:   qualâ€¿len     u8
      {âˆ¾"["â€¿ğ•¨â€¿"]"â€¿ğ•©}â—‹ShowÂ´ # Vector:      countâ€¿t      [4]â€¦
      "*"âˆ¾Show             # Pointer:     t            *â€¦
      TâŠ¸{âˆ¾ğ•¨â€¿"->"â€¿ğ•©}âŸœShowÂ´  # Function:    âŸ¨qâ€¿râ€¿s, tâŸ©   (â€¦,â€¦,â€¦) -> â€¦
      T                    # Tuple:       qâ€¿râ€¿s        (â€¦,â€¦,â€¦)
    âŸ©âˆ˜dat
    Matchesâ‡{ğ•¨Isâˆ˜âŠ¢â—¶0â€¿Equivğ•©}
  }
  tVOIDâ€¿tPRIMâ€¿tVECâ€¿tPTRâ€¿tFUNâ€¿tTUP â† â†•6
  TypeKindâ‡{
    "typekind argument must be type"!Is ğ•©
    ğ•©.typeKindâŠ‘"void"â€¿"primitive"â€¿"vector"â€¿"pointer"â€¿"function"â€¿"tuple"
  }
  IsVoid â‡ {tVOIDâ‰¡ğ•©.typeKind}

  primTypes â‡ (tVOID New âŸ¨âŸ©) âˆ¾ tPRIM NewÂ¨ qw â† âˆ¾â‹ˆÂ¨Â¨Ëâ‰ âˆ˜â€¿2â¥ŠâŸ¨
    'u', 2â‹†0âˆ¾3+â†•4  # 1/8/16/32/64
    'i', 2â‹†  3+â†•4  #   8/16/32/64
    'f', 2â‹†  5+â†•2  #        32/64
  âŸ©
  _getPrim â† {{ğ•@} (âŸ¨!âˆ˜ğ•—âŸ©Â«primTypes) âŠ‘Ëœ qwâŠ¸âŠâŒ¾<}

  Is â‡ knameâ‰¡Kind
  Vec â† {nğ•Št: "Vector size should be a constant integer"!IsNat n â‹„ !Is t â‹„ tVEC New âŸ¨n,tâŸ©}
  Ptr â† { ğ•Št: "Pointer type wasn't type"!Is t â‹„ tPTR New t}
  Tup â‡ { ğ•Št: !IsTup t â‹„ !âˆ§Â´IsÂ¨ t â‹„ tTUP New t}
  Fun â‡ tFUN New â‹ˆ

  _cases â† {
    Kindâ†{ğ•©.typeKind} â‹„ Datâ†{ğ•©.dat}
    c â† âŒŠâ€¿2â¥Šğ•—
    k â† âŠË˜c
    d â† (1âŠË˜c) âˆ¾ ((â‰ â¥Šc)â†“ğ•—)Â»âŸ¨!âˆ˜0âŸ©
    (kâŠ¸âŠâŒ¾< âŠ¢âŠ˜(â‰ â—¶âŠ¢â€¿Â¯1)â—‹Kind)â—¶({ğ•â—‹Dat}Â¨âŒ¾((â‰ k)âŠ¸â†‘)d) âŠ£ @â—‹(!Is)
  }

  Quality â† âŸ¨tPRIM,{symbols.New â‹ˆâŠ‘ğ•©}, !âˆ˜"Non-primitive type"âŸ©_cases
  _isQual â† {âŸ¨tPRIM,ğ”½âŠ‘,0âŸ©_cases TypeOfâŸ(Â¬Is)}

  Deref â‡ { Is ğ•© ? tPTR=ğ•©.typeKind ? ğ•©.dat ; !"Expected pointer" }

  Width â† âŸ¨
    tPRIM, 1âŠ¸âŠ‘
    tVEC,  Ã—âŸœ{Widthğ•©}Â´
    tTUP,  +Â´{Widthğ•©}Â¨
    tPTR,  ptrWidth
    {!âˆ¾âŸ¨"Can't find width of ",TypeKindğ•©," types"âŸ©}
  âŸ©_cases

  VCount â† âŸ¨ tVEC,âŠ‘, 1 âŸ© _cases
  VType â† âŸ¨ tVEC,1âŠ¸âŠ‘, tPTR,âŠ¢ âŸ© _cases

  FnCast â‡ {
    argsâ€¿ret â† âŸ¨tFUN,âŠ¢, !âˆ˜"Calling non-function"âŸ©_cases ğ•¨
    args(("Wrong number of arguments: expected "âˆ¾â€¢Reprâˆ˜âŠ£)!â‰¡)â—‹â‰ ğ•©
    âŸ¨args CastÂ¨ ğ•©, retâŸ©
  }

  _typeRel_ â† {
    ğ•¨ âŸ¨
      tVOID, 1
      tPRIM, ğ”½
      tVEC,  =â—‹âŠ‘ _and_ (ğ•Šâ—‹(Â¯1âŠ¸âŠ‘))
      tPTR,  (@â‰¢ğ•˜)âŠ‘ğ•Šâ€¿ğ•˜
      tTUP,  MTup â† =â—‹â‰  _and_ (âˆ§Â´ğ•ŠÂ¨)
      tFUN,  ğ•Šâ—‹(1âŠ¸âŠ‘) _and_ (MTupâ—‹âŠ‘)
      0
    âŸ© _cases ğ•©
  }
  _cmpPrim â† {
    Lâ†Â¯1âŠ¸âŠ‘ â‹„ â‰ â—‹âŠ‘â—¶âŸ¨ğ”½â—‹L, ('f'â‰ âŠ‘âˆ˜âŠ£)_and_(<â—‹L)âŸ©
  }
  Equiv    â† â‰¡          _typeRel_ @
  Subtype  â‡ â‰¤ _cmpPrim _typeRel_ 1
  SSubtype â‡ < _cmpPrim _typeRel_ 0

  _asCast â† {
    "Can't cast to non-type"!Isğ•¨
    Fail â† {!âˆ¾âŸ¨"Can't cast ",Kindğ•©," to ",Showğ•¨âŸ©}
    Num â† {tğ•Šn:
      âŸ¨ tPRIM,numbers.CastâŸœn, FailâŸœn âŸ© _cases t
      t constants.New n
    }
    Cast â† ğ•Š
    Tup â† {
      ptr â† 0
      c â† âŸ¨ tTUP,âŠ¢, tPTR,{ptrâ†©1â‹„ğ•©}, FailâŸœğ•© âŸ©_casesâŸ(0â‰ â€¢Type) ğ•¨
      ğ•¨ constants.NewâŸptr c CastÂ¨ ğ•©
    }
    Obj â† ("number"â‰¢{ğ•©.kind})â—¶âŸ¨Num,IsTypedâˆ˜âŠ¢â—¶âŸ¨FailËœ,ğ”½âŸ©âŸ©
    # _tsel selects on ğ•¨; swap to use ğ•©
    ğ•¨ âŸ¨TupËœ, NumËœ, FailËœ, FailËœ, ObjËœâŸ©_tselËœ ğ•©
  }
  _cc â† { Testâ€¿Convâ€¿Fail _ğ•£:
    (Conv âŠ£ Failâ—‹ShowâŸ(Â¬TestËœ)âŸœTypeOf)_asCast
  }
  Cast â‡ âŸ¨
    Equiv, âŠ¢
    {!âˆ¾âŸ¨"Explicit conversion required to change ",ğ•©," to ",ğ•¨âŸ©}
  âŸ©_cc
  Promote â† âŸ¨
    Subtype, {functions.EmitâŸ¨ğ•¨, symbols.New "^promote", ğ•¨, ğ•©âŸ©}
    {!âˆ¾âŸ¨"Can't promote from type ",ğ•©," to non-subset ",ğ•¨âŸ©}
  âŸ©_cc
  Reinterpret â† âŸ¨
    â‰¡â—‹Width, {functions.EmitâŸ¨ğ•¨, symbols.New "^promote", ğ•¨, ğ•©âŸ©}
    {!âˆ¾âŸ¨"Can't reinterpret type ",ğ•©," as different-width type ",ğ•¨âŸ©}
  âŸ©_cc

  IncWidth â† {
    "First parameter of promote must be a type or number"!"number"â‰¡Kindğ•¨
    nâ†numbers.From ğ•¨
    tâ†TypeOf ğ•©
    (1 + n Ã—âˆ˜- Width t)â—¶âŸ¨
      !âˆ˜"Can't decrease width in promotion"
      âŠ¢
      âŸ¨
        tPRIM, "Invalid width"_getPrim ğ•¨âŒ¾(1âŠ¸âŠ‘)
        !âˆ˜"Can't increase width of non-primitive type"
      âŸ©_casesâˆ˜tâŠ¸Promote
    âŸ© ğ•©
  }
  GetQual â† {
    e â† "Quality must be a single-letter symbol (i,u,f)"
    n â† e symbols.From ğ•© â‹„ e!1=â‰ n
    âŠ‘n
  }
  PrimType â† "Invalid primitive type specification"_getPrim âŸ¨GetQual,numbers.FromâŸ© {ğ•ğ•©}Â¨ âŠ¢

  builtins â‡ âˆ¾Ë˜â‰âˆ˜â€¿2â¥ŠâŸ¨
    âŸ¨"cast"   ,             "promote"   ,"reinterpret"âŸ©
    âŸ¨ Cast _p2,Isâˆ˜âŠ£â—¶IncWidthâ€¿Promote _p2, Reinterpret _p2âŸ©
    âŸ¨"eltype"   ,"vcount"   ,"width"   ,          "__vec"   ,"__pnt"âŸ©
    âŸ¨ VType _p1 , VCount _p1, Width _p1,numbers.FromâŠ¸Vec _p2,   Ptr _p1âŸ©
    âŸ¨"primtype"   ,"quality","isfloat","issigned","isint"âŸ©
    âŸ¨ PrimType _e2, Quality _p1âŸ©âˆ¾{ğ•©_isQual _p1}Â¨âŸ¨'f'âŠ¸â‰¡ â‹„ 'i'âŠ¸â‰¡ â‹„ âŠ‘âˆ˜âˆŠâŸœ"iu"âŸ©
  âŸ©
}

registers â† {knameâ‡"register"
  Is â† kname â‰¡ Kind
  Transient â‡ {
    kindâ‡kname â‹„ showsâ‡"(temp)" â‹„ typeâ‡ğ•© â‹„ fmtTypeâ‡1 â‹„ Matchesâ‡â‰¡
    nameâ†âŸ¨âŸ© â‹„ AddNameâ‡{nameâˆ¾â†©<ğ•©}
    mutâ‡0 â‹„ refâ‡0 â‹„ Useâ‡{ğ•¤â‹„ref+â†©1} â‹„ SetMutâ‡!
    ShowRegâ‡{showRegâ†©âˆ¾âŸ¨ğ•@âŸ©âˆ¾"_"âŠ¸âˆ¾Â¨(ref=1)/name}
  }
  Declare â‡ { name ğ•Š typeâ€¿val:
    kindâ‡kname â‹„ showsâ‡name â‹„ typeâ‡ â‹„ fmtTypeâ‡1 â‹„ Matchesâ‡â‰¡
    addNameâ‡@ â‹„ {ğ•©.AddName name}âŸIs val
    mutâ‡0 â‹„ refâ‡0 â‹„ Useâ‡{ğ•¤â‹„ref+â†©1}
    SetMutâ‡{ğ•¤â‹„mutâ†©1}  # Changed (for blocks, and transient elimination)
    ShowRegâ‡{showRegâ†©ğ•©}âˆ˜{
      Is val? Â¬val.mut? (Â¬mut)âˆ¨1=val.ref? ref+â†©val.ref-1 â‹„ val.ShowRegğ•© ;
      âˆ¾âŸ¨ğ•@,"_",nameâŸ©
    }
  }
  Mutable â‡ { Is ğ•© ? {!}â‰¢ğ•©.setMut ; 0 }
  Mutated â‡ { Is ğ•© ? ğ•©.mut ; 0 }
  MarkUse â‡ {ğ•©.Use@}âŸIs
}
constants â† {knameâ‡"constant"
  New â‡ {
    kindâ‡kname â‹„ typeâ‡ğ•¨ â‹„ valueâ‡ğ•©
    showsâ‡âˆ¾"!:"âˆ¾Â¨ShowÂ¨ğ•©â€¿ğ•¨ â‹„ fmtTypeâ‡0 â‹„ Matchesâ‡â‰¡
  }
  Static â‡ {
    kindâ‡kname â‹„ typeâ€¿handleâ‡ğ•©
    showsâ‡"$c"âˆ¾(""âŠ¢"_"âˆ¾ğ•¨)âˆ¾Ëœâ€¢Repr handle â‹„ fmtTypeâ‡1 â‹„ Matchesâ‡â‰¡
  }
  Undefined â‡ {
    kindâ‡kname â‹„ showsâ‡"?:"âˆ¾Show typeâ‡ğ•© â‹„ fmtTypeâ‡0 â‹„ Matchesâ‡â‰¡
  }
}

labels â† {knameâ‡"label"
  New â‡ { kindâ‡kname â‹„ showsâ‡"l"âˆ¾â€¢Reprğ•© â‹„ Matchesâ‡â‰¡ }
}
symbols â† {knameâ‡"symbol"
  Is â† kname â‰¡ Kind
  From â‡ {!âŸœ(Isğ•©Ë™)ğ•¨ â‹„ ğ•©.symstr}
  M â† Isâˆ˜âŠ¢_and_(â‰¡â—‹From)
  Enc â† "'"(âˆ¾âˆ¾âŠ£)âŠ¢+128Ã—' 'âŠ¸= # Space to non-breaking space
  New â‡ { kindâ‡kname â‹„ symstrâ‡ğ•© â‹„ Showsâ‡Encâˆ˜symstr â‹„ Matchesâ‡M }
}

functions â† {knameâ‡"function"
  currentâ‡{
    Appendâ‡NextLabelâ‡Returnâ‡SetArchâ‡!âˆ˜"No function active"
    arch â‡ architecture.init
  }
  New â† {ğ•¤
    kindâ‡kname â‹„ showsâ‡"$f"âˆ¾(â€¢Repr idâ‡ğ•©)âˆ¾"_"âŠ¸âˆ¾âŸ(0<â‰ )ğ•¨ â‹„ Matchesâ‡â‰¡ â‹„ typeâ‡@
    archâ‡architecture.NewFunction@ â‹„ SetArchâ‡{archâ†©ğ•©}
    labelâ†Â¯1 â‹„ argsâ†atypesâ†âŸ¨âŸ© â‹„ rTypeâ‡@
    NextLabelâ‡{ğ•¤â‹„ labels.New label+â†©1 }
    NextArgâ‡{ atypesâˆ¾â†©<ğ•© â‹„ argsâˆ¾â†©<aâ†ğ•¨ registers.Declare ğ•©â€¿@ â‹„ a }
    âŸ¨Push,ArrâŸ©â†MakeStack@
    Instrsâ‡Arr
    Appendâ‡{ Pushğ•©â‹„@ }
    SetRTypeâ‡{
      SetRTypeâ†©!âˆ˜0 â‹„ !types.Is rTypeâ†©ğ•©
      type â†© atypes types.Fun rType
    }
    _ret_â†{
      @â‰¢rType? types.IsVoid rType? AppendâŸğ•˜ âŸ¨"ret",âŠ‘types.primTypesâŸ© â‹„@ ;
      Append âŸ¨"ret", rType â‰¢âŸœ@â—¶âŸ¨ğ”½âˆ˜âŠ¢, types.CastâŸ© ğ•©âŸ©
      {Showsâ‡!âˆ˜"Can't use return result as value"â‹„kindâ‡"error"}
    }
    Returnâ‡!âˆ˜"Early return from function with no explicit result type" _ret_ 1 @âŠ£Â´âŠ¢
    Finishâ‡{"Explicit result type needed"!IsTyped ğ•©â‹„SetRtype TypeOf ğ•©â‹„ğ•©} _ret_ 0
    Protâ‡{ğ•Š:
      ext â† (0<â‰ )â—¶âŸ¨âŸ©â€¿(â‹ˆÂ·'+'âŒ¾âŠ‘Â·âˆ¾','âŠ¸âˆ¾Â¨) architecture.ListExt arch
      at â† (ğ•Â¨args)â‰Ë˜ShowÂ¨atypes
      1â†“âˆ¾" "âŠ¸âˆ¾Â¨âŸ¨1â†“shows,Show rTypeâŸ©âˆ¾((<âˆ˜â€¢Reprâˆ˜â‰ âˆ¾â¥Š)at)âˆ¾ext
    }
  }
  _with_ â‡ {
    uâ€¿name â† ğ•¨  # Passed in by nodes.Define, pretty hacky
    fsâ†current
    fâ†currentâ†©name program.AddFunction new
    u.Set f
    f (f.Finish ğ”½)program._trace_ ğ•˜ ğ•©
    currentâ†©fs
    f
  }
  NextArg â‡ { ğ•¨ current.NextArg ğ•© }
  Label â‡ { current.NextLabel ğ•© }
  Append â† { current.Append ğ•© }
  _appendReg â† { (1âŠ¸âŠ‘âŠ£Append) âŸ¨"new",ğ”½ğ•¨âŸ©âˆ¾{kindâ‡@â‹„showsâ‡ğ•©}âŒ¾âŠ‘ğ•© }
  AppendNew â† registers.Transient _appendReg
  Return â‡ { current.Return ğ•© }
  GetArch â† {ğ•Š: current.arch }
  SetArch â† { current.SetArch ğ•© }
  Emit â‡ { (âŠ‘ğ•©) AppendNew "emit" <âŠ¸âˆ¾ ğ•© }
  Declare â‡ { tâ†TypeOfğ•© â‹„ ğ•¨ registers.DeclareâŸœtâ€¿ğ•© _appendReg "val"â€¿tâ€¿ğ•© }
  _destructure â† {
    0â‰ â€¢Typeğ•© ? ğ•¨ğ”½âš‡0ğ•©;
    "Single assignment target but multiple values" ! 0=â€¢Typeğ•¨
    "Assignment tuple length mismatch" ! ğ•¨ â‰¡â—‹â‰¢ ğ•©
    ğ•¨ğ•ŠÂ¨ğ•©
  }
  Mut  â‡ {
    "Can't assign to non-register" ! registers.Mutable ğ•¨
    Append "mut"â€¿ğ•¨â€¿(ğ•¨.type types.Cast ğ•©)
    ğ•¨.SetMut@
    ğ•¨
  }_destructure
  Call â‡ {
    f â† âŠ‘ğ•©
    "Calling non-function" ! IsTyped f
    aâ€¿t â† (TypeOf f) types.FnCast 1â†“ğ•©
    t AppendNew âŸ¨"call",t,fâŸ© âˆ¾ â‰ âŠ¸âˆ¾ a
  }
  _instr â† { Append (ğ•¨ğ”½ğ•©)<âŠ¸âˆ¾ğ•¨â‹ˆğ•© â‹„ ğ•© }
  SetLabel â‡ "lbl"_instr
  Goto     â‡ "goto"âŠ˜"gotoT"_instr
  GotoF    â‡ "gotoF"_instr
  builtins â‡ â‰> âŸ¨
    âŸ¨"call",Call _v1âŸ©, âŸ¨"emit",Emit _v1âŸ©, âŸ¨"return",ReturnâŸ©
    âŸ¨"makelabel",LabelâŸ©, âŸ¨"goto",Goto _p1âŸ©
    âŸ¨"setlabel",SetLabel _p1 â‹ˆâˆ˜LabelâŸ(0=â‰ )âŸ©
  âŸ© âˆ¾ { Newâ€¿Unionâ€¿Hasâ€¿List â† architecture â‹„ Sâ†SetArch â‹„ Gâ†GetArch â‹„ âŸ¨
    âŸ¨"setarch",S NewâŸ©
    âŸ¨"addarch",S G Union NewâŸ©
    âŸ¨"hasarch",GâŠ¸HasâŸ©
    âŸ¨"listarch",symbols.NewÂ¨Listâˆ˜GâŸ©
  âŸ©}
}

blocks â† {knameâ‡"block"
  New â‡ {ğ•Š indâ€¿ptrsâ€¿bodyâ€¿lsâ€¿e:
    kindâ‡kname
    showsâ‡"{block}" â‹„ Matchesâ‡â‰¡
    Execâ‡{
      "Wrong number of pointer arguments in block exec" ! ptrsâ‰¡â—‹â‰ 1âŠ‘ğ•©
      r â† body.Eval be â† âŸ¨â‰ ind,ls,ğ•©,ptrsâŸ© env.Block e
      be.Stores @
      r
    }
  }
  Exec â‡ {ğ•Š indâ€¿varsâ€¿block:
    "Executing non-block" ! "block"â‰¡Kind block
    block.Exec indâ€¿vars
  }
}
Load â† {  ğ•Š ptrâ€¿i: functions.Emit âŸ¨types.Deref TypeOf ptr, symbols.New "^load", ptr, iâŸ© }
Storeâ† {v ğ•Š ptrâ€¿i: functions.Emit âŸ¨types.Deref TypeOf ptr, symbols.New "^store", ptr, i, vâŸ© }


builtins â† {
  Kinds â† {
    E â† "Unhandled type" ! 0Ë™
    (e{kâ€¿oâ†ğ•¨â‹„âˆ§â—‹(kâ‰¡âŠ¢)â—¶âŸ¨ğ•,OË™âŸ©}Â´ğ•©){oâ†ğ•¨ğ”½â—‹Kindğ•©â‹„ğ•¨Oğ•©}
  }
  Ty2 â† {ğ•âš‡0 _p2}âˆ˜Kinds âŠ£âˆ¾âŸœ(<Â·"symbol"âŒ¾âŠ‘âŠ¢Â´)âˆ˜âŠ¢âŸ(âŠ‘âˆŠâŸœ=â€¿â‰ )"number"â€¿"type"â‹ˆÂ¨{ğ•numbers._cmp}âŠ¸â‹ˆ
  TypeSuff â† IsTypedâ—¶0â€¿{ğ•©.fmtType}â—¶""â€¿{":"âˆ¾Fmt TypeOfğ•©}
  UnEsc â† âŠ¢-128Ã—(' '+128)âŠ¸= # Non-breaking space to space
  Fmt â† 2â†“Â·âˆ¾Â·", "âŠ¸âˆ¾Â¨(UnEscâˆ˜Showâˆ¾TypeSuff)âŠ("("âˆ¾")"âˆ¾ËœKindâŠ"unknown")Â¨
  Merge â† {
    0<âŒˆÂ´=Â¨ğ•© ? âˆ¾ğ•© ;
    mâ†"merge: parameters must include at least one tuple or all be symbols"
    symbols.New âˆ¾ mâŠ¸symbols.FromÂ¨ğ•©
  }
  Slice â† {
    "slice: one or two slicing values expected"!(2âŠ¸â‰¤âˆ§â‰¤âŸœ3)â‰ ğ•©
    sâ†Â¬=lâ†âŠ‘ğ•©
    l "slice: first parameter must be a tuple or symbol"âŠ¸symbols.FromâŸsâ†©
    iâ†lâ‰ âŠ¸(0âŒˆâŠ£âŒŠ+âŸ(0âŠ¸>)Â¨)numbers.FromÂ¨1â†“ğ•© â‹„ symbols.NewâŸs (âŠ‘i)â†“(1â†“i)â†‘Â´Ëœl
  }
  namesâ€¿values â‡ <Ë˜âˆ¾â‰âŸ¨
    ShowÂ¨âŠ¸â‰ types.primTypes
    â‰> âŸ¨
      âŸ¨"show",(1â‰ â‰ )â—¶âŠ‘â€¿{Showsâ‡!âˆ˜"Multiple show used improperly"}âŠ£â€¢Outâˆ˜FmtâŸ©
      âŸ¨"exec",blocks.Exec _e3âŸ©
      âŸ¨"match",Match _p2âŸ©
      âŸ¨"undefined",(constants.UndefinedâŠ£"undefined: expected type"!"type"â‰¡Kind)_p1âŸ©
      âŸ¨"hastype",IsTypedâˆ˜âŠ‘ _and_ ({ğ•©.type}âŠ¸MatchÂ´)_e2âŸ©
      âŸ¨"type",TypeOf _p1âŸ©, âŸ¨"kind",symbols.New Kind _p1âŸ©
      âŸ¨"typekind",symbols.New types.TypeKind _p1âŸ©
      âŸ¨"load",Load _e2âŸ©, âŸ¨"store",Â¯1âŠ¸(âŠ‘Storeâ†“)_e3âŸ©
      âŸ¨"tup",âŠ¢âŸ©, âŸ¨"tupsel",numbers.FromâŠ¸âŠ‘âš‡0â€¿âˆ _p2âŸ©, âŸ¨"tuplen",â‰ _p1âŸ©
      âŸ¨"merge",MergeâŸ©, âŸ¨"slice",SliceâŸ©
      âŸ¨"symchars",(symbols.Newâˆ˜â‹ˆÂ¨"symchars: expected symbol"âŠ¸symbols.From)_p1âŸ©
      âŸ¨"bind",âŠ‘{ğ•ğ•©âŠ¸âˆ¾}1âŠ¸â†“_v1âŸ©, âŸ¨"each",âŠ‘{ğ•Â¨<Ë˜â‰>ğ•©}1âŠ¸â†“_v1âŸ©
      âŸ¨"apply",{"apply: second parameter must be a tuple"!1==ğ•©â‹„ğ•ğ•©}_p2âŸ©
      âŸ¨"witharch",architecture.WithâŸ©
    âŸ©
    functions.builtins
    numbers.builtins
    types.builtins
    >âŸ¨
      "__eq"â€¿"__ne"â€¿"__lt"â€¿"__gt"â€¿"__le"â€¿"__ge"
      =â€¿â‰ â€¿<â€¿>â€¿â‰¤â€¿â‰¥ Ty2Â¨ âŸ¨Match,Â¬MatchâŸ© âˆ¾ Â·â¥Šâ‰Ë˜âŸœ({ğ•Ëœ}Â¨) âŸ¨types.SSubtype,types.SubtypeâŸ©
    âŸ©
  âŸ©
  values {nameâ‡ğ•©}âŠ¸{ğ•âŠ˜ğ•¨}âŸ(3=â€¢Typeâˆ˜âŠ¢)Â¨Ëœâ†© names
}

var â† {
  Getâ‡{ğ•©.Get@}
  Fixedâ‡{ kindâ‡"var" â‹„ Getâ‡ğ•©Ë™ }
  Newâ‡{NGâ†"generator"â‰¢Kind â‹„ kindâ‡"var"
    vâ†ğ•© â‹„ Getâ‡{ğ•¤â‹„v}
    Setâ‡{
      {ğ•Š:Setâ†©!âˆ˜"Can't extend a non-generator"}âŸNGğ•©
      vâ†©ğ•©
    }
  }
}
scopes â† {
  noLambda â† var.Fixed {!âˆ˜"Unhandled case"}
  nullâ†{Getâ‡{ErrâŸ¨"Undefined name: "âˆ¾ğ•©,ğ•¨âŸ©} â‹„ GetLamâ‡noLambdaË™}
  Newâ‡{
    pâ†@Â¨nâ†ğ•¨âŠ£âŸ¨âŸ© â‹„ Namesâ‡{ğ•¤â‹„n}
    parent â‡ ğ•©  # For nonlocal
    Sel â†{ğ•©âŠ‘env.Vars}
    Makeâ†{câ†â‰ nâ‹„pâ€¿nâˆ¾âŸœ<Â¨â†©ğ•©â‹„c}
    Dup â†{ErrâŸ¨"Duplicate definition:",âŠ‘ğ•©,"Previously defined here:",ğ•¨âŠ‘pâŸ©}
    Par â†{ğ•âˆ˜env.Parent}
    _find â† { (nâŠ¸âŠâŒ¾<ğ•©) =âŸœ(â‰ n)â—¶ğ•— ğ•¨â€¿ğ•© }
    Get â‡ âŸ¨SelâŠ£, Par ğ•©.GetÂ´âˆ˜âŠ¢âŸ© _find
    Add â‡ Sel Dupâ€¿Make _find
    Lam â† ParâŸ(noLambdaâŠ¸â‰¢) ğ•©.GetLamÂ´âˆ˜âŠ¢
    AddLam â‡ âŸ¨â‹ˆËœSelâˆ˜âŠ£, Lamâ‹ˆSelâˆ˜MakeâŸ© _find
    GetLam â‡ âŸ¨SelâŠ£, LamâŸ© _find
  }
  Initâ‡New nullË™

  queue â† âŸ¨âŸ©
  _defer â‡ { queueâˆ¾â†©<ğ”½â€¿ğ•© }
  _run â‡ {
    ğ”½ _defer ğ•©
    _while_ â† {ğ”½âŸğ”¾âˆ˜ğ”½_ğ•£_ğ”¾âˆ˜ğ”½âŸğ”¾ğ•©}
    {ğ•Š:dâ†âŠ‘queueâ‹„queueâ†“Ëœâ†©1â‹„{ğ•ğ•©}Â´d}_while_{ğ•Š:0<â‰ queue} @
  }
}
env â† {
  Vars  â‡{ğ•©.vars}
  Parentâ‡{ğ•©.parent}
  Make â†{ varsâ‡ğ•¨ â‹„ parentâ‡ğ•© }
  Aliasâ‡Make
  New  â‡{ (var.Newâˆ˜@Â¨ ğ•¨) Make ğ•© }
  Fixedâ‡{ (var.FixedÂ¨ ğ•¨) Make ğ•© }
  Blockâ‡{âŸ¨ni,Loadâ€¿Store,indâ€¿ptrs,namesâŸ© ğ•Š par:
    pv â† names functions.Declareâš‡âˆâ€¿0âŸœ(Loadâˆ˜â‹ˆâŸœind)Â¨ ptrs
    varsâ€¿parent â‡ (var.FixedÂ¨(niâ¥Š<ind)âˆ¾pv) Make par
    Stores â‡ {ğ•¤
      ptrs {registers.Mutated ğ•© ? Store ğ•¨â€¿indâ€¿ğ•© ;@}âš‡0 pv
    }
  }
}

program â† {
  AddFunctionâ‡AddConstantâ‡Exportâ‡Requireâ‡!âˆ˜0 â‹„ traceâ‡@
  _with â‡ {
    fnsâ†âŸ¨âŸ© â‹„ AddFunction â†© { f â† ğ•¨ ğ• â‰ fns â‹„ fnsâˆ¾âŸœ<â†©f â‹„ f }
    cnsâ†âŸ¨âŸ© â‹„ AddConstant â†© { c â† ğ•¨ constants.Static âŸ¨tâ†TypeOfğ•©, â‰ cnsâŸ© â‹„ cnsâˆ¾âŸœ<â†©âŸ¨Show c,t,ğ•©âŸ© â‹„ c }
    expâ†âŸ¨âŸ© â‹„ Export â†© { "Exports must be typed" ! IsTyped ğ•© â‹„ exp âˆ¾âŸœ<â†© ğ•¨â€¿ğ•© }
    reqâ†âŸ¨âŸ© â‹„ Require â†© { req âˆ¾âŸœ<â†© ğ•© }
    âŸ¨_trace_âŸ©â†©sâ†Stack@
    ğ•¨ ğ”½âŠs.Report ğ•©
    AddFunctionâ†©AddConstantâ†©Exportâ†©!âˆ˜0
    âˆ¾ âŸ¨DispHeaderÂ¨req, DispConstants cns, âˆ¾DispFunctionÂ¨fns, DispExportÂ¨expâŸ©
  }
  Stack â† {ğ•¤
    âŸ¨_trace_â‡_while_âŸ© â‡ âŸ¨Dumpâ‡ArrâŸ© â† MakeStack@
    Report â‡ {ğ•¤
      â€¢Out (âˆ§`lfâŠ¸â‰ )âŠ¸/âŠâ€¢Repr â€¢CurrentError@
      â€¢Out ""
      # DispSourceÂ¨ âŒ½ Dump@
      # ^ would be the easy way, but we want to compress repeats
      l â† â‰ s â† Dump@
      n â† (â†•l)-Ëœ lâŠ¸=âŠ¸+ â·âŠ¸(âŠ£â‰ âŠ¸â†“âŠ¢âŠ’âˆ¾)âŠs  # Distance to next repetition
      n âŠËœâ†© i â† /Â»âŠ¸â‰ n                 # Split into blocks of equal distance
      e â† n+lÂ«i                       # Last possible endpoint
      Sc â† {ğ•¨ğ•Šnâ€¿iâ€¿e:e-n|âŸ(+ËœâŠ¸â‰¤)e-ğ•¨âŒˆi} # Full reps (if â‰¥2) not overlapping previous
      i âŒˆâ†©Â» e â†© 0 Sc` <Ë˜â‰>âŸ¨n,i,eâŸ©     # Adjust start and end
      iâ€¿nâ€¿e (i<e)âŠ¸/Â¨â†©                 # Filter out empties
      f â† i+n                         # End of displayed reps
      df â† {DispSource ğ•©Ë™}Â¨ s
      rt â† (1<n) ("Repeated "âˆ¾â€¢Reprâˆ˜âŠ¢âˆ¾" times:"âˆ¾/âŸœ" {{{")Â¨ (e-i)Ã·n
      df rtâŠ¸({ğ•âŠ£Â·â€¢Outğ•¨Ë™}Â¨)âŒ¾((f-1)âŠ¸âŠ)â†©
      df {â€¢Outâˆ˜("}}}"âˆ¾@+10)âŠ¢ğ•}Â¨âŒ¾((i/Ëœ1<n)âŠ¸âŠ)â†©
      {ğ•@}Â¨ âŒ½ df /Ëœ 1â‰ `eâ‰ â—‹(lâ†‘/â¼)f     # Remove extra iterations
      â€¢Exit 1
    }
  }
  J â† 1â†“Â·âˆ¾" "âŠ¸âˆ¾Â¨
  DispHeaderâ†{ "require " âˆ¾ Show ğ•© }
  DispConstantsâ†{ âˆ¾âŸœ(<âŸ¨âŸ©)âŸ(0<â‰ ) (J"constant"<âŠ¸âˆ¾ShowÂ¨âŒ¾(1âŠ¸â†“))Â¨ ğ•© }
  DispFunctionâ†{
    ShowReg â† {hâ†Â¯1â‹„{ğ•Š:"v"âˆ¾â€¢Repr h+â†©1}}{ğ•©.ShowRegğ•—}
    ProcInstrs â† {
      # Mark each register with the number of times it's used after definition
      (registers.MarkUseÂ¨2â†“âŠ¢)Â¨ ğ•©
      # Combine new into next mut call if that's the only use
      nm â† / âˆ§âŸœÂ«Ë "new"â€¿"mut" â‰¡âŒœ âŠ‘Â¨ğ•©
      nm (â‰¡â—¶0â€¿{1=ğ•©.ref}Â¨Ë1â€¿2âŠ‘Â¨ğ•©âŠËœ0â€¿1+âŒœâŠ¢)âŠ¸/â†©
      ğ•© â†© (Â¬(â‰ ğ•©)â†‘/â¼1+nm) / (1âŒ½ğ•©) (âŠ£âŒ¾(2âŠ¸â†‘)Â¨âŒ¾(nmâŠ¸âŠ)) ğ•©
      # Convert to names, performing register numbering
      ğ•© ("register"â‰¡Kind)â—¶Showâ€¿ShowRegÂ¨âŒ¾(1âŠ¸â†“)Â¨â†©
      # Registers are aliased when possible, leading to no-op new
      # instructions removed here
      {"new"â‰¡âŠ‘ğ•© ? "val"â‰¡2âŠ‘ğ•© ? â‰¡Â´1â€¿4âŠğ•© ? 0 ; 1}Â¨âŠ¸/ ğ•©
    }
    âˆ¾âŸ¨
      âŸ¨"beginFn "âˆ¾ğ•©.Prot showRegâŸ©
      JÂ¨ ProcInstrs ğ•©.Instrs@
      âŸ¨"endFn",""âŸ©
    âŸ©
  }
  DispExportâ†{ "export " âˆ¾ J <âŠ¸âˆ¾âŸœ(TypeOfâ‹ˆâ—‹ShowâŠ¢)Â´ ğ•© }
}

nodes â† {
  # Node operations
  o â† {
    Verify â‡ {ğ•©.node}
    Dump â‡ {ğ•©.Dump@}
    Disp â‡ {ğ•©.Disp@}
    Oper â‡ {ğ•Šop :{ğ•©.Oper  op }}
    Scopeâ‡ {ğ•Šsc :{ğ•©.Scope sc }}
    Eval â‡ {ğ•Šenv:{ğ•©.Eval  env}}
  }
  Defaults â† {
    nodeâ€¿visit â‡ ğ•©
    Visit o.verify
    Dump â‡ {ğ•¤â‹„âŸ¨node,Visit o.dumpâŸ©}
    Disp â‡ {ğ•¤â‹„node <âŠ¸âˆ¾ "  "âŠ¸âˆ¾Â¨ âˆ¾âˆ¾ @ â¥Šâˆ˜<âˆ˜âŠ¢âŸ((2Ã—â‰¡)+â‰¡âŸœ@)Â¨â—‹Visit o.disp}
    Oper â‡ {Visit o.Oper  ğ•© â‹„ operator.nil}
    Scopeâ‡ {Visit o.Scope ğ•©â‹„@}
    Eval â‡ {Visit o.Eval  ğ•©}
  }

  # Node types
  Ident â† {
    nameâ‡ğ•© â‹„ posâ‡ğ•¨âŠ£@
    âŸ¨node,DumpâŸ©â‡Defaults "ident"â€¿âŸ¨âŸ©
    Dispâ‡{ğ•¤â‹„âŸ¨nameâŸ©}
    Operâ‡{ğ•©.Lookup name}
    Evalâ‡!âˆ˜0 â‹„ Scopeâ‡{Evalâ†©var.Getâˆ˜(pos ğ•©.Get name)}
  }
  _value â† {
    nameâ†ğ•© â‹„ posâ‡ğ•¨âŠ£@
    Evalâ‡(ğ•¨ğ”½ğ•©)Ë™
    âŸ¨node,Dump,Oper,ScopeâŸ©â‡Defaults "value"â€¿âŸ¨âŸ©
    Dispâ‡{ğ•¤â‹„âŸ¨nameâŸ©}
  }
  Number â‡ numbers.Read
  Word â‡ (âŠ‘âŠâˆ˜âŠ¢âˆŠdigË™)â—¶âŸ¨Ident, Number _valueâŸ©
  Symbol â‡ (symbols.New 1â†“Â¯1â†“âŠ¢)_value
  Run â‡ {
    ğ•¨ğ•ŠâŸ¨âŸ¨infixâŸ©,paramsâŸ©: CondNodeÂ´ ğ•©;
    âŸ¨caller,paramsâŸ©â†ğ•© â‹„ posâ‡ğ•¨
    spread â† 0=â€¢TypeÂ¨params â‹„ params âŠ‘Â¨â†©
    deSpread â† (âˆ¨Â´spread)âŠ‘âŠ¢â€¿{
      âˆ¾ spread âŠ£â—¶âŸ¨â‹ˆâŠ¢,("Spread input must be tuple"!IsTup)âŠ¸âŠ¢âŠ¢âŸ©Â¨ğ•©
    }
    Visitâ†{âŸ¨ğ•caller,ğ•Â¨paramsâŸ©}
    âŸ¨node,Dump,Disp,ScopeâŸ©â‡dâ†Defaults "run"â€¿visit
    Oper â‡ {ğ•¤â‹„ pos operator.Run âŸ¨âŠ‘Visit o.Oper ğ•©, paramsâŸ©}
    Eval â‡ {
      (3=â€¢Typeğ•¨)â—¶âŸ¨!âˆ˜"Running non-generator", ğ•âˆ˜DeSpreadâŸ© program._trace_ pos ğ•©
    }Â´ d.Eval
  }
  Call â‡ { ğ•¨ Run âŸ¨Ident"call" , <âŠ¸âˆ¾Â´ğ•©âŸ© }
  Phrase â‡ {
    thingsâ†ğ•© â‹„ posâ‡ğ•¨
    ToNameâ‡{ğ•¤â‹„ (1=â‰ )â—¶@â€¿(("ident"â‰¡{ğ•©.node})â—¶@â€¿{ğ•©.name}âŠ‘) things }
    Visitâ†{âŸ¨ğ•Â¨thingsâŸ©}
    âŸ¨node,Dump,Disp,Scope,EvalâŸ©â‡Defaults "phrase"â€¿visit
    Operâ‡{
      âŸ¨nodeâŸ©â†©n â† (o.Oper ğ•©)Â¨âŠ¸operator.Parse things
      Scopeâ†©{ğ•¨n.Scopeğ•©} â‹„ Evalâ†©{ğ•¨n.Evalğ•©} â‹„ Dispâ†©{ğ•¨n.Dispğ•©} # fields of n can change
      operator.nil
    }
  }
  PhraseTryName â‡ {"phrase"â‰¡ğ•©.node}â—¶@â€¿{ğ•©.ToName@}
  notTypeVar â† types.primTypesâ‰ âŠ¸â†‘builtins.names
  Lambda â‡ {
    âŸ¨âŸ¨paramsPlus,condsâŸ©,resultâŸ©â†ğ•© â‹„ posâ†ğ•¨
    pvarâ€¿paramsâ€¿pmatchâ€¿ptype â† <Ë˜â‰>paramsPlus
    tname â† (Â¬âˆ˜âˆŠâŸœ(âŸ¨@âŸ©âˆ¾notTypeVar)âŠ¸/ PhraseTryNameÂ¨)Â¨ ptype
    uTypâ€¿iTypâ†(â·âˆ˜âˆ¾ â‹ˆ âŠâˆ˜âˆ¾âŠ”Â·/â‰ Â¨)tname
    _pc â† {nâ†ğ•¨â‹„fâ†ğ•— â‹„ {pos Run âŸ¨Ident f,âŸ¨Ident n,ğ•©âŸ©âŸ©}Â¨ğ•©}
    condsâˆ¾Ëœâ†©âˆ¾(params "hastype"_pcÂ¨ tnameâ‰ âŠ¸â†“Â¨ptype)âˆ¾(params "match"_pcÂ¨ pmatch)
    uParâ€¿iParâ†(â·â‹ˆâŠ)params
    Visitâ†{((iParâŠuPar)âˆ¾âŸœ(âˆ¾""<âŠ¸âˆ¾":"âŠ¸âˆ¾Â¨)Â¨tname)âˆ¾âŸ¨ğ•Â¨conds,ğ•resultâŸ©}
    âŸ¨node,Dump,Disp,OperâŸ©â‡Defaults "lambda"â€¿visit
    Scopeâ‡{ Visit scopes._defer o.Scope (uParâˆ¾uTyp) scopes.New ğ•© }
    Evalâ‡{ğ•¨ ğ•Š e: # ğ•¨ is previous value and name, from Define
      next â† ({ğ•©.Get@}âŠ‘ğ•¨)âŠ£{"No matching generator definition"!0Ë™}
      name â† (1âŠ‘ğ•¨)âŠ£""
      AllEq â† âˆ§Â´âŠMatchÂ¨1âŠ¸â†“
      Countâ€¿DeVar â† (+Â´Â¬)âŠ¸{
        Â¬âˆ¨Â´ğ•© ? âŸ¨ğ•¨=â‰ , âŠ¢âŸ© ;
        âŸ¨ğ•¨â‰¤â‰ , (0â€¿ğ•¨-Ëœâ‹ˆâ¼/ğ•©)âŠ¸(âˆ¾0â€¿2â€¿1âŠâ†‘Â¨âŸœ<âˆ¾âŸœ<Â·<â†“Â´Ëœ)âŸ©
      } pvar
      CT â† {âˆ§Â´((âˆ§Â´IsTypedÂ¨)_and_(AllEq{ğ•©.type}Â¨)âŠâŸœğ•©)Â¨iTyp}
      Execâ€¿_cached â† { result.nodeâ‰¢"function"?
        Exec â‡ result.Evalâˆ˜âŠ¢ â‹„ _cached â‡ {ğ”½}
      ;
        argsâ†resâ†archesâ†âŸ¨âŸ© â‹„ ANâ†architecture.SeeNext
        Exec â‡ {
          argsâˆ¾â†©<ğ•¨ â‹„ archesâˆ¾â†©<AN@
          n â† (128âŒŠâ‰ )âŠ¸â†‘ nameâˆ¾âˆ¾('_'âˆ¾Â·âˆŠâŸœ(digâˆ¾1â†“alph)âŠ¸/Show)Â¨ğ•¨
          {Setâ‡{resâˆ¾â†©<ğ•©}}â€¿n result.Eval ğ•©
        }
        _cached â‡ {
          i â† (ğ•©âŠ¸((=â—‹â‰ )â—¶âŸ¨0,âˆ§Â´MatchÂ¨âŸ©)Â¨args) âˆ§ archesâ‰¡Â¨<AN@
          âˆ¨Â´i ? (âŠ‘/i)âŠ‘res ; ğ”½ğ•©
        }
      }
      {
        Count ğ•© ? aâ†DeVarğ•© â‹„ âˆ§Â´AllEqÂ¨iParâŠ”a ? CT a ?
        try â† (âŠ‘âŸ¨aË™âŠ¸execâŸ©) (Next ğ•©Ë™){numbers.GetBoolâˆ˜ğ•¨.Evalâ—¶ğ”½â€¿ğ•}Â´ conds
        Try ((iParâˆŠâŠ¸/a)âˆ¾{ğ•©.type}Â¨iTypâŠ‘Â¨âŠ¸âŠa) env.Fixed e
      ;
        Next ğ•©
      }_cachedâŠ˜{ğ•Š: {nameâ‡ğ•©} "(generator)"âŸ(0=â‰ ) name}
    }
  }
  Extender â‡ {
    âŸ¨names,resultâŸ©â†ğ•© â‹„ posâ†ğ•¨
    Visitâ†{namesâˆ¾âŸ¨ğ•Â¨resultâŸ©}
    âŸ¨node,Dump,Disp,OperâŸ©â‡Defaults "extender"â€¿visit
    Scopeâ‡{ Visit scopes._defer o.Scope names scopes.New ğ•© }
    Evalâ‡{ğ•¨ğ•Še: {
      A â† ! program._trace_ pos
      "Wrong number of parameters in extension" A namesâ‰¡â—‹â‰ ğ•©
      "Generator defined with extend must be called with extend" A âˆ§Â´ ("var"â‰¡Kind)Â¨ ğ•©
      Â¯1âŠ‘result {ğ•¨.Evalğ•©}Â¨ <ğ•© env.Alias e
    }âŠ˜{ğ•Š: {nameâ‡ğ•©} "(extender)"âŸ(0=â‰ ) (1âŠ‘ğ•¨)âŠ£""}}
  }
  Extend â‡ {
    âŸ¨ext,namesâŸ©â†ğ•© â‹„ posâ†ğ•¨
    Visitâ†{âŸ¨ğ•ext,namesâŸ©}
    âŸ¨node,Dump,Disp,OperâŸ©â‡Defaults "extend"â€¿visit
    Nâ†âŠ¢ â‹„ NonLocalâ‡{ğ•Š:Nâ†©{ğ•©.parent}}
    vâ†@ â‹„ Scope â‡ { ext.Scopeğ•© â‹„ v â†© posâŠ¸(Nğ•©).AddLamÂ¨ names }
    Eval â‡ {
      slots â† {ğ•©.Setğ•¨.Get@â‹„ğ•©}âŸâ‰¢â—‹({ğ•ğ•©}âŸœ(Nğ•©))Â´Â¨ v
      (ext.Evalğ•©){ğ”½} program._trace_ pos slots
    }
  }
  Arg â‡ {
    âŸ¨name,typeâŸ©â†ğ•© â‹„ posâ†ğ•¨
    Visitâ†{âŸ¨name,ğ•typeâŸ©}
    âŸ¨node,Dump,Disp,OperâŸ©â‡Defaults "arg"â€¿visit
    vâ†@ â‹„ Scopeâ‡{ type.Scope ğ•© â‹„ v â†© pos ğ•©.Add name }
    Evalâ‡{
      uâ†Vğ•© â‹„ tâ†type.Eval ğ•©
      "Argument type must be a type" ! program._trace_ pos types.Is t
      u.Set name functions.NextArg t
    }
  }
  Function â‡ {
    âŸ¨args,type,resultâŸ©â†ğ•© â‹„ posâ†ğ•¨
    Visitâ†{âŸ¨ğ•Â¨args,ğ•Â¨type,ğ•resultâŸ©}
    âŸ¨node,Dump,Disp,OperâŸ©â‡Defaults "function"â€¿visit
    Scopeâ‡{ Visit scopes._defer o.Scope scopes.New ğ•© }
    Evalâ‡{
      evâ†o.Eval args env.New ğ•©
      EvÂ¨ args
      ğ•¨.SetRTypeâˆ˜EvÂ¨ type
      Ev result
    } functions._with_ pos
  }
  _setType â† { pos typeâ€¿env _ğ•£ v:
    { â‰ type ?
      t â† (âŠ‘type).Eval ğ•©
      "Variable type must be a type" ! types.Is t
      t types.Cast v
    ;
      "Explicit type needed for untyped initial value" ! {=ğ•©?âˆ§Â´ğ•ŠÂ¨ğ•©;IsTypedğ•©} v
      v
    } program._trace_ pos env
  }
  Assign â‡ { pos ğ•Š âŸ¨name,1,type,valueâŸ©: # Declaration
    Visitâ†{âŸ¨nameâˆ¾":",ğ•Â¨type,ğ•valueâŸ©}
    âŸ¨node,Dump,Disp,OperâŸ©â‡Defaults "assign"â€¿visit
    GetVarâ†!âˆ˜0 â‹„ Scopeâ‡{
      Visit o.Scope ğ•©
      getVar â†© pos ğ•©.Add name
    }
    Evalâ‡{
      u â† GetVar ğ•©
      v â† pos typeâ€¿ğ•© _setType value.Eval ğ•©
      u.Set nameâŠ¸functions.Declareâš‡0 v
    }
  ;
    ğ•¨ Run âŸ¨{functions.MutÂ´ğ•©}Ë™_value"=" , 0â€¿3âŠğ•©âŸ©
  }
  Const â‡ {
    âŸ¨type,valueâŸ©â†ğ•© â‹„ posâ†ğ•¨
    Visitâ†{âŒ½âŸ¨ğ•Â¨type,":",ğ•valueâŸ©}
    âŸ¨node,Dump,Disp,Oper,ScopeâŸ©â‡Defaults "assign"â€¿visit
    Evalâ‡{ (1âŠ‘ğ•¨) program.AddConstant pos typeâ€¿ğ•© _setType value.Eval ğ•© }
  }
  Define â‡ {
    âŸ¨name,valueâŸ©â†ğ•© â‹„ posâ†ğ•¨
    Visitâ†{âŸ¨name,ğ•valueâŸ©}
    âŸ¨node,Dump,Disp,OperâŸ©â‡Defaults "define"â€¿visit
    Nâ†âŠ¢ â‹„ NonLocalâ‡{ğ•Š:Nâ†©{ğ•©.parent}}
    v0â†vâ†@ â‹„ Scope â‡ {
      value.Scope ğ•©
      s â† N ğ•©
      v0â€¿v â†© pos ("lambda"â‰¡value.node)â—¶âŸ¨ @â‹ˆs.Add , s.AddLam âŸ© name
    }
    Evalâ‡{
      fâ†"function"â‰¡value.node  # Set value in Eval for function recursion
      e â† N ğ•©
      uâ†V e â‹„ u.Set program._trace_ posâŸ(Â¬f) (nameâ‹ˆËœfâ—¶âŸ¨V0,uË™âŸ©e) value.Eval ğ•©
    }
  }
  OpDef â‡ {
    âŸ¨op,fn,type,precâŸ©â†ğ•© â‹„ posâ†ğ•¨
    Visitâ†{ğ•¤â‹„âŸ¨type,op,fn,â€¢Repr precâŸ©}
    âŸ¨node,Dump,Disp,Scope,EvalâŸ©â‡Defaults "opdef"â€¿visit
    Nâ†âŠ¢ â‹„ NonLocalâ‡{ğ•Š:Nâ†©{ğ•©.parent}}
    Operâ‡{pos (Nğ•©).Add typeâ€¿opâ€¿fnâ€¿prec}
  }
  Export â‡ {
    âŸ¨name,valueâŸ© â† {Show ğ•©.Eval@}Â¨âŒ¾âŠ‘ ğ•© â‹„ posâ†ğ•¨
    Visitâ†{âŸ¨name,ğ•valueâŸ©}
    âŸ¨node,Dump,Disp,Oper,ScopeâŸ©â‡dâ†Defaults "export"â€¿visit
    NonLocal â‡ âŠ¢
    Eval â‡ { program.Export program._trace_ posÂ¨âŸœ<Â´ d.Eval ğ•© }
  }
  Include â‡ {
    # Top-level if statements resolve in operator pass; expand then
    âŸ¨fileâŸ© â† ğ•© â‹„ posâ†ğ•¨
    NLâ†âŠ¢ â‹„ NonLocalâ‡{ğ•Š:NLâ†©{ğ•©.NonLocal@â‹„ğ•©}}
    âŸ¨node,Dump,DispâŸ©â‡Defaults "include"â€¿{âŸ¨ğ•fileâŸ©} â‹„ Scopeâ‡Evalâ‡!
    Oper â‡ {ğ•¤
      b â† NL pos files.Include symbols.From file.Eval@
      âŸ¨node,Dump,Disp,Oper,Scope,EvalâŸ© â†© b # Always a body so fields can't change
      b.Oper ğ•©
    }
  }
  Require â‡ {
    âŸ¨fileâŸ© â† ğ•©
    âŸ¨node,Dump,DispâŸ©â‡Defaults "require"â€¿{âŸ¨ğ•fileâŸ©} â‹„ Scopeâ‡Operâ‡NonLocalâ‡âŠ¢
    Eval â‡ {ğ•Š: program.Require file.Eval@}
  }
  Body â‡ {
    statementsâ†ğ•©
    Visitâ†{âŸ¨ğ•Â¨statementsâŸ©}
    âŸ¨node,Dump,DispâŸ©â‡dâ†Defaults "body"â€¿visit
    Nâ†âŠ¢ â‹„ NonLocalâ‡{ğ•Š:Nâ†©{ğ•©.parent}}
    Operâ‡{ d.Oper operator.NewScope N ğ•© }
    scâ†@ â‹„ Scopeâ‡{ d.Scope sc â†© scopes.New N ğ•© }
    Evalâ‡{ Â¯1âŠ‘âŠ‘d.Eval (sc.Names@) env.New N ğ•© }
  }

  LazyLabel â† {ğ•¤
    label â‡ ğ•©
    GotoC â‡ {
      label functions.LabelâŸ(@âŠ¸â‰¡)â†©
      GotoC â†© {ğ•© ğ•¨â—¶functions.GotoFâ€¿functions.Goto label}
      ğ•¨GotoCğ•©
    }
  }
  CondNode â† {
    terms â† ğ•©
    nameâ€¿_ev â† ğ•¨ â‹„ Evalâ‡terms _ev
    Visitâ†{âŸ¨name,ğ•Â¨termsâŸ©}
    âŸ¨node,Dump,Disp,ScopeâŸ©â‡dâ†Defaults "cond"â€¿visit
  }
  CondEval â† {
    "cond"â‰¡ğ•¨.node ? ğ•¨.Eval ğ•© ;
    nğ•ŠâŸ¨jvâ€¿label,eâŸ©:
    c â† n.Eval e
    { IsTyped c ? jv label.GotoC c â‹„ Â¬jv ; numbers.GetBool c }
  }
  CAccum â† {ğ•Šid: {
    âŸ¨jvâ€¿label,eâŸ©â†ğ•©
    l â† LazyLabel@
    i â† (âŠ‘ğ•—) CondEval âŸ¨Â¬id,lâŸ©âŒ¾âŠ‘âŸ(id=jv) ğ•©
    c â† (1âŠ‘ğ•—) CondEvalâŸœğ•©âŸ((Â¬id)â‰¢âŠ¢) i
    functions.SetLabelâŸ(@âŠ¸â‰¢) l.label
    c
  }}
  condNodes â† âŸ¨
    { nameâ‡"not" â‹„ infixâ‡0 â‹„ _ev â‡ { Â¬ (âŠ‘ğ•—) CondEval Â¬âŒ¾(âŠ‘âŠ‘)ğ•© } }
    { nameâ‡"and" â‹„ infixâ‡1 â‹„ ev â‡ CAccum 1 }
    { nameâ‡"or"  â‹„ infixâ‡1 â‹„ ev â‡ CAccum 0 }
  âŸ©
  CO â† {ğ•Šn: bindâ‡Â¯âˆâ‹„Râ‡âŠ¢â‹„nullâ€¿leftâ‡n.infixâŒ½{Vâ‡nË™ â‹„ Tâ‡Â¯âˆ<{ğ•©.bind}}â€¿@}
  condOp â‡ ({ğ•©.name}Â¨ {ğ•¨âŠ¸âŠâŒ¾< =âŸœ(â‰ ğ•¨)â—¶âŸ¨âŠ‘âŸœğ•©,@âŸ© âŠ¢} COÂ¨) condNodes
  If â‡ {
    âŸ¨cond,then,elseâŸ©â†ğ•© â‹„ posâ†ğ•¨
    Visitâ†{âŸ¨ğ•cond,ğ•then,ğ•Â¨elseâŸ©}
    âŸ¨node,Dump,Disp,ScopeâŸ©â‡Defaults "if"â€¿visit
    IfLabelâ†LazyLabel
    Oper â‡ { cond.Oper operator.CondScope ğ•© â‹„ {ğ•thenâ‹„ğ•Â¨else}o.Oper ğ•© â‹„ operator.nil }
    Eval â‡ {
      lf â† IfLabel@
      c â† cond CondEval âŸ¨0â€¿lf, eâ†ğ•©âŸ©
      { @â‰¢lf.label ?
        then.Eval e
        functions.GotoÂ¨ lt â† functions.LabelÂ¨ else
        functions.SetLabel lf.label
        lt { ğ•©.Eval e â‹„ functions.SetLabel ğ•¨ }Â¨ else
        {Showsâ‡!âˆ˜"Can't use runtime if statement result as value"â‹„kindâ‡"error"}
      ;
        numbers.GetBool c ? then.Eval e ;
        r â† {Showsâ‡!âˆ˜"Can't use if-0 statement result as value"â‹„kindâ‡"error"}
        r âŠ£Â´ { ğ•©.Eval e }Â¨ else
      }
    }
  }
  TopIf â‡ {
    âŸ¨cond,then,elseâŸ©â†ğ•© â‹„ posâ†ğ•¨ â‹„ NonLocalâ‡âŠ¢
    Visitâ†{âŸ¨ğ•cond,ğ•Â¨then,ğ•Â¨elseâŸ©}
    âŸ¨node,Dump,DispâŸ©â‡Defaults "topif"â€¿visit â‹„ Scopeâ‡Evalâ‡!
    Operâ‡{
      # Latest we can evaluate condition without scope circularity, so do it now
      lf â† { labelâ‡@ â‹„ GotoCâ‡{ğ•Š:!program._trace_ pos"Dynamic top-level if statement unsupported"} }
      cond.Oper operator.CondScope ğ•©
      c â† {ğ•¨ CondEval âŸ¨0â€¿lf, ğ•©âŸ©}ast._runIfCond cond
      body â† c Â¬âŠ¸âŠ‘ thenâ€¿else
      âŸ¨Scope,EvalâŸ© â†© d â† Defaults "topif"â€¿{âŸ¨ğ•Â¨bodyâŸ©}
      d.Oper ğ•©
      operator.nil
    }
  }
  While â‡ {
    âŸ¨testFirst,cond,stmtâŸ©â†ğ•©
    Visitâ†{âŸ¨ğ•cond,ğ•stmtâŸ©}
    âŸ¨node,Dump,Disp,ScopeâŸ©â‡Defaults "while"â€¿visit
    Oper â‡ { cond.Oper operator.CondScope ğ•© â‹„ stmt.Oper ğ•© â‹„ operator.nil }
    Eval â‡ {
      functions.GotoÂ¨ lc â† functions.LabelÂ¨â†•testFirst
      functions.SetLabel lt â† functions.Label@
      stmt.Eval ğ•©
      functions.SetLabelÂ¨ lc
      functions.Gotoâˆ˜ltâŸ(1â‰¡âŠ¢) cond CondEval âŸ¨1â€¿(LazyLabel lt), ğ•©âŸ©
      {Showsâ‡!âˆ˜"Can't use while statement result as value"â‹„kindâ‡"error"}
    }
  }

  n0 â† Word "0"
  For â‡ {
    âŸ¨fn,ptrs,ind,from,to,bodyâŸ©â†ğ•© â‹„ posâ†ğ•¨
    ptriâ†posâŠ¸IdentÂ¨ptrnâ†âŠ‘Â¨ptrs
    ptrvâ†ptrs(1âŠ‘âˆ¾âŸœ<)Â¨ptri
    fromâ†©n0âŠ£Â´from
    vardispâ†1â†“âˆ¾(","âŠ¸âˆ¾Â¨ptrn)âˆ¾" over "âŠ¸âˆ¾Â¨ind
    Visitâ†{âŸ¨ğ•fn,vardispâŠ£ğ•Â¨ptriâ‰Ë˜ptrv,ğ•from,ğ•to,ğ•bodyâŸ©}
    âŸ¨node,Dump,Disp,OperâŸ©â‡dâ†Defaults "for"â€¿visit
    lsâ†@
    Scope â‡ {
      (o.Scope ğ•©)Â¨ âˆ¾âŸ¨fnâŸ©â€¿ptrvâ€¿âŸ¨from,toâŸ©
      ls â†© (<pos) {ğ•}âˆ˜ğ•©.GetÂ¨ "load"â€¿"store"
      body.Scope scopes._defer (indâˆ¾ptrn) scopes.New ğ•©
    }
    Eval â‡ {
      eâ†o.Eval ğ•©
      Forâ†(E fn) program._trace_ pos
      lsvâ†var.Getâˆ˜{ğ•ğ•©}âŸœğ•©Â¨ ls
      For âŸ¨EÂ¨ptrv, E from, E to, blocks.New indâ€¿ptrnâ€¿bodyâ€¿lsvâ€¿ğ•©âŸ©
    }
  }
}

files â† {
  pathâ†@ â‹„ logâ†âŸ¨âŸ©
  Load â† {
    path â†© (âˆ¨`âŒ¾âŒ½'/'âŠ¸=)âŠ¸/ ğ•©
    ast.Build â€¢file.Chars ğ•©
  }
  lib â† ('/'âˆ¾ËœâŸ(â‰ âŸœ(Â¯1âŠ¸âŠ‘))âŒ¾âŠ‘Â¨libpaths)âˆ¾<âŸ¨"","include/"âŸ©
  Include â‡ {
    search â† (â‰ â†‘ğ•©Ë™)âŠ¸â‰¡âˆ˜âŠ‘Â¨âŠ¸/ ('.'=âŠ‘ğ•©) âŠ‘ âŸ¨lib,âŸ¨""â€¿pathâŸ©âŸ©
    Get â† {preâ€¿pathğ•Šğ•©: path â€¢file.At pre â‰ âŠ¸(âŠ¢â†“ËœâŠ£+'/'=âŠ‘) ğ•©}âŸœ(ğ•©âˆ¾".singeli")
    fâ†@ â‹„ {fâ‰¡@? â€¢file.Exists ftâ†Getğ•©? fâ†©ft; @}Â¨ search
    Report â† {" (searched "âˆ¾"and Singeli library)"âˆ¾Ëœâˆ¾â¥Š(GetÂ¨Â¯1â†“ğ•©)âˆ¾Ë˜<", "}
    Errâˆ˜((1<â‰ )â—¶""â€¿Reportâˆ˜searchâŠ¸(âˆ¾Ëœ)âŒ¾âŠ‘)âŸ(fâ‰¡@) "File not found"â€¿ğ•¨
    log âˆ¾â†© <f
    opâ†path â‹„ aâ†Load f â‹„ pathâ†©op â‹„ a
  }
  Build â‡ { logâ†©âŸ¨âŸ© â‹„ Load ğ•© }
  WriteDeps â‡ { @â‰¢ğ•© ? ğ•© â€¢file.Lines log ; @ }
}

ast â† {
  Show â‡ {â€¢Out âˆ¾âˆ¾âŸœlfÂ¨ ğ•©.Disp @}
  baseScope â† builtins.names scopes.New scopes.Init@
  baseEnv   â† builtins.values env.Fixed @
  Build â‡ Parseâˆ˜Tokenize
  Compile â‡ {
    t â† files.Build ğ•©
    t.Oper operator.NewScope operator.nilScope
    files.WriteDeps ğ•¨
    t.Scope scopes._run sc â† scopes.New baseScope
    t.Eval program._with (sc.Names@) env.New baseEnv
  }
  _runIfCond â‡ { # For top-level if condition
    ğ•©.Scope scopes._run baseScope
    eâ†@ â‹„ {eâ†©ğ•©}âˆ˜(ğ•©âŠ¸ğ”½) program._with baseEnv â‹„ e
  }
}

(âˆ¾âˆ¾âŸœlfÂ¨) ast.Compile
