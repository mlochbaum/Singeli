tabâ€¿lfâ†@+9â€¿10

dig â† '0'+â†•10
alphâ† â¥Š"aA"+âŒœâ†•26
wc  â† digâˆ¾alphâˆ¾"._"      # Word characters
oc  â† "!$%&*+-/<=>?\^|~" # Operator characters that can stick together

# Source to list of token strings
Tokenizeâ†{
  # Resolve comments and strings
  sâ€¿dâ€¿câ€¿nâ†ğ•©âŠ¸=Â¨"'""#"âˆ¾lfâ‹„sdâ†/Â¨sâ€¿d
  gâ†â‹qâ†(Â¯1â†“Â¨sd)âˆ¾âŠ¸âˆ¾/c â‹„qâ†©gâŠq                 # Open indices
  eâ† gâŠ( 1â†“Â¨sd)âˆ¾âŠ¸âˆ¾-âŸœÂ»âˆ˜âŠâŸœ(0âˆ¾+`c)âŠ¸//nâˆ¾1       # Matching close indices
  Seâ†{(âŠËœğ•¨)Se 1Â¨âŒ¾((ğ•©/ğ•¨)âŠ¸âŠ)ğ•©}âŸ(0=Â¯1âŠ‘âŠ¢)       # Mark reachable openings
  aâ€¿bâ†((â‰ ğ•©)â†‘Â·/â¼((â‰ â†‘âˆ¾âŸœâ‰ Se 1âˆ¾0Â¨)qâ‹e)âŠ¸/)Â¨qâ€¿e   # Open/close masks
  kâ†Â»â‰ `abâ†aâˆ¨b                               # Token continuation mask
  {âŸ¨âŠ‘/ğ•©,"Unclosed quote"âŸ©!0}âŸ(âˆ¨Â´)(sâˆ¨d)>kâˆ¨a
  ignâ†(ğ•©âˆŠ" "âˆ¾tab)âˆ¨â‰ `abâˆ§câˆ¨n                  # Ignored characters
  # Other stuff
  kâˆ¨â†©âˆ¨Â´(Â»âŠ¸âˆ§k<ğ•©âŠ¸âˆŠ)Â¨wcâ€¿oc                     # Group names, numbers, and ops
  tsâ†Â¬kâˆ¨ign                                 # Token start mask
  âŸ¨ğ•©âŠ”Ëœ1-ËœignÂ¬âŠ¸Ã—+`ts, /tsâŸ©
}

MakeStack â† {ğ•¤
  stâ†@ â‹„ dâ†0
  Pushâ‡{   stâ†©ğ•©â€¿st â‹„ d+â†©1}
  Pop â‡{ğ•¤â‹„ râ€¿sâ†st â‹„ stâ†©s â‹„ d-â†©1 â‹„ r}
  Arr â‡{ğ•¤â‹„ âŠ‘Â¨ âŒ½ 1âŠ¸âŠ‘âŸ(â†•d) st}
  _while_â‡{Pop âŠ¢ ğ”½ âŠ£ Â·Pushğ•˜Ë™}
}

Parse â† {
  # Three kinds of token tests, distinguished by depth.
  Is â† â‰¡âˆ˜âŠ¢â—¶âŸ¨
    {ğ•ğ•¨}   # 0 Function to apply
    â‰¡      # 1 Token
    âŠ‘<âŠ¸âˆŠ   # 2 List of tokens
  âŸ©
  sep â† âŸ¨";", â¥ŠlfâŸ©

  ! (Â¯1âŠ‘ğ•©) Is sep

  Err â† {â€¢â†>DumpStack@ â‹„ ğ•¨!ğ•©}
  MakeStream â† {
    lenâ†â‰ srcâ†ğ•© â‹„ iâ†0
    Pos  â‡ {ğ•¤â‹„i}
    Inc  â† {ğ•¤â‹„i+â†©1}
    Rem  â‡ {ğ•¤â‹„(i+1)<len}
    Peek â‡ {ğ•¤â‹„iâŠ‘src}
    Next â‡ PeekâŠ¸Is
    Get  â‡ Inc âŠ¢ PeekâŠ¸(âŠ£âŠ£â‰â—‹<ErrâŸ(Â¬âŠ¢)Is)
    Try  â‡ 1âˆ˜IncâŸâŠ¢âˆ˜Next
  }
  âŸ¨Next,Get,Peek,Try,Rem,PosâŸ© â† MakeStream ğ•©

  # Node creation and error tracking
  c â† nodes
  âŸ¨_whileParse_â‡_while_, DumpStackâ‡ArrâŸ© â† MakeStack@
  _node_ â† {âŸ¨ğ•—, ğ”¾_whileParse_âŸ¨ğ•—,Pos@âŸ© ğ•©âŸ©}

  When  â† {Testâ€¿Cont:       ( â¥Šâˆ˜< Cont)âŸTest   âŸ¨âŸ©  }
  While â† {Testâ€¿Contâ€¿init: {(ğ•Šâˆ¾âŸœ<âŸœCont)âŸTestğ•©} ContÂ¨â†•init}
  _seq â† {â‰¡Â¨âŠ¸((â‰ âŸœ1âˆ§(<sep)â‰¢Â¨âŠ¢)/>âŸœ0â—¶{ğ•@}â€¿GetÂ¨) ğ”½}

  Name â† Get (âŠ‘alphâˆŠËœâŠ)Ë™
  Word â† Get (âŠ‘(wcâˆ¾oc)âˆŠËœâŠ)Ë™

  AddParams â† {ğ•Šâˆ˜(c.run  _node_ (<âˆ¾Params))âŸ(Next"{") ğ•©}
  AddArgs   â† {  (c.call _node_ (<âˆ¾Args  ))âŸ(Next"(") ğ•©}
  Expr0 â† {ğ•¤
    Vec â† c.run _node_ (âŸ¨MakeVecËœâŸ© âˆ¾ "["â€¿Exprâ€¿"]"â€¿Expr0 _seq)
    Par â† âŠ‘ "("â€¿Exprâ€¿")" _seq
    Â¬âˆ˜IsâŸœ"["â—¶âŸ¨Vec, Â¬âˆ˜IsâŸœ"("â—¶âŸ¨Par,WordâŸ©âŸ© Peek@
  }
  Callable â† AddParamsâˆ˜Expr0
  Expr â† c.phrase _node_ {ğ•¤
    While âŸ¨Â¬Nextâˆ˜(sepâˆ¾â¥ŠÂ¨",:=)}"), AddArgsâˆ˜Callable, 0âŸ©
  }

  Param â† c.param _node_ {ğ•¤
    n â† Name@
    e â† When âŸ¨Try"==", ExprâŸ©
    nâ€¿e
  }
  Params â† {ğ•¤
    Get "{"
    a â† While âŸ¨Tryâˆ˜",", Param, 1âŸ©
    c â† While âŸ¨Tryâˆ˜"&", Expr, 0âŸ©
    Get "}"
    aâ€¿c
  }

  Args â† {ğ•¤
    Get "("
    a â† While âŸ¨Tryâˆ˜",", Expr, 1âŸ©
    Get ")"
    a
  }

  Statement â† {
  "if":     c.if     _node_ ("if"â€¿"("â€¿Exprâ€¿")"â€¿Statementâ€¿(Whenâˆ˜âŸ¨Nextâˆ˜"else",StatementâŸ©)_seq)@ ;
  "while":  c.while  _node_ ("while"â€¿"("â€¿Exprâ€¿")"â€¿Statement _seq)@ ;
  "do":     c.do     _node_ ("do"â€¿Statementâ€¿"while"â€¿"("â€¿Exprâ€¿")"â€¿sep _seq)@ ;
  # TODO: make most of the for definition conditional
  "@":      c.for    _node_ ("@"â€¿Callableâ€¿"("â€¿(Whileâˆ˜âŸ¨Tryâˆ˜",", Name, 1âŸ©)â€¿"over"â€¿Nameâ€¿"from"â€¿Exprâ€¿"to"â€¿Exprâ€¿")"â€¿Statement _seq)@ ;
  "return": c.return _node_ ("return"â€¿Expr _seq)@ ;
  "{":      Body@ ;
  ğ•©:
    n â† Expr@
    k â† Try ":"
    e â† Try "="
    t â† When âŸ¨k>e, {eâ†©Try"="â‹„ğ•©}âˆ˜ExprâŸ©
    c.decl _node_ {âŸ¨ğ•©,t,Expr@âŸ©}âŸe n
  }âˆ˜Peek

  Seps â† {Tryâˆ˜sepâ—¶@â€¿ğ•Šğ•©}
  Body â† {ğ•¤
    Get "{"
    While âŸ¨Â¬Tryâˆ˜"}", Statementâˆ˜Seps, 0âŸ©
  }
  # ğ•© indicates if preceding token was =
  Result â† c.body _node_ (Nextâˆ˜"{"â—¶âŸ¨Exprâ€¿sep _seq !, BodyâŸ©)

  FunDecl â† c.funDecl _node_ {ğ•¤
    n â† Name@
    p â† When âŸ¨Next"{", c.paramList _node_ ParamsâŸ©
    Get "("
    Arg â† c.arg _node_ (Nameâ€¿":"â€¿Expr _seq)
    a â† While âŸ¨Tryâˆ˜",", Arg, 1âŸ©
    Get ")"
    r â† When âŸ¨Try":", ExprâŸ©
    b â† Result Try"="
    âŸ¨n,p,a,r,bâŸ©
  }

  Define â† c.define _node_ ("def"â€¿Exprâ€¿"="â€¿(Resultâˆ˜1) _seq)

  Symb â† '''=âŠ‘
  Export â† c.export _node_ ((Get symbË™)â€¿"="â€¿Callableâ€¿sep _seq)

  Program â† c.program _node_ {ğ•¤
    Line â† Â¬âˆ˜IsâŸœ"def"â—¶âŸ¨Define, Symbâ—¶FunDeclâ€¿ExportâŸ©âˆ˜Peek
    While âŸ¨Rem, Lineâˆ˜Seps, 0âŸ©
  }

  Program @
}

nodes â† {
  Node â† {
    nâ†âŠ‘ğ•© â‹„ dâ†0âŸ(âŸ¨3âŸ©âŠ¸â‰¡)1âŸ(âŸ¨2âŸ©âŠ¸â‰¡)1â†“ğ•©
    {
      (<n) âˆ¾ "  "âŠ¸âˆ¾Â¨âˆ¾ dâŠ£â—¶âŸ¨â‰â—‹<âŠ¢,RunNode,âˆ¾RunNodeÂ¨âŸ©Â¨ğ•©
    }
  }
  run      â‡ Node "run"      â€¿0â€¿2â€¿2     # name params conds
  call     â‡ Node "call"     â€¿0â€¿2       # name args
  phrase   â‡ Node "phrase"   â€¿3         # things
  body     â‡ Node "body"     â€¿2         # statements
  funDecl  â‡ Node "funDecl"  â€¿0â€¿2â€¿2â€¿2â€¿1 # name params args type result
  arg      â‡ Node "arg"      â€¿0â€¿1       # name type
  decl     â‡ Node "decl"     â€¿1â€¿2â€¿1     # name type value
  define   â‡ Node "define"   â€¿1â€¿1       # target value
  export   â‡ Node "export"   â€¿0â€¿1       # name value
  program  â‡ Node "program"  â€¿2         # lines
  param    â‡ Node "param"    â€¿0â€¿2       # name equals
  paramListâ‡ Node "paramList"â€¿2â€¿2       # params conds
  if       â‡ Node "if"       â€¿1â€¿1â€¿2     # cond then else
  while    â‡ Node "while"    â€¿1â€¿1       # cond stmt
  do       â‡ Node "do"       â€¿1â€¿1       # stmt cond
  return   â‡ Node "return"   â€¿1         # value
}

RunNode â† {ğ•ğ•©}Â´âŠ¢

MakeVec â† !

â€¢Out âˆ¾âˆ¾âŸœlfÂ¨ RunNode Parse âŠ‘Tokenize 1â†“"
add{T}(a:*T, b:*T, r:*T, l:u64) : void = {
  i := 0u64;
  i = i+1;
}
def a=1+2
'abc'=fn{x,y}
"
