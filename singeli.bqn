tabâ€¿lfâ†@+9â€¿10

dig â† '0'+â†•10
alphâ† "_"âˆ¾â¥Š"aA"+âŒœâ†•26
wc  â† digâˆ¾alphâˆ¾"."       # Word characters
oc  â† "!$%&*+-/<=>?\^|~" # Operator characters that can stick together

# Source to list of token strings
Tokenizeâ†{
  ğ•©âˆ¾â†©lf(â‰ â¥ŠâŠ£)Â¯1â†‘ğ•©                            # Trailing newline
  # Resolve comments and strings
  sâ€¿dâ€¿câ€¿nâ†ğ•©âŠ¸=Â¨"'""#"âˆ¾lfâ‹„sdâ†/Â¨sâ€¿d
  gâ†â‹qâ†(Â¯1â†“Â¨sd)âˆ¾âŠ¸âˆ¾/c â‹„qâ†©gâŠq                 # Open indices
  eâ† gâŠ( 1â†“Â¨sd)âˆ¾âŠ¸âˆ¾-âŸœÂ»âˆ˜âŠâŸœ(0âˆ¾+`c)âŠ¸//nâˆ¾1       # Matching close indices
  Seâ†{(âŠËœğ•¨)Se 1Â¨âŒ¾((ğ•©/ğ•¨)âŠ¸âŠ)ğ•©}âŸ(0=Â¯1âŠ‘âŠ¢)       # Mark reachable openings
  aâ€¿bâ†((â‰ ğ•©)â†‘Â·/â¼((â‰ â†‘âˆ¾âŸœâ‰ Se 1âˆ¾0Â¨)qâ‹e)âŠ¸/)Â¨qâ€¿e   # Open/close masks
  kâ†Â»â‰ `abâ†aâˆ¨b                               # Token continuation mask
  {âŸ¨âŠ‘/ğ•©,"Unclosed quote"âŸ©!0}âŸ(âˆ¨Â´)(sâˆ¨d)>kâˆ¨a
  ignâ†(ğ•©âˆŠ" "âˆ¾tab)âˆ¨â‰ `abâˆ§câˆ¨n                  # Ignored characters
  # Other stuff
  kâˆ¨â†©âˆ¨Â´(Â»âŠ¸âˆ§k<ğ•©âŠ¸âˆŠ)Â¨wcâ€¿oc                     # Group names, numbers, and ops
  btâ†(âŒˆ`â†•âˆ˜â‰ Ã—Â¬)k â‹„ xdâ†ğ•©âˆŠdig
  kâˆ¨â†©Â»âŠ¸âˆ¨(Â»(btâŠxd)âˆ§ğ•©='e')âˆ§(ğ•©='-')âˆ§Â«xd        # Negative exponents 12e-3
  tsâ†nâˆ¨Â¬kâˆ¨ign                               # Token start mask
  lcâ†(1+/ğ•©=lf){(âŠ¢â‹ˆÂ¨ğ•©-âŠâŸœ(0âˆ¾ğ•¨))ğ•¨â‹ğ•©}/ts        # Line/column numbers
  âŸ¨ğ•©âŠ”Ëœ1-Ëœ(ign>â‰ `abâˆ§sâˆ¨d)Â¬âŠ¸Ã—+`ts, Source ğ•©â€¿lcâŸ©
}

# Position handler for error reporting
Source â† {
  srcâ€¿lcâ†ğ•©
  { pos ğ•Š disp:
    râ€¿câ†<Ë˜â‰>posâŠlc
    â€¢Out src/Ëœ(src=lf)(âŠ£<+`âŠ¸=)eâ†Â¯1âŠ‘r
    Tr â† {
      e â† (+`(ğ•©â‰¤Â¯1Â»ğ•¨â‰ âŠ¸+Â¨ğ•©))âŠ”ğ•©â‹ˆÂ¨ğ•¨
      l â† "^"âŒ¾(1âŠ‘Â¯1âŠ‘âŠ‘) âŒ½ "|"âŒ¾(1âŠ¸âŠ‘)Â¨âŠ¸âˆ¾` (1+â‰ e)â†‘e
      {âˆ¾((-âŸœÂ»ğ•¨)âˆ¾â‰ Â¯1âŠ‘ğ•©)â†‘Â¨""<âŠ¸âˆ¾ğ•©}Ëâˆ˜â‰âˆ˜>Â¨ l
    }
    â€¢OutÂ¨ disp Trâ—‹((r=e)âŠ¸/) c
  }
}
DispSource â† {ğ•ğ•©}Â´
Err â† { (ğ•©â‰ âŠ¸â¥Šâ€¢Outâ€¿DispSource) {ğ•ğ•©}Â¨ ğ•© â‹„ â€¢Exit 1 }

numbers â† {knameâ‡"number"
  f â† â€¢Import "float2.bqn"
  NN â† 1â‰ â€¢Type  # Not native number
  Is â† knameâ‰¡{Kindğ•©}
  Wrap â† {kindâ‡knameâ‹„valueâ‡ğ•©â‹„Matchesâ‡Matchâ‹„Showsâ‡FmtLargeâˆ˜ğ•©}
  Unwrap â† {6=â€¢Typeğ•©?knameâ‰¡ğ•©.kind?ğ•©.value; !"Expected number"}
  Promote â† NNâ—¶f.Toâ€¿Unwrap
  From â‡ f.Fromâˆ˜UnwrapâŸNN
  GetBool â‡ {"Boolean expected"!âŠ‘ğ•©âˆŠ0â€¿1â‹„ğ•©}âˆ˜From
  Match â‡ âˆ§â—‹Isâ—¶âŸ¨0,â‰¡â—‹PromoteâŸ©

  _be â† {ğ•—âŠ¸Ã—âŠ¸+ËœÂ´âŒ½âˆ˜âŠ¢}
  Nat â† (10 _be âŠ£ "Ill-formed number"!Â·âˆ§Â´0âŠ¸â‰¤âˆ§â‰¤âŸœ9) -âŸœ'0'
  LC â† +âŸœ(32Ã—1="A["âŠ¸â‹) '_'âŠ¸â‰ âŠ¸/  # Lowercase, underscores removed
  da â† digâˆ¾'a'+â†•26
  Read â‡ {
    (â‰ ğ•©)>sâ†âŒŠÂ´ğ•©âŠ"bx" ? # Base n with 0x9abc or 31bNUMBER
      b â† ('b'=sâŠ‘ğ•©)â—¶âŸ¨16âŠ£Â·!"0"âŠ¸â‰¡,NatâŸ© sâ†‘ğ•©
      "Invalid base" ! bâ‰¤â‰ da
      d â† (bâ†‘da) (â‰ âˆ˜âŠ£(âŠ¢âŠ£"Invalid digits"!âˆ§Â´âˆ˜>)âŠ) (1+s)â†“ğ•©
      Eâ†b _be â‹„ EEâ†{hâ€¿lâ†f.Toâˆ˜EÂ¨ğ•¨-âŠ¸(â†“â‹ˆâ†‘)ğ•©â‹„Wrap l f.Add (f.To bâ‹†ğ•¨)f.Mul h}
      (âŒŠ53Ã·2â‹†â¼b) <âŸœâ‰ â—¶Eâ€¿EE d
    ;
      _n â† {('-'=âŠ‘)â—¶âŸ¨ğ”½, -âˆ˜ğ”½ 1âŠ¸â†“âŸ©}
      Pos â† âŠâŸœ"."âŠ¸(Natâˆ˜â†‘ + Â·(0<â‰ )â—¶âŸ¨0,NatÃ·10â‹†â‰ âŸ©+âŸœ1âŠ¸â†“)
      âŠâŸœ"e"âŠ¸(Pos _nâˆ˜â†‘ Ã— <âŸœâ‰ â—¶âŸ¨1,10â‹†Â·Nat _n+âŸœ1âŠ¸â†“âŸ©) ğ•©
  }âŸœLCâŠ{ErrâŸ¨â€¢CurrentError@,ğ•¨âŸ©}

  InRange â† {1=âŠ‘0â‹Ëœ-ËœÂ´âŸœ(âŒ½ğ•¨)Â¨ğ•©}
  FmtLarge â† {
    âŒŠâŠ¸â‰¡ğ•© ? (f.Abs ğ•©) InRange 2â‹†53â€¿64 ? "0x"âˆ¾daâŠËœâŒ½ 16â€¿16 f._repr ğ•© ;
    FmtNum f.From ğ•©
  }

  Cast â‡ {'f'â€¿lğ•Šn:1; qâ€¿lğ•Šn: # 1 if valid; error otherwise
    n NNâ—¶â‹ˆâ€¿Unwrapâ†©
    "Cannot cast float to integer"!âŒŠâŠ¸â‰¡n
    "Constant doesn't fit"!n InRange -âŸœ(1âŠ¸âŠ‘Ã·2Ë™)âŸ(q='i') âŸ¨0,2â‹†lâŸ©
  }
  builtins â‡ {
    Wâ†Wrap â‹„ Pâ†Promote â‹„ Bâ†GetBool
    Eâ†f.To 2â‹†From
    prâ€¿val â† <Ë˜â‰âˆ˜â€¿2â¥Š âŸ¨
      {ğ•âŠ‘}     ,âŸ¨"neg",NNâ—¶âŸ¨-,Wâˆ˜f.Negâ—‹UnwrapâŸ©âŸ©â€¿âŸ¨"not",Â¬âˆ˜BâŸ©
      {Wâˆ˜ğ•â—‹P}  ,âŸ¨"add"â€¿f.Add, "sub"â€¿f.Sub, "mul"â€¿f.Mul, "div"â€¿f.DivâŸ©
      {W PâŠ¸ğ•âŸœE},âŸ¨"shl", f.MulâŸ©â€¿âŸ¨"shr", f.Floor f.DivâŸ©
      {ğ•â—‹B}    ,âŸ¨ "and"â€¿âˆ§, "or"â€¿âˆ¨, "xor"â€¿â‰  âŸ©
    âŸ©
    â‰>âˆ¾ ({{ğ•Â´}âˆ˜ğ•}Â¨âŒ¾(1âŠ¸â†“) {ğ•âš‡0}Â¨ pr) {âŸ¨"__"âŠ¸âˆ¾,ğ•âŸ©âŠ¸({ğ•ğ•©}Â¨)Â¨ğ•©}Â¨ val
  }
  _cmp â‡ {(f.Cmp ğ”½ 0Ë™)â—‹Promote}
}

architectures â† {
  # ğ•© is a list of extension dependency chains.
  New â‡ {
    TSort â† {{ğ•ŠâŸ(ğ•©<â—‹â‰ âŠ¢)âŸœ(ğ•©âˆ¾Â·/ğ•¨âŠ¸<)ğ•¨âˆ¨âˆ§Â´âˆ˜âŠâŸœğ•¨Â¨p}âŸœ/0Â¨pâ†ğ•©} # Topological sort
    u â† â·âˆ¾ğ•©
    u âŠËœâ†© TSort âˆ¾Â¨ (âŠ¢âŠ”â—‹âˆ¾(Â¯1â†“â†‘)Â¨) (<u)âŠÂ¨ğ•©
    m â† âˆ¨Ëâˆ˜âˆ§â‰1â€¿âˆËœâŸ(âŒˆ2â‹†â¼â‰ ) (â‰¥âŒœËœâ†•âˆ˜â‰ )âŠ¸Ã—âˆ¨Â´Ã—âŒœËœÂ¨(<u)âˆŠÂ¨ğ•©    # Dependency matrix
    Id â† uâŠ¸âŠ
    Set â‡ {
      mask â‡ ({ğ•©.mask}ğ•¨) âˆ¨Ë (Id ğ•©) âŠ m
      Has â‡ mask âŠ‘Ëœ IdâŒ¾<
    }
  }
  x86 â‡ New ((âŠ¢-Ëœ+`Ã—Â¬)' 'âŠ¸=)âŠ¸âŠ”Â¨ â€¢file.Lines "data/x86_ext.txt"
}

MakeStack â† {ğ•¤
  stâ†@ â‹„ dâ†0
  Pushâ‡{   stâ†©ğ•©â€¿st â‹„ d+â†©1}
  Pop â‡{ğ•¤â‹„ râ€¿sâ†st â‹„ stâ†©s â‹„ d-â†©1 â‹„ r}
  Arr â‡{ğ•¤â‹„ âŠ‘Â¨ âŒ½ 1âŠ¸âŠ‘âŸ(â†•d) st}
  _while_â‡{Pop âŠ¢ ğ”½ âŠ£ Â·Pushğ•˜Ë™}
}

MakeStream â† {
  lenâ†â‰ srcâ†ğ•© â‹„ iâ†0
  Pos  â‡ {ğ•¤â‹„i}
  Inc  â† {ğ•¤â‹„i+â†©1}
  Rem  â‡ {ğ•¤â‹„i<len}
  Peek â‡ {ğ•¤â‹„iâŠ‘src}
  Next â‡ Inc âŠ¢ Peek
}

Parse â† {ğ•Š tokensâ€¿ShowTrace:
  # Three kinds of token tests, distinguished by depth.
  Is â† â‰¡âˆ˜âŠ¢â—¶âŸ¨
    {ğ•ğ•¨}   # 0 Function to apply
    â‰¡      # 1 Token
    âŠ‘<âŠ¸âˆŠ   # 2 List of tokens
  âŸ©
  sep â† âŸ¨";", â¥ŠlfâŸ©

  ! (Â¯1âŠ‘tokens) Is sep

  Asrt â† {ğ•¨ğ•Š1:@;
    lâ†{ğ•¨âŠ¸âŠâŠğ•©Ë™}Ëâ‰âˆ˜â€¿2â¥ŠâŸ¨c.arg,"arg",c.assign,"assign",c.body,"body",c.call,"call",c.define,"define",c.export,"export",c.for,"for",c.function,"function",c.if,"if",c.lambda,"lambda",c.opdef,"opdef",c.phrase,"phrase",c.run,"run",c.while,"while",c.word,"word"âŸ©
    ShowTraceâŸœLÂ´ <Ë˜â‰>DumpStack@
    â€¢Out ""
    F â† (â¥Šlf)âŠ¸â‰¡â—¶â€¢Reprâ€¿"end of line"
    â€¢Out {âˆ¾"Expected "â€¿ğ•¨â€¿" but saw "â€¿ğ•©}âŸœFÂ´âŸ(1<â‰¡) ğ•¨
    â€¢Exit 1
  }
  MakeTokStream â† {
    âŸ¨Incâ‡NextâŸ©â†Posâ€¿Remâ€¿Peekâ‡MakeStream ğ•©
    Peek â†© Peek âŠ£ "File ended unexpectedly" Asrt Rem
    Next â‡ PeekâŠ¸Is
    Get  â‡ Inc âŠ¢ {ğ•© (âŠ¢ âŠ£ (ğ•¨â€¢ReprâŠ˜âŠ£âŠ¢)âŠ¸â‹ˆ Asrt IsËœ) Peek@}
    Try  â‡ 1âˆ˜IncâŸâŠ¢âˆ˜Next
  }
  âŸ¨Next,Get,Peek,Try,Rem,PosâŸ© â† MakeTokStream tokens

  # Node creation and error tracking
  c â† nodes
  âŸ¨_whileParse_â‡_while_, DumpStackâ‡ArrâŸ© â† MakeStack@
  _node_ â† {pâ†Pos@ â‹„ (ShowTraceâ—‹â‹ˆâŸœ""âŠ¢)â€¿p ğ”½ ğ”¾_whileParse_âŸ¨p,ğ•—âŸ© ğ•©}

  When  â† {Testâ€¿Cont:       ( â¥Šâˆ˜< Cont)âŸTest   âŸ¨âŸ©  }
  While â† {Testâ€¿Contâ€¿init: {(ğ•Šâˆ¾âŸœ<âŸœCont)âŸTestğ•©} ContÂ¨â†•init}
  _seq â† {â‰¡Â¨âŠ¸((â‰ âŸœ1âˆ§(<sep)â‰¢Â¨âŠ¢)/>âŸœ0â—¶{ğ•@}â€¿(GetâŠ¢)Â¨) ğ”½}

  _begin_ â† {ğ•˜ Get (âŠ‘âˆ˜ğ”½âŠ‘)Ë™}
  _ifASCII â† {(@+128)âŠ¸â‰¤â—¶ğ”½â€¿1}
  Name â† âˆŠâŸœalph _begin_ "name"
  Oper â† âˆŠâŸœoc _ifASCII _begin_ "operator"
  Word â† c.word _node_ (âˆŠâŸœ(wcâˆ¾oc)_ifASCII _begin_ "word")
  Symbol â† c.symbol _node_ ('''âŠ¸=_begin_"symbol")

  AddParams â† {ğ•Šâˆ˜(c.run  _node_ (âŠ¢â‹ˆ"{"â€¿"}"_args))âŸ(Next"{") ğ•©}
  AddArgs   â† {  (c.call _node_ (âŠ¢â‹ˆ"("â€¿")"_args))âŸ(Next"(") ğ•©}
  Expr0 â† {ğ•¤
    Vec â† c.run _node_ ((c.Word"__vec") â‹ˆ "["â€¿Exprâ€¿"]"â€¿Expr0 _seq)
    Par â† âŠ‘ "("â€¿Stmtâ€¿")" _seq
    AResâ† c.body _node_ (Nextâˆ˜"{"â—¶âŸ¨â‹ˆExpr, BodyâŸ©)
    Anonâ† c.lambda _node_ (Paramsâ€¿"=>"â€¿ARes _seq)
    (âŠ‘"[({'"âŠâŠ)â—¶Vecâ€¿Parâ€¿Anonâ€¿Symbolâ€¿Word Peek@
  }
  Callable â† AddParamsâˆ˜Expr0
  _exprEnd â† {endTok _ğ•£:
    end â† endTokâˆ¾sepâˆ¾â¥ŠÂ¨",:=)}]"
    Call â† { Opâ†âˆ¨Â´(ocâˆ¾"[")=âŠ â‹„ câ†Â¬Next op â‹„ AddArgsâŸc Callableğ•© }
    c.phrase _node_ (Whileâˆ˜âŸ¨Â¬Nextâˆ˜end, Call, 0âŸ©)
  }
  Expr â† âŸ¨âŸ©_exprEnd

  _args â† {ğ•— _argsFn_ Expr}
  _argsFn_ â† {ğ•¤
    Get âŠ‘ğ•—
    Try 1âŠ‘ğ•— ? âŸ¨âŸ© ;
    a â† While âŸ¨Tryâˆ˜",", ğ”¾, 1âŸ©
    Get 1âŠ‘ğ•—
    a
  }

  StSub â† {
  "def":    Define@ ;
  "if":     c.if     _node_ ("if"â€¿"("â€¿Exprâ€¿")"â€¿Blockâ€¿(Whenâˆ˜âŸ¨Tryâˆ˜"else"âˆ˜Seps,BlockâŸ©)_seq)@ ;
  "while":  c.while  _node_ (1 âˆ¾   "while"â€¿"("â€¿Exprâ€¿")"â€¿Block _seq)@ ;
  "do":     c.while  _node_ (0 âˆ¾âŸœâŒ½ "do"â€¿Blockâ€¿"while"â€¿"("â€¿Exprâ€¿")"â€¿sep _seq)@ ;
  "@":      For@ ;
  ğ•©:
    n â† Expr@
    d â† Try ":"
    e â† Try "="
    t â† When âŸ¨d>e, {eâ†©Try"="â‹„ğ•©}âˆ˜ExprâŸ©
    c.assign _node_ {âŸ¨ğ•©,d,t,Expr@âŸ©}âŸe n
  }
  Stmt â† StSub Peek

  Seps â† {Tryâˆ˜sepâ—¶@â€¿ğ•ŠâŸRemğ•©}
  Body â† {ğ•¤
    Get "{"
    b â† While âŸ¨Â¬Tryâˆ˜"}"âˆ˜Seps, Stmt, 0âŸ©
    "Empty body" Asrt 0<â‰ b
    b
  }
  Block â† "{"âŠ¸â‰¡â—¶âŸ¨StSub, c.body _node_ BodyâŸ© Peek

  For â† c.for _node_ {ğ•¤
    OAâ† "@for: multiple variables must use ""over"""âŠ¸Asrt
    TAâ† "@for: ""from"" missing ""to"""âŠ¸Asrt
    NAâ† "@for: loop variable must be a name"âŠ¸Asrt
    Expr â† "over"â€¿"from"â€¿"to"_exprEnd # Shadow
    Get "@"
    f â† Callable@
    Get "("
    toâ† Expr@ â‹„ NEâ†{ğ•¤â‹„ NA@â‰¢nâ†c.PhraseTryName to â‹„ toâ†©Expr@ â‹„ n}
    peâ† While âŸ¨Tryâˆ˜",", Name, 0âŸ©
    psâ† pe âŠ¢â—¶{OA 0=â‰ ğ•¨â‹„âŸ¨âŸ©}â€¿{(<NE@)âˆ¾ğ•¨} Try"over" # Pointers
    frâ† When âŸ¨Try"from", ExprâŸ©                 # Start index
    i â† âŠ¢â—¶{ğ•¤â‹„TA 0=â‰ frâ‹„âŸ¨âŸ©}â€¿{ğ•¤â‹„âŸ¨NE@âŸ©} Try"to"    # Index variable
    Get ")"
    b â† Block@
    âŸ¨f,ps,i,fr,to,bâŸ©
  }

  # ğ•© indicates if preceding token was =
  Result â† c.body _node_ (("{"â€¿"@"âŠ¸âŠâŒ¾<Peek)â—¶âŸ¨
    Body
    â‹ˆFor
    Exprâ€¿sep _seq "Missing = before body?"AsrtâŠ¢
  âŸ©)

  Params â† {ğ•¤
    ExprA â† âŸ¨"&"âŸ©_exprEnd
    Param â† {ğ•¤
      n â† Name@
      e â† When âŸ¨     Try "==", ExprAâŸ©
      t â† When âŸ¨(â‰ e)â—¶Tryâ€¿0":", ExprAâŸ©
      nâ€¿eâ€¿t
    }
    Get "{"
    a â† While âŸ¨Tryâˆ˜",", Param, 1âŸ©
    c â† While âŸ¨Tryâˆ˜"&", ExprA, 0âŸ©
    Get "}"
    aâ€¿c
  }
  _withParams â† {ğ•¤
    (Next"{")â—¶âŸ¨ğ”½, c.lambda _node_ (Paramsâ€¿ğ•Š _seq)âŸ©@
  }

  Function â† c.function _node_ {ğ•¤
    Arg â† c.arg _node_ (Nameâ€¿":"â€¿Expr _seq)
    a â† "("â€¿")" _argsFn_ Arg @
    r â† When âŸ¨Try":", ExprâŸ©
    b â† Result Try"="
    âŸ¨a,r,bâŸ©
  } _withParams
  Const â† {ğ•¤
    t â† When âŸ¨Try":", ExprâŸ©
    Get "="
    c.run _node_ ((c.Word"cast") â‹ˆ tâˆ¾<)âŸ(0<â‰ t) Expr@
  }
  FunConst â† (Nextâˆ˜"("â€¿"{"â—¶Constâ€¿Function)
  Generator â† {ğ•¤â‹„ Get"=" â‹„ Result 1} _withParams
  DefFun â† c.define _node_ (      Nameâ€¿FunConst  _seq)
  Define â† c.define _node_ ("def"â€¿Nameâ€¿Generator _seq)

  Export â† c.export _node_ ((Whileâˆ˜âŸ¨Tryâˆ˜",",Symbol,1âŸ©)â€¿"="â€¿Callableâ€¿sep _seq)

  OpType â† {ğ•¤
    pre â† (âŠ‘â‰¢Get) "prefix"â€¿"infix"
    preâ—¶âŸ¨'p', Nextâ—¶âŸ¨'n', âŠ‘âˆ˜Getâˆ˜1âŸ©âŸ© "none"â€¿"left"â€¿"right"
  }
  OpDef â† c.opDef _node_ ("oper"â€¿OpTypeâ€¿Operâ€¿Nameâ€¿Word _seq)

  Include â† c.include _node_ ("include"â€¿Symbol _seq)

  Program â† c.body _node_ {ğ•¤
    Line â† "def"â€¿"oper"â€¿"include"âŠ¸âŠâŒ¾<â—¶âŸ¨
      Define, OpDef, Include, ('''=âŠ‘)â—¶DefFunâ€¿Export
    âŸ©âˆ˜Peek
    Seps@
    While âŸ¨Rem, SepsâŠ¢Line, 0âŸ©
  }

  Program @
}

operator â† {
  Parse â‡ {ops ğ•Š val:
    Peekâ€¿Nextâ€¿Rem â† MakeStream ops {nullâ€¿leftâ€¿bindâ€¿Râ‡ğ•¨ â‹„ valueâ‡ğ•©}Â¨ val
    E â† {ğ•Štest: {ğ•Šâˆ˜{ğ•© LeD Next@}âŸ(Test Peek)âŸRem ğ•©} NuD Remâ—¶Misâ€¿Next@ }
    NuD â† { ğ•©.null â‰¢âŸœ@â—¶{ğ•©.value}â€¿{ğ•© Run âŸ¨ğ•©.R ğ•¨.V@, âŸ¨E ğ•¨.tâŸ©âŸ©} ğ•© }
    LeD â† { UnkâŸ(@â‰¡lâ†ğ•©.left)ğ•© â‹„ ğ•© Run âŸ¨ğ•©.R l.V@, âŸ¨ğ•¨, E l.tâŸ©âŸ© }
    Run â† {ğ•©.value.pos}âŠ¸nodes.Run
    Unk â† { Err "Unknown operator"â€¿ğ•©.value.pos }
    Mis â† {ğ•Š: Err "Missing right operand"â€¿(Â¯1âŠ‘val).pos }
    E 1
  }
  New â† {ğ•¤
    null â‡ left â‡ @
    bind â‡ Â¯âˆ
    R â‡ âŠ¢
    Op â† {ğ•Švalâ€¿pâ€¿câ€¿a:
      V â‡ nodes.Wordâˆ˜val
      T â‡ (p C {ğ•©.bind}){{âŠ£ACğ•}âŸağ•—}
    }
    AddNull â‡ {ğ•¨ğ•ŠâŸ¨value, precâŸ©: AddNullâ†©ğ•¨_dup
      null â†© Op âŸ¨value, prec, <, 0âŸ©
    }
    AddLeft â‡ {ğ•¨ğ•ŠâŸ¨value, prec, assocâŸ©: AddLeftâ†©ğ•¨_dup
      bind â†© prec
      left â†© Op âŸ¨value, prec, ("lrn"âŠ¸âŠâŒ¾<assoc)âŠ‘âŸ¨<,â‰¤,<-=âŸ©, 'n'=assocâŸ©
    }
    _dup â† { Err "Duplicate operator definition:"â€¿ğ•¨â€¿"Previously defined here:"â€¿ğ•— }
    AC â† ğ•©{ Err ("Associativity for operator "âˆ¾ğ•—âˆ¾" must be disambiguated")â€¿ğ•¨.value.pos }âŸ(0âŠ¸>)
  }
  Run â‡ {ğ•¨ğ•ŠâŸ¨op,paramsâŸ©: nullâ€¿leftâ€¿bindâ‡op â‹„ Râ‡ğ•¨ nodes.Run op.Râ‹ˆparamsË™}
  nil â‡ New @

  Lookupâ‡Addâ‡!âˆ˜0
  _with â‡ {
    nâ†âŸ¨âŸ© â‹„ oâ†âŸ¨âŸ©
    _get â† {(nâŠ¸âŠâŒ¾<ğ•©) =âŸœ(â‰ n)â—¶{ğ•¨âŠ‘o}â€¿ğ”½ ğ•©}
    Lookup â†© nil _get
    Define â† {nâˆ¾â†©<ğ•© â‹„ oâˆ¾â†©<râ†Newğ•© â‹„ r} _get
    Add â†© {ğ•¨ğ•Štypeâ€¿nameâ€¿valueâ€¿prec:
      p â† Define name
      (typeâ‰ 'p')â—¶âŸ¨ğ•¨p.AddNullâŠ¢, ğ•¨p.AddLeftâˆ¾âŸœtypeâŸ© âŸ¨value,precâŸ©
    }
    ğ•¨ğ”½ğ•©
    Lookupâ†©Addâ†©!âˆ˜0
  }
}


# Runtime
# Kinds are:
# - BQN values tuple (list), number, generator (function)
# - Classes symbols, types, registers, constants, functions, blocks
_and_ â† { ğ”½â—¶âŸ¨0,ğ”¾âŸ© }
IsNum â† 1=â€¢Type
IsInt â† IsNum _and_ (âŒŠâŠ¸=)
IsNat â† IsInt _and_ (0âŠ¸â‰¤)
IsTup â† 0=â€¢Type
FmtNum â† 'Â¯'(âŠ¢+=Ã—'-'-âŠ£)â€¢Repr

_tsel â† {â€¢Typeâˆ˜âŠ£â—¶(Â¯1((â†“Â»(6â¥ŠâŸ¨!âŸ©)Ë™)âˆ¾â†‘)ğ•—)}
Kind  â† âŸ¨"tuple","number",@,"generator",{ğ•©.kind}âŸ©_tsel
Show  â† {âŸ¨"tup{"âˆ¾"}"Â«Â·âˆ¾(","âˆ¾ğ•Š)Â¨, FmtNum, {ğ•©.Shows@}âŸ©_tsel ğ•©}
Match â† {ğ•¨ âŸ¨âˆ§Â´ğ•ŠÂ¨, numbers.Match,â‰¡,â‰¡, {ğ•¨ğ•¨.Matchesğ•©}âŸ©_tsel ğ•©}
IsTypedâ†("register"âŠ¸â‰¡âˆ¨"constant"âŠ¸â‰¡) Kind
TypeOfâ† {âŸ¨types.Tup ğ•ŠÂ¨, {ğ•©.Type@}âŸ©_tsel ğ•©}

types â† {knameâ‡"type"
  New â† {kğ•Šd:
    kindâ‡kname
    typeKindâ€¿datâ‡ğ•¨â€¿ğ•©
    Tâ†"("âˆ¾")"Â«Â·âˆ¾(","âˆ¾Show)Â¨  # Display type tuple
    Showsâ‡typeKindâ—¶âŸ¨
      "void"               # Void:                     void
      âˆ¾âŸœâ€¢ReprÂ´             # Primitive:   qualâ€¿len     u8
      {âˆ¾"["â€¿ğ•¨â€¿"]"â€¿ğ•©}â—‹ShowÂ´ # Vector:      countâ€¿t      [4]â€¦
      "*"âˆ¾Show             # Pointer:     t            *â€¦
      TâŠ¸{âˆ¾ğ•¨â€¿" -> "â€¿ğ•©}âŸœShowÂ´# Function:    âŸ¨t, qâ€¿râ€¿sâŸ©   (â€¦,â€¦,â€¦) -> â€¦
      T                    # Tuple:       qâ€¿râ€¿s        (â€¦,â€¦,â€¦)
    âŸ©âˆ˜dat
    Matchesâ‡{ğ•¨MTğ•©}
  }
  tVOIDâ€¿tPRIMâ€¿tVECâ€¿tPTRâ€¿tFUNâ€¿tTUP â† â†•6
  TypeKindâ‡{
    "typekind argument must be type"!Is ğ•©
    ğ•©.typeKindâŠ‘"void"â€¿"primitive"â€¿"vector"â€¿"pointer"â€¿"function"â€¿"tuple"
  }
  IsVoid â‡ {tVOIDâ‰¡ğ•©.typeKind}

  primTypes â‡ (tVOID New âŸ¨âŸ©)âˆ¾âˆ¾(<(tPRIM New â‹ˆ)Â¨Â´)Ë˜ âˆ˜â€¿2â¥ŠâŸ¨
    'u', 2â‹†0âˆ¾3+â†•4  # 1/8/16/32/64
    'i', 2â‹†  3+â†•4  #   8/16/32/64
    'f', 2â‹†  5+â†•2  #        32/64
  âŸ©

  Is â‡ knameâ‰¡Kind
  Vec â† {nğ•Št: "Vector size should be a constant integer"!IsNat n â‹„ !Is t â‹„ tVEC New âŸ¨n,tâŸ©}
  Ptr â† { ğ•Št: "Pointer type wasn't type"!Is t â‹„ tPTR New t}
  Tup â‡ { ğ•Št: !IsTup t â‹„ !âˆ§Â´IsÂ¨ t â‹„ tTUP New t}
  Fun â‡ tFUN New â‹ˆ

  _isQual â† {{tPRIMâ‰¡ğ•©.typeKind}â—¶âŸ¨0,ğ”½{âŠ‘ğ•©.dat}âŸ© TypeOfâŸ(Â¬Is)}

  Deref â‡ { Is ğ•© ? tPTR=ğ•©.typeKind ? ğ•©.dat ; !"Expected pointer" }

  _cases â† {
    Kindâ†{ğ•©.typeKind} â‹„ Datâ†{ğ•©.dat}
    c â† âŒŠâ€¿2â¥Šğ•—
    k â† âŠË˜c
    d â† (1âŠË˜c) âˆ¾ ((â‰ â¥Šc)â†“ğ•—)Â»âŸ¨!âˆ˜0âŸ©
    (kâŠ¸âŠâŒ¾< âŠ¢âŠ˜(â‰ â—¶âŠ¢â€¿Â¯1)â—‹Kind)â—¶({ğ•â—‹Dat}Â¨d) âŠ£ @â—‹(!Is)
  }

  Size â† âŸ¨
    tPRIM, 1âŠ¸âŠ‘
    tVEC,  Ã—âŸœ{Sizeğ•©}Â´
    tTUP,  +Â´{Sizeğ•©}Â¨
  âŸ©_cases

  VCount â† âŸ¨ tVEC,âŠ‘, 1 âŸ© _cases
  VType â† âŸ¨ tVEC,1âŠ¸âŠ‘, tPTR,âŠ¢ âŸ© _cases

  _sub â† {
    L â† Â¯1âŠ¸âŠ‘
    ğ•¨ âŸ¨
      tVEC,  =â—‹âŠ‘ _and_ (ğ•Šâ—‹L)
      tPTR,  ğ•Š
      tTUP,  =â—‹â‰  _and_ (âˆ§Â´ğ•ŠÂ¨)
      tPRIM, â‰ â—‹âŠ‘â—¶âŸ¨ğ”½â—‹L, ('f'â‰ âŠ‘âˆ˜âŠ£)_and_(<â—‹L)âŸ©
      0
    âŸ© _cases ğ•©
  }
  Subtype  â‡ â‰¤ _sub
  SSubtype â‡ < _sub
  MT â‡ Subtype âˆ§ SubtypeËœ

  Cast â‡ {
    Numâ†{tğ•Šn:
      âŸ¨ tPRIM,numbers.CastâŸœn, !"Cannot cast number to "âˆ¾Show âŸ© _cases t
      t constants.New n
    }
    Objâ†{
      "number"â‰¡ğ•©.kind ? ğ•¨ Num ğ•© ;
      "Cast failed" ! IsTypedâ—¶âŸ¨0,TypeOf MT ğ•¨Ë™âŸ© ğ•©
      ğ•©
    }
    ğ•¨ âŸ¨âŸ¨tTUP,âŠ¢âŸ©_casesâŠ¸(ğ•ŠÂ¨)Ëœ, NumËœ, ObjËœâŸ©_tselËœ ğ•©
  }

  builtins â‡ âˆ¾Ë˜â‰âˆ˜â€¿2â¥ŠâŸ¨
    âŸ¨"cast","eltype","vcount","width",          "__vec","__pnt"âŸ©
    âŸ¨ CastÂ´, VTypeâŠ‘ , VCountâŠ‘, SizeâŠ‘ ,numbers.FromâŠ¸VecÂ´,   PtrâŠ‘âŸ©
    "isfloat"â€¿"issigned"â€¿"isint"
    {ğ•©_isQualâŠ‘}Â¨âŸ¨'f'âŠ¸â‰¡ â‹„ 'i'âŠ¸â‰¡ â‹„ âŠ‘âˆ˜âˆŠâŸœ"iu"âŸ©
  âŸ©
}

registers â† {knameâ‡"register"
  New â‡ {
    kindâ‡kname â‹„ typeâ‡ğ•¨ â‹„ handleâ‡ğ•©
    showsâ‡"v"âˆ¾â€¢Reprğ•© â‹„ Matchesâ‡â‰¡
    usedâ‡0 â‹„ SetUsedâ‡{ğ•¤â‹„usedâ†©1}
    mutâ‡0  â‹„ SetMut â‡{ğ•¤â‹„mut â†©1}
  }
}
constants â† {knameâ‡"constant"
  New â‡ {
    kindâ‡kname â‹„ typeâ‡ğ•¨ â‹„ valueâ‡ğ•©
    showsâ‡âˆ¾"!:"âˆ¾âŸœShowÂ¨ğ•©â€¿ğ•¨ â‹„ Matchesâ‡â‰¡
  }
}

NewLabel  â† { showsâ‡"l"âˆ¾â€¢Reprğ•© }
symbols â† {knameâ‡"symbol"
  Mâ†(knameâ‰¡Kindâˆ˜âŠ¢)_and_(â‰¡â—‹Show)
  Newâ‡{ kindâ‡kname â‹„ showsâ‡ğ•© â‹„ Matchesâ‡M }
}

functions â† {knameâ‡"function"
  currentâ‡@
  New â† {ğ•¤
    kindâ‡kname â‹„ showsâ‡"f"âˆ¾â€¢Repr idâ‡ğ•© â‹„ Matchesâ‡â‰¡ â‹„ typeâ‡@
    handleâ†Â¯1 â‹„ labelâ†Â¯1 â‹„ argsâ†âŸ¨âŸ© â‹„ rTypeâ‡@
    Nextâ‡{ ğ•© registers.New handle+â†©1 }
    NextLabelâ‡{ğ•¤â‹„ NewLabel label+â†©1 }
    NextArgâ‡{ argsâˆ¾â†©ğ•© â‹„ Next ğ•© }
    âŸ¨Push,ArrâŸ©â†MakeStack@
    Instrsâ‡Arr
    Appendâ‡{ Pushğ•©â‹„@ ; (1âŠ¸âŠ‘âŠ£ğ•Š) âŸ¨"new",Nextğ•¨âŸ©âˆ¾symbols.NewâŒ¾âŠ‘ğ•© }
    SetRTypeâ‡{
      SetRTypeâ†©!âˆ˜0 â‹„ !types.Is rTypeâ†©ğ•©
      type â†© args types.Fun rType
    }
    _ret_â†{
      @â‰¢rType? types.IsVoid rType? AppendâŸğ•˜ âŸ¨"ret",âŠ‘types.primTypesâŸ© â‹„@ ;
      Append âŸ¨"ret", rType â‰¢âŸœ@â—¶âŸ¨ğ”½âˆ˜âŠ¢, types.CastâŸ© ğ•©âŸ©
    }
    Returnâ‡!âˆ˜"Early return from function with no explicit result type" _ret_ 1 @âŠ£Â´âŠ¢
    Finishâ‡{"Explicit result type needed"!IsTyped ğ•©â‹„SetRtype TypeOf ğ•©â‹„ğ•©} _ret_ 0
    Protâ‡{ğ•¤â‹„ 1â†“âˆ¾" "âŠ¸âˆ¾Â¨âŸ¨shows,Show rTypeâŸ©âˆ¾(â€¢Reprâˆ˜â‰ âŠ¸âˆ¾ShowÂ¨args)}
  }
  _with â‡ {
    fsâ†current
    fâ†currentâ†©program.AddFunction new
    f.Finish f ğ”½ ğ•©
    currentâ†©fs
    f
  }
  NextHandle â‡ { current.Next ğ•© }
  NextArg â‡ { current.NextArg ğ•© }
  Label â‡ { current.NextLabel ğ•© }
  Append â† { ğ•¨ current.Append ğ•© }
  Return â‡ { current.Return ğ•© }
  Emit â‡ { (âŠ‘ğ•©) Append "emit" <âŠ¸âˆ¾ ğ•© }
  Copy â‡ { (âŠ‘ğ•©) Append "val" <âŠ¸âˆ¾ ğ•© }
  Mut  â‡ {
    "Can't assign to non-register" ! "register"â‰¡Kind ğ•¨
    Append "mut"â€¿ğ•¨â€¿ğ•©
    ğ•¨.SetMut@
    ğ•¨
  }
  Call â‡ {
    f â† âŠ‘ğ•©
    ! "function"â‰¡Kind f
    t â† f.rType
    t Append âŸ¨"call",t,fâŸ© âˆ¾ â‰ âŠ¸âˆ¾ 1â†“ğ•©
  }
  _instr â† { Append (ğ•¨ğ”½ğ•©)<âŠ¸âˆ¾ğ•¨â‹ˆğ•© }
  SetLabel â‡ "lbl"_instr
  Goto     â‡ "goto"âŠ˜"gotoT"_instr
  GotoF    â‡ "gotoF"_instr
}

blocks â† {knameâ‡"block"
  New â‡ {ğ•Š indâ€¿ptrsâ€¿bodyâ€¿lsâ€¿e:
    kindâ‡kname
    showsâ‡"{block}" â‹„ Matchesâ‡â‰¡
    Execâ‡{
      ! ptrsâ‰¡â—‹â‰ 1âŠ‘ğ•©
      r â† body.Eval be â† âŸ¨â‰ ind,ls,ğ•©âŸ© env.Block e
      be.Stores @
      r
    }
  }
  Exec â‡ {ğ•Š indâ€¿varsâ€¿block:
    ! "block"â‰¡Kind block
    block.Exec indâ€¿vars
  }
}
Load â† {  ğ•Š ptrâ€¿i: functions.Emit âŸ¨types.Deref TypeOf ptr, symbols.New "si_load", ptr, iâŸ© }
Storeâ† {v ğ•Š ptrâ€¿i: functions.Emit âŸ¨types.Deref TypeOf ptr, symbols.New "si_store", ptr, i, vâŸ© }


builtins â† {
  Kinds â† {
    E â† "Unhandled type" ! 0Ë™
    (e{kâ€¿oâ†ğ•¨â‹„âˆ§â—‹(kâ‰¡âŠ¢)â—¶âŸ¨ğ•,OË™âŸ©}Â´ğ•©){oâ†ğ•¨ğ”½â—‹Kindğ•©â‹„ğ•¨Oğ•©}
  }
  Ty2 â† {ğ•âš‡0Â´}âˆ˜Kinds "number"â€¿"type"â‹ˆÂ¨{ğ•numbers._cmp}âŠ¸â‹ˆ
  Fmt â† 2â†“Â·âˆ¾Â·", "âŠ¸âˆ¾Â¨ShowâŠ("("âˆ¾")"âˆ¾ËœKindâŠ"unknown")Â¨
  namesâ€¿values â‡ <Ë˜âˆ¾â‰âŸ¨
    ShowÂ¨âŠ¸â‰ types.primTypes
    â‰> âŸ¨
      âŸ¨"show",(1â‰ â‰ )â—¶âŠ‘â€¿{Showsâ‡!âˆ˜"Multiple show used improperly"}âŠ£â€¢Outâˆ˜FmtâŸ©
      âŸ¨"call",functions.CallâŸ©, âŸ¨"emit",functions.EmitâŸ©,
      âŸ¨"return",functions.ReturnâŸ©, âŸ¨"exec",blocks.ExecâŸ©
      âŸ¨"match",MatchÂ´âŸ©
      âŸ¨"hastype",IsTypedâˆ˜âŠ‘ _and_ ({ğ•©.type}âŠ¸MatchÂ´)âŸ©
      âŸ¨"type",TypeOfâˆ˜âŠ‘âŸ©, âŸ¨"kind",symbols.New Kindâˆ˜âŠ‘âŸ©
      âŸ¨"typekind",symbols.New types.TypeKindâˆ˜âŠ‘âŸ©
      âŸ¨"load",LoadâŸ©, âŸ¨"store",Â¯1âŠ¸(âŠ‘Storeâ†“)âŸ©
      âŸ¨"tup",âŠ¢âŸ©, âŸ¨"tupsel",numbers.FromâŠ¸âŠ‘Â´âŸ©, âŸ¨"merge",âˆ¾âŸ©
      âŸ¨"bind",âŠ‘{ğ•ğ•©âŠ¸âˆ¾}1âŠ¸â†“âŸ©, âŸ¨"apply",{ğ•ğ•©}Â´âŸ©, âŸ¨"each",âŠ‘{ğ•Â¨<Ë˜â‰>ğ•©}1âŠ¸â†“âŸ©
    âŸ©
    numbers.builtins
    types.builtins
    >âŸ¨
      "__eq"â€¿"__ne"â€¿"__lt"â€¿"__gt"â€¿"__le"â€¿"__ge"
      =â€¿â‰ â€¿<â€¿>â€¿â‰¤â€¿â‰¥ Ty2Â¨ âŸ¨Match,Â¬MatchâŸ© âˆ¾ Â·â¥Šâ‰Ë˜âŸœ({ğ•Ëœ}Â¨) âŸ¨types.SSubtype,types.SubtypeâŸ©
    âŸ©
  âŸ©
}

var â† {
  Getâ‡{ğ•©.Get@}
  SetTypeâ‡{ğ•¨.SetTypeğ•©}
  Fixedâ‡{ Getâ‡ğ•©Ë™ }
  Newâ‡{
    vâ†ğ•© â‹„ Getâ‡{ğ•¤â‹„v} â‹„ Setâ‡{vâ†©ğ•©}
    SetTypeâ‡{SetTypeâ†©!âˆ˜0
      C â† functions.Copy ğ•©â‹ˆâŠ¢
      G â† ("register"â‰¡Kindâˆ˜âŠ¢)â—¶âŸ¨ C , {ğ•©.SetUsed@â‹„ğ•©} CâŸ{ğ•©.used} âŸ©
      Setâ†©Set Â·G ğ•©âŠ¸types.Cast
    }
  }
}
scopes â† {
  noLambda â† var.Fixed {!âˆ˜"Unhandled case"}
  nullâ†{Getâ‡{ErrâŸ¨"Undefined name: "âˆ¾ğ•©,ğ•¨âŸ©} â‹„ GetLamâ‡noLambdaË™}
  Newâ‡{
    pâ†@Â¨nâ†ğ•¨âŠ£âŸ¨âŸ© â‹„ Namesâ‡{ğ•¤â‹„n}
    Sel â†{ğ•©âŠ‘env.Vars}
    Makeâ†{câ†â‰ nâ‹„pâ€¿nâˆ¾âŸœ<Â¨â†©ğ•©â‹„c}
    Dup â†{ErrâŸ¨"Duplicate definition: ",âŠ‘ğ•©,"Previously defined here: ",ğ•¨âŠ‘pâŸ©}
    Par â†{ğ•âˆ˜env.Parent}
    _find â† { (nâŠ¸âŠâŒ¾<ğ•©) =âŸœ(â‰ n)â—¶ğ•— ğ•¨â€¿ğ•© }
    Get â‡ âŸ¨SelâŠ£, Par ğ•©.GetÂ´âˆ˜âŠ¢âŸ© _find
    Add â‡ Sel Dupâ€¿Make _find
    Lam â† ParâŸ(noLambdaâŠ¸â‰¢) ğ•©.GetLamÂ´âˆ˜âŠ¢
    AddLam â‡ âŸ¨â‹ˆËœSelâˆ˜âŠ£, Lamâ‹ˆSelâˆ˜MakeâŸ© _find
    GetLam â‡ âŸ¨SelâŠ£, LamâŸ© _find
  }
  Initâ‡New nullË™

  queue â† âŸ¨âŸ©
  _defer â‡ { queueâˆ¾â†©<ğ”½â€¿ğ•© }
  _run â‡ {
    ğ”½ _defer ğ•©
    _while_ â† {ğ”½âŸğ”¾âˆ˜ğ”½_ğ•£_ğ”¾âˆ˜ğ”½âŸğ”¾ğ•©}
    {ğ•Š:dâ†âŠ‘queueâ‹„queueâ†“Ëœâ†©1â‹„{ğ•ğ•©}Â´d}_while_{ğ•Š:0<â‰ queue} @
  }
}
env â† {
  Vars  â‡{ğ•©.vars}
  Parentâ‡{ğ•©.parent}
  Make â†{ varsâ‡ğ•¨ â‹„ parentâ‡ğ•© }
  New  â‡{ (var.Newâˆ˜@Â¨ ğ•¨) Make ğ•© }
  Fixedâ‡{ (var.FixedÂ¨ ğ•¨) Make ğ•© }
  Blockâ‡{âŸ¨ni,Loadâ€¿Store,indâ€¿ptrsâŸ© ğ•Š par:
    pi â† ptrs â‹ˆÂ¨ <ind
    pv â† LoadÂ¨ pi
    varsâ€¿parent â‡ (var.FixedÂ¨(indÂ¨â†•ni)âˆ¾pv) Make par
    Stores â‡ {ğ•¤
      mâ†{(ğ•©.Get@).mut}Â¨vâ†niâ†“vars
      v var.GetâŠ¸(Storeâˆ¾âŸœ<Ëœ)Â¨â—‹(mâŠ¸/) pi
    }
  }
}

program â† {
  AddFunctionâ‡Exportâ‡!âˆ˜0 â‹„ traceâ‡@
  _with â‡ {
    fnsâ†âŸ¨âŸ© â‹„ AddFunction â†© { f â† ğ• â‰ fns â‹„ fnsâˆ¾âŸœ<â†©f â‹„ f }
    expâ†âŸ¨âŸ© â‹„ Export â†© { "Exporting non-function" ! "function"â‰¡Kind ğ•© â‹„ exp âˆ¾âŸœ<â†© ğ•¨â€¿ğ•© }
    âŸ¨_trace_âŸ©â†©sâ†Stack@
    ğ•¨ ğ”½âŠs.Report ğ•©
    AddFunctionâ†©Exportâ†©!âˆ˜0
    âˆ¾ âŸ¨âˆ¾DispFunctionÂ¨fns, DispExportÂ¨expâŸ©
  }
  Stack â† {ğ•¤
    âŸ¨_trace_â‡_while_âŸ© â‡ âŸ¨Dumpâ‡ArrâŸ© â† MakeStack@
    Report â‡ {ğ•¤
      â€¢Out (âˆ§`lfâŠ¸â‰ )âŠ¸/âŠâ€¢Repr â€¢CurrentError@
      â€¢Out ""
      # DispSourceÂ¨ âŒ½ Dump@
      # ^ would be the easy way, but we want to compress repeats
      l â† â‰ s â† Dump@
      n â† (â†•l)-Ëœ lâŠ¸=âŠ¸+ â·âŠ¸(âŠ£â‰ âŠ¸â†“âŠ¢âŠ’âˆ¾)âŠs  # Distance to next repetition
      n âŠËœâ†© i â† /Â»âŠ¸â‰ n                 # Split into blocks of equal distance
      e â† n+lÂ«i                       # Last possible endpoint
      Sc â† {ğ•¨ğ•Šnâ€¿iâ€¿e:e-n|âŸ(+ËœâŠ¸â‰¤)e-ğ•¨âŒˆi} # Full reps (if â‰¥2) not overlapping previous
      i âŒˆâ†©Â» e â†© 0 Sc` <Ë˜â‰>âŸ¨n,i,eâŸ©     # Adjust start and end
      iâ€¿nâ€¿e (i<e)âŠ¸/Â¨â†©                 # Filter out empties
      f â† i+n                         # End of displayed reps
      df â† {DispSource ğ•©Ë™}Â¨ s
      rt â† (1<n) ("Repeated "âˆ¾â€¢Reprâˆ˜âŠ¢âˆ¾" times:"âˆ¾/âŸœ" {{{")Â¨ (e-i)Ã·n
      df rtâŠ¸({ğ•âŠ£Â·â€¢Outğ•¨Ë™}Â¨)âŒ¾((f-1)âŠ¸âŠ)â†©
      df {â€¢Outâˆ˜("}}}"âˆ¾@+10)âŠ¢ğ•}Â¨âŒ¾((i/Ëœ1<n)âŠ¸âŠ)â†©
      {ğ•@}Â¨ âŒ½ df /Ëœ 1â‰ `eâ‰ â—‹(lâ†‘/â¼)f     # Remove extra iterations
      â€¢Exit 1
    }
  }
  J â† 1â†“Â·âˆ¾" "âŠ¸âˆ¾Â¨
  Disp â† J ShowÂ¨âŒ¾(1âŠ¸â†“)
  DispFunctionâ†{ âˆ¾âŸ¨"beginFn "âˆ¾ğ•©.Prot@âŸ©â€¿(DispÂ¨ ğ•©.Instrs@)â€¿âŸ¨"endFn",""âŸ© }
  DispExportâ†{ "export " âˆ¾ J {ğ•©.Prot@}âŒ¾âŠ‘ âŒ½ğ•© }
}

nodes â† {
  # Node operations
  o â† {
    Verify â‡ {ğ•©.node}
    Dump â‡ {ğ•©.Dump@}
    Disp â‡ {ğ•©.Disp@}
    Oper â‡ {ğ•©.Oper@}
    Scopeâ‡ {ğ•Šsc :{ğ•©.Scope sc }}
    Eval â‡ {ğ•Šenv:{ğ•©.Eval  env}}
  }
  Defaults â† {
    nodeâ€¿visit â‡ ğ•©
    Visit o.verify
    Dump â‡ {ğ•¤â‹„âŸ¨node,Visit o.dumpâŸ©}
    Disp â‡ {ğ•¤â‹„node <âŠ¸âˆ¾ "  "âŠ¸âˆ¾Â¨ âˆ¾âˆ¾ @ â¥Šâˆ˜<âˆ˜âŠ¢âŸ((2Ã—â‰¡)+â‰¡âŸœ@)Â¨â—‹Visit o.disp}
    Oper â‡ {ğ•¤â‹„Visit o.oper â‹„ operator.nil}
    Scopeâ‡ {Visit o.Scope ğ•©â‹„@}
    Eval â‡ {Visit o.Eval ğ•©}
  }

  # Node types
  Ident â† {
    nameâ‡ğ•© â‹„ posâ‡ğ•¨âŠ£@
    âŸ¨node,DumpâŸ©â‡Defaults "ident"â€¿âŸ¨âŸ©
    Dispâ‡{ğ•¤â‹„âŸ¨nameâŸ©}
    Operâ‡{ğ•¤â‹„operator.Lookup name}
    Evalâ‡!âˆ˜0 â‹„ Scopeâ‡{Evalâ†©var.Getâˆ˜(pos ğ•©.Get name)}
  }
  _value â† {
    nameâ†ğ•©
    Evalâ‡(ğ•¨ğ”½ğ•©)Ë™
    âŸ¨node,Dump,Oper,ScopeâŸ©â‡Defaults "value"â€¿âŸ¨âŸ©
    Dispâ‡{ğ•¤â‹„âŸ¨nameâŸ©}
  }
  Word â‡ (âŠ‘âŠâˆ˜âŠ¢âˆŠdigË™)â—¶âŸ¨Ident, numbers.Read _valueâŸ©
  Symbol â‡ (symbols.New 1â†“Â¯1â†“âŠ¢)_value
  Run â‡ {
    âŸ¨caller,paramsâŸ©â†ğ•© â‹„ posâ‡ğ•¨
    Visitâ†{âŸ¨ğ•caller,ğ•Â¨paramsâŸ©}
    âŸ¨node,Dump,Disp,ScopeâŸ©â‡dâ†Defaults "run"â€¿visit
    Oper â‡ {ğ•¤â‹„ pos operator.Run âŸ¨âŠ‘Visit o.oper,paramsâŸ©}
    Eval â‡ {ğ• program._trace_ pos ğ•©}Â´ d.Eval
  }
  Call â‡ { ğ•¨ Run âŸ¨Ident"call" , <âŠ¸âˆ¾Â´ğ•©âŸ© }
  Phrase â‡ {
    thingsâ†ğ•©
    ToNameâ‡{ğ•¤â‹„ (1=â‰ )â—¶@â€¿(("ident"â‰¡{ğ•©.node})â—¶@â€¿{ğ•©.name}âŠ‘) things }
    Visitâ†{âŸ¨ğ•Â¨thingsâŸ©}
    âŸ¨node,Dump,Disp,Scope,EvalâŸ©â‡Defaults "phrase"â€¿visit
    Operâ‡{ğ•¤
      n â† o.OperÂ¨âŠ¸operator.Parse things
      Scopeâ†©{ğ•¨n.Scopeğ•©} â‹„ Evalâ†©{ğ•¨n.Evalğ•©} â‹„ Dispâ†©{ğ•¨n.Dispğ•©}
      operator.nil
    }
  }
  PhraseTryName â‡ {"phrase"â‰¡ğ•©.node}â—¶@â€¿{ğ•©.ToName@}
  PhraseToName â‡ @ (âŠ¢âŠ£!âˆ˜â‰¢) PhraseTryName
  notTypeVar â† types.primTypesâ‰ âŠ¸â†‘builtins.names
  Lambda â‡ {
    âŸ¨âŸ¨paramsPlus,condsâŸ©,resultâŸ©â†ğ•© â‹„ posâ†ğ•¨
    paramsâ€¿pmatchâ€¿ptype â† <Ë˜â‰>paramsPlus
    tname â† (Â¬âˆ˜âˆŠâŸœ(âŸ¨@âŸ©âˆ¾notTypeVar)âŠ¸/ PhraseTryNameÂ¨)Â¨ ptype
    uTypâ€¿iTypâ†(â·âˆ˜âˆ¾ â‹ˆ âŠâˆ˜âˆ¾âŠ”Â·/â‰ Â¨)tname
    _pc â† {nâ†ğ•¨â‹„fâ†ğ•— â‹„ {pos Run âŸ¨Ident f,âŸ¨Ident n,ğ•©âŸ©âŸ©}Â¨ğ•©}
    condsâˆ¾Ëœâ†©âˆ¾(params "hastype"_pcÂ¨ tnameâ‰ âŠ¸â†“Â¨ptype)âˆ¾(params "match"_pcÂ¨ pmatch)
    uParâ€¿iParâ†(â·â‹ˆâŠ)params
    Visitâ†{((iParâŠuPar)âˆ¾âŸœ(âˆ¾""<âŠ¸âˆ¾":"âŠ¸âˆ¾Â¨)Â¨tname)âˆ¾âŸ¨ğ•Â¨conds,ğ•resultâŸ©}
    âŸ¨node,Dump,Disp,OperâŸ©â‡Defaults "lambda"â€¿visit
    Scopeâ‡{ Visit scopes._defer o.Scope (uParâˆ¾uTyp) scopes.New ğ•© }
    Evalâ‡{ğ•¨ ğ•Š e: # ğ•¨ is previous value
      next â† ({ğ•©.Get@}ğ•¨)âŠ£{"No matching generator definition"!0Ë™}
      AllEq â† âˆ§Â´âŠMatchÂ¨1âŠ¸â†“
      Check â† {iPar (â‰¡â—‹â‰¢)_and_(âˆ§Â´AllEqÂ¨âˆ˜âŠ”) ğ•©}
      CT â† {âˆ§Â´((âˆ§Â´IsTypedÂ¨)_and_(AllEq{ğ•©.type}Â¨)âŠâŸœğ•©)Â¨iTyp}
      Check _and_ CTâ—¶Nextâ€¿{
        Fâ†Next ğ•©Ë™
        try â† result.eval{numbers.GetBoolâˆ˜ğ•¨.Evalâ—¶Fâ€¿ğ•}Â´conds
        Try ((iParâˆŠâŠ¸/ğ•©)âˆ¾{ğ•©.type}Â¨iTypâŠ‘Â¨âŠ¸âŠğ•©) env.Fixed e
      }
    }
  }
  Arg â‡ {
    âŸ¨name,typeâŸ©â†ğ•© â‹„ posâ†ğ•¨
    Visitâ†{âŸ¨name,ğ•typeâŸ©}
    âŸ¨node,Dump,Disp,OperâŸ©â‡Defaults "arg"â€¿visit
    vâ†@ â‹„ Scopeâ‡{ type.Scope ğ•© â‹„ v â†© pos ğ•©.Add name }
    Evalâ‡{ uâ†Vğ•© â‹„ u.SetType tâ†type.Eval ğ•© â‹„ u.Set functions.NextArg t }
  }
  Function â‡ {
    âŸ¨args,type,resultâŸ©â†ğ•© â‹„ posâ†ğ•¨
    Visitâ†{âŸ¨ğ•Â¨args,ğ•Â¨type,ğ•resultâŸ©}
    âŸ¨node,Dump,Disp,OperâŸ©â‡Defaults "function"â€¿visit
    Scopeâ‡{ Visit scopes._defer o.Scope scopes.New ğ•© }
    Evalâ‡{
      Evâ†(o.Eval args env.New ğ•©) program._trace_ pos
      EvÂ¨ args
      ğ•¨.SetRTypeâˆ˜EvÂ¨ type
      Ev result
    }functions._with
  }
  Assign â‡ { pos ğ•Š âŸ¨name,1,type,valueâŸ©: # Declaration
    name PhraseToNameËœâ†©@
    Visitâ†{âŸ¨nameâˆ¾":",ğ•Â¨type,ğ•valueâŸ©}
    âŸ¨node,Dump,Disp,OperâŸ©â‡Defaults "assign"â€¿visit
    GetVarâ†!âˆ˜0 â‹„ Scopeâ‡{
      Visit o.Scope ğ•©
      getVar â†© pos ğ•©.Add name
    }
    Evalâ‡{
      u â† GetVar ğ•©
      v â† value.Eval ğ•©
      u var.SetType â‰ â—¶âŸ¨TypeOf vË™, (o.Evalğ•©)âˆ˜âŠ‘âŸ© type
      u.Set v
    }
  ;
    ğ•¨ Run âŸ¨{functions.MutÂ´ğ•©}Ë™_value"=" , 0â€¿3âŠğ•©âŸ©
  }
  Define â‡ {
    âŸ¨name,valueâŸ©â†ğ•© â‹„ posâ†ğ•¨
    Visitâ†{âŸ¨name,ğ•valueâŸ©}
    âŸ¨node,Dump,Disp,OperâŸ©â‡Defaults "define"â€¿visit
    v0â†vâ†@ â‹„ Scope â‡ {
      value.Scope ğ•©
      v0â€¿v â†© pos ("lambda"â‰¡value.node)â—¶âŸ¨ @â‹ˆğ•©.Add , ğ•©.AddLam âŸ© name
    }
    Evalâ‡{ uâ†Vğ•© â‹„ u.Set (V0ğ•©) value.Eval ğ•© }
  }
  OpDef â‡ {
    âŸ¨type,op,fn,precâŸ©â†ğ•© â‹„ posâ†ğ•¨
    !"value"â‰¡prec.node â‹„ precâ†©numbers.From prec.Eval@
    Visitâ†{ğ•¤â‹„âŸ¨type,op,fn,â€¢Repr precâŸ©}
    âŸ¨node,Dump,Disp,Scope,EvalâŸ©â‡Defaults "opdef"â€¿visit
    Operâ‡{ğ•¤â‹„ pos operator.Add typeâ€¿opâ€¿fnâ€¿prec}
  }
  Export â‡ {
    âŸ¨name,valueâŸ© â† {Show ğ•©.Eval@}Â¨âŒ¾âŠ‘ ğ•© â‹„ posâ†ğ•¨
    Visitâ†{âŸ¨name,ğ•valueâŸ©}
    âŸ¨node,Dump,Disp,Oper,ScopeâŸ©â‡dâ†Defaults "export"â€¿visit
    Eval â‡ { program.Export program._trace_ posÂ¨âŸœ<Â´ d.Eval ğ•© }
  }
  Include â‡ {
    {ğ•©.NoScope@â‹„ğ•©} files.Include Show (âŠ‘ğ•©).Eval@
  }
  Body â‡ {
    statementsâ†ğ•©
    Visitâ†{âŸ¨ğ•Â¨statementsâŸ©}
    âŸ¨node,Dump,Disp,OperâŸ©â‡dâ†Defaults "body"â€¿visit
    scâ†@ â‹„ Scopeâ‡{ Visit o.Scope sc â†© scopes.New ğ•© }
    Evalâ‡{ Â¯1âŠ‘âŠ‘d.Eval (sc.Names@) env.New ğ•© }
    # Hack for include statements
    NoScopeâ‡{ğ•¤â‹„ Scopeâ†©d.Scope â‹„ Evalâ†©Â¯1âŠ‘Â·âŠ‘d.Eval }
  }
  If â‡ {
    âŸ¨cond,then,elseâŸ©â†ğ•©
    Visitâ†{âŸ¨ğ•cond,ğ•then,ğ•Â¨elseâŸ©}
    âŸ¨node,Dump,Disp,Oper,ScopeâŸ©â‡Defaults "if"â€¿visit
    Eval â‡ {
      c â† cond.Eval eâ†ğ•©
      { IsTyped c ?
        lf â† functions.Label@
        c functions.GotoF lf
        then.Eval e
        functions.GotoÂ¨ lt â† functions.LabelÂ¨ else
        functions.SetLabel lf
        lt { ğ•©.Eval e â‹„ functions.SetLabel ğ•¨ }Â¨ else
        {Showsâ‡!âˆ˜"Can't use if statement result as value"â‹„kindâ‡"error"}
      ;
        numbers.GetBool c ? then.Eval e ;
        r â† {Showsâ‡!âˆ˜"Can't use if-0 statement result as value"â‹„kindâ‡"error"}
        r âŠ£Â´ { ğ•©.Eval e }Â¨ else
      }
    }
  }
  While â‡ {
    âŸ¨testFirst,cond,stmtâŸ©â†ğ•©
    Visitâ†{âŸ¨ğ•cond,ğ•stmtâŸ©}
    âŸ¨node,Dump,Disp,Oper,ScopeâŸ©â‡Defaults "while"â€¿visit
    Eval â‡ {
      functions.GotoÂ¨ lc â† functions.LabelÂ¨â†•testFirst
      functions.SetLabel lt â† functions.Label@
      stmt.Eval ğ•©
      functions.SetLabelÂ¨ lc
      (cond.Eval ğ•©) functions.Goto lt
      {Showsâ‡!âˆ˜"Can't use while statement result as value"â‹„kindâ‡"error"}
    }
  }
  n0 â† Word "0"
  For â‡ {
    âŸ¨fn,ptrs,ind,from,to,bodyâŸ©â†ğ•© â‹„ posâ†ğ•¨
    fromâ†©n0âŠ£Â´from
    ptriâ†IdentÂ¨ptrs
    vardispâ†1â†“âˆ¾(","âŠ¸âˆ¾Â¨ptrs)âˆ¾" over "âŠ¸âˆ¾Â¨ind
    Visitâ†{âŸ¨ğ•fn,vardispâŠ£ğ•Â¨ptri,ğ•from,ğ•to,ğ•bodyâŸ©}
    âŸ¨node,Dump,Disp,OperâŸ©â‡dâ†Defaults "for"â€¿visit
    lsâ†@
    Scope â‡ {
      (o.Scope ğ•©)Â¨ âˆ¾âŸ¨fnâŸ©â€¿ptriâ€¿âŸ¨from,toâŸ©
      ls â†© (<pos) {ğ•}âˆ˜ğ•©.GetÂ¨ "load"â€¿"store"
      body.Scope scopes._defer (indâˆ¾ptrs) scopes.New ğ•©
    }
    Eval â‡ {
      eâ†o.Eval ğ•©
      Forâ†(E fn) program._trace_ pos
      lsvâ†var.Getâˆ˜{ğ•ğ•©}âŸœğ•©Â¨ ls
      For âŸ¨EÂ¨ptri, E from, E to, blocks.New indâ€¿ptrsâ€¿bodyâ€¿lsvâ€¿ğ•©âŸ©
    }
  }
}

files â† {
  pathâ†@ â‹„ logâ†âŸ¨âŸ©
  Load â† {
    path â†© (âˆ¨`âŒ¾âŒ½'/'âŠ¸=)âŠ¸/ ğ•©
    ast.Build â€¢file.Chars ğ•©
  }
  Include â‡ {
    f â† ('.'=âŠ‘)â—¶âŸ¨"include/",pathâŸ©âŠ¸â€¢file.At ğ•©âˆ¾".singeli"
    log âˆ¾â†© <f
    opâ†path â‹„ aâ†Load f â‹„ pathâ†©op â‹„ a
  }
  Build â‡ {
    log â†© âŸ¨âŸ©
    a â† Load ğ•©
    â€¢file.LinesâŸœlogâŸ(@âŠ¸â‰¢) ğ•¨
    a
  }
}

ast â† {
  Show â‡ {â€¢Out âˆ¾âˆ¾âŸœlfÂ¨ ğ•©.Disp @}
  baseScope â† builtins.names scopes.New scopes.Init@
  baseEnv   â† builtins.values env.Fixed @
  Build â‡ Parseâˆ˜Tokenize
  Compile â‡ {
    t â† ğ•¨ files.Build ğ•©
    t.Oper operator._with @
    t.Scope scopes._run baseScope
    t.Eval program._with baseEnv
  }
}

(âˆ¾âˆ¾âŸœlfÂ¨) ast.Compile
