tabâ€¿lfâ†@+9â€¿10

dig â† '0'+â†•10
alphâ† â¥Š"aA"+âŒœâ†•26
wc  â† digâˆ¾alphâˆ¾"._"      # Word characters
oc  â† "!$%&*+-/<=>?\^|~" # Operator characters that can stick together

# Source to list of token strings
Tokenizeâ†{
  # Resolve comments and strings
  sâ€¿dâ€¿câ€¿nâ†ğ•©âŠ¸=Â¨"'""#"âˆ¾lfâ‹„sdâ†/Â¨sâ€¿d
  gâ†â‹qâ†(Â¯1â†“Â¨sd)âˆ¾âŠ¸âˆ¾/c â‹„qâ†©gâŠq                 # Open indices
  eâ† gâŠ( 1â†“Â¨sd)âˆ¾âŠ¸âˆ¾-âŸœÂ»âˆ˜âŠâŸœ(0âˆ¾+`c)âŠ¸//nâˆ¾1       # Matching close indices
  Seâ†{(âŠËœğ•¨)Se 1Â¨âŒ¾((ğ•©/ğ•¨)âŠ¸âŠ)ğ•©}âŸ(0=Â¯1âŠ‘âŠ¢)       # Mark reachable openings
  aâ€¿bâ†((â‰ ğ•©)â†‘Â·/â¼((â‰ â†‘âˆ¾âŸœâ‰ Se 1âˆ¾0Â¨)qâ‹e)âŠ¸/)Â¨qâ€¿e   # Open/close masks
  kâ†Â»â‰ `abâ†aâˆ¨b                               # Token continuation mask
  {âŸ¨âŠ‘/ğ•©,"Unclosed quote"âŸ©!0}âŸ(âˆ¨Â´)(sâˆ¨d)>kâˆ¨a
  ignâ†(ğ•©âˆŠ" "âˆ¾tab)âˆ¨â‰ `abâˆ§câˆ¨n                  # Ignored characters
  # Other stuff
  kâˆ¨â†©âˆ¨Â´(Â»âŠ¸âˆ§k<ğ•©âŠ¸âˆŠ)Â¨wcâ€¿oc                     # Group names, numbers, and ops
  tsâ†Â¬kâˆ¨ign                                 # Token start mask
  âŸ¨ğ•©âŠ”Ëœ1-ËœignÂ¬âŠ¸Ã—+`ts, /tsâŸ©
}

MakeStack â† {ğ•¤
  stâ†@ â‹„ dâ†0
  Pushâ‡{   stâ†©ğ•©â€¿st â‹„ d+â†©1}
  Pop â‡{ğ•¤â‹„ râ€¿sâ†st â‹„ stâ†©s â‹„ d-â†©1 â‹„ r}
  Arr â‡{ğ•¤â‹„ âŠ‘Â¨ âŒ½ 1âŠ¸âŠ‘âŸ(â†•d) st}
  _while_â‡{Pop âŠ¢ ğ”½ âŠ£ Â·Pushğ•˜Ë™}
}

Parse â† {
  # Three kinds of token tests, distinguished by depth.
  Is â† â‰¡âˆ˜âŠ¢â—¶âŸ¨
    {ğ•ğ•¨}   # 0 Function to apply
    â‰¡      # 1 Token
    âŠ‘<âŠ¸âˆŠ   # 2 List of tokens
  âŸ©
  sep â† âŸ¨";", â¥ŠlfâŸ©

  ! (Â¯1âŠ‘ğ•©) Is sep

  Err â† {â€¢â†>DumpStack@ â‹„ ğ•¨!ğ•©}
  MakeStream â† {
    lenâ†â‰ srcâ†ğ•© â‹„ iâ†0
    Pos  â‡ {ğ•¤â‹„i}
    Inc  â† {ğ•¤â‹„i+â†©1}
    Rem  â‡ {ğ•¤â‹„(i+1)<len}
    Peek â‡ {ğ•¤â‹„iâŠ‘src}
    Next â‡ PeekâŠ¸Is
    Get  â‡ Inc âŠ¢ PeekâŠ¸(âŠ£âŠ£â‰â—‹<ErrâŸ(Â¬âŠ¢)Is)
    Try  â‡ 1âˆ˜IncâŸâŠ¢âˆ˜Next
  }
  âŸ¨Next,Get,Peek,Try,Rem,PosâŸ© â† MakeStream ğ•©

  # Node creation and error tracking
  c â† nodes
  âŸ¨_whileParse_â‡_while_, DumpStackâ‡ArrâŸ© â† MakeStack@
  _node_ â† {ğ”½ ğ”¾_whileParse_âŸ¨ğ•—,Pos@âŸ© ğ•©}

  When  â† {Testâ€¿Cont:       ( â¥Šâˆ˜< Cont)âŸTest   âŸ¨âŸ©  }
  While â† {Testâ€¿Contâ€¿init: {(ğ•Šâˆ¾âŸœ<âŸœCont)âŸTestğ•©} ContÂ¨â†•init}
  _seq â† {â‰¡Â¨âŠ¸((â‰ âŸœ1âˆ§(<sep)â‰¢Â¨âŠ¢)/>âŸœ0â—¶{ğ•@}â€¿GetÂ¨) ğ”½}

  Name â† Get (âŠ‘alphâˆŠËœâŠ)Ë™
  Word â† Get (âŠ‘(wcâˆ¾oc)âˆŠËœâŠ)Ë™

  AddParams â† {ğ•Šâˆ˜(c.run  _node_ (âŠ¢â‰â—‹<"{"â€¿"}"_args))âŸ(Next"{") ğ•©}
  AddArgs   â† {  (c.call _node_ (âŠ¢â‰â—‹<"("â€¿")"_args))âŸ(Next"(") ğ•©}
  Expr0 â† {ğ•¤
    Vec â† c.run _node_ (âŸ¨c.Word"vector"âŸ© âˆ¾ "["â€¿Exprâ€¿"]"â€¿Expr0 _seq)
    Par â† âŠ‘ "("â€¿Exprâ€¿")" _seq
    Â¬âˆ˜IsâŸœ"["â—¶âŸ¨Vec, Â¬âˆ˜IsâŸœ"("â—¶âŸ¨Par,c.word _node_ WordâŸ©âŸ© Peek@
  }
  Callable â† AddParamsâˆ˜Expr0
  Expr â† c.phrase _node_ {ğ•¤
    While âŸ¨Â¬Nextâˆ˜(sepâˆ¾â¥ŠÂ¨",:=)}"), AddArgsâˆ˜Callable, 0âŸ©
  }

  _args â† {ğ•¤
    Get âŠ‘ğ•—
    a â† While âŸ¨Tryâˆ˜",", Expr, 1âŸ©
    Get 1âŠ‘ğ•—
    a
  }

  Statement â† {
  "if":     c.if     _node_ ("if"â€¿"("â€¿Exprâ€¿")"â€¿Statementâ€¿(Whenâˆ˜âŸ¨Nextâˆ˜"else",StatementâŸ©)_seq)@ ;
  "while":  c.while  _node_ (1 âˆ¾   "while"â€¿"("â€¿Exprâ€¿")"â€¿Statement _seq)@ ;
  "do":     c.while  _node_ (0 âˆ¾âŸœâŒ½ "do"â€¿Statementâ€¿"while"â€¿"("â€¿Exprâ€¿")"â€¿sep _seq)@ ;
  # TODO: make most of the for definition conditional
  "@":      c.for    _node_ ("@"â€¿Callableâ€¿"("â€¿(Whileâˆ˜âŸ¨Tryâˆ˜",", Name, 1âŸ©)â€¿"over"â€¿Nameâ€¿"from"â€¿Exprâ€¿"to"â€¿Exprâ€¿")"â€¿Statement _seq)@ ;
  "return": c.return _node_ ("return"â€¿Expr _seq)@ ;
  "{":      c.body   _node_ Body@ ;
  ğ•©:
    n â† Expr@
    d â† Try ":"
    e â† Try "="
    t â† When âŸ¨d>e, {eâ†©Try"="â‹„ğ•©}âˆ˜ExprâŸ©
    c.assign _node_ {âŸ¨ğ•©,d,t,Expr@âŸ©}âŸe n
  }âˆ˜Peek

  Seps â† {Tryâˆ˜sepâ—¶@â€¿ğ•Šğ•©}
  Body â† {ğ•¤
    Get "{"
    While âŸ¨Â¬Tryâˆ˜"}"âˆ˜Seps, Statement, 0âŸ©
  }
  # ğ•© indicates if preceding token was =
  Result â† c.body _node_ (Nextâˆ˜"{"â—¶âŸ¨Exprâ€¿sep _seq !, BodyâŸ©)

  Params â† {ğ•¤
    Param â† {ğ•¤
      n â† Name@
      e â† When âŸ¨Try"==", ExprâŸ©
      nâ€¿e
    }
    Get "{"
    a â† While âŸ¨Tryâˆ˜",", Param, 1âŸ©
    c â† While âŸ¨Tryâˆ˜"&", Expr, 0âŸ©
    Get "}"
    aâ€¿c
  }
  _withParams â† {ğ•¤
    (Next"{")â—¶âŸ¨ğ”½, c.lambda _node_ (Paramsâ€¿ğ•Š _seq)âŸ©@
  }

  Function â† c.function _node_ {ğ•¤
    Get "("
    Arg â† c.arg _node_ (Nameâ€¿":"â€¿Expr _seq)
    a â† While âŸ¨Tryâˆ˜",", Arg, 1âŸ©
    Get ")"
    r â† When âŸ¨Try":", ExprâŸ©
    b â† Result Try"="
    âŸ¨a,r,bâŸ©
  } _withParams
  Generator â† âŸ¨"=",Resultâˆ˜1âŸ©_seq _withParams
  DefFun â† c.define _node_ (      Nameâ€¿Function  _seq)
  Define â† c.define _node_ ("def"â€¿Nameâ€¿Generator _seq)

  Symb â† '''=âŠ‘
  Export â† c.export _node_ ((Get symbË™)â€¿"="â€¿Callableâ€¿sep _seq)

  Program â† c.body _node_ {ğ•¤
    Line â† Â¬âˆ˜IsâŸœ"def"â—¶âŸ¨Define, Symbâ—¶DefFunâ€¿ExportâŸ©âˆ˜Peek
    While âŸ¨Rem, Lineâˆ˜Seps, 0âŸ©
  }

  Program @
}

_and_ â† { ğ”½â—¶âŸ¨0,ğ”¾âŸ© }
IsNum â† 1=â€¢Type
IsInt â† IsNum _and_ (âŒŠâŠ¸=)
IsNat â† IsInt _and_ (0âŠ¸â‰¤)
Show â† {â€¢Typeâ—¶âŸ¨"tup{"âˆ¾"}"Â«Â·âˆ¾(","âˆ¾ğ•Š)Â¨, â•, !,!,!,!,!, {ğ•©.Show@}âŸ©ğ•©}

âŸ¨IsTypeâŸ© â† types â† {
  IsType â‡ {ğ•Šv: type=v.class}
  Type â† {kğ•Šd:
    classâ‡ğ•¤
    kindâ€¿datâ‡ğ•¨â€¿ğ•©
    Showâ‡kindâ—¶âŸ¨
      "void"               # Void:                     void
      âˆ¾âŸœâ•Â´                 # Primitive:   qualâ€¿len     u8
      {âˆ¾"["â€¿ğ•¨â€¿"]"â€¿ğ•©}â—‹ShowÂ´ # Vector:      countâ€¿t      [4]â€¦
      "*"âˆ¾Show             # Pointer:     t            *â€¦
      {âˆ¾ğ•¨â€¿" -> "â€¿ğ•©}â—‹ShowÂ´  # Function:    âŸ¨t, qâ€¿râ€¿sâŸ©   (â€¦,â€¦,â€¦) -> â€¦
      Show                 # Tuple:       qâ€¿râ€¿s        (â€¦,â€¦,â€¦)
    âŸ©âˆ˜dat
  }
  tVOIDâ€¿tPRIMâ€¿tVECâ€¿tPTRâ€¿tFUNâ€¿tTUP â† â†•6

  primTypes â‡ (tVOID Type âŸ¨âŸ©)âˆ¾âˆ¾(<(tPRIM Type â‰)Â¨Â´)Ë˜ âˆ˜â€¿2â¥ŠâŸ¨
    'u', 2â‹†0âˆ¾3+â†•4  # 1/8/16/32/64
    'i', 2â‹†  3+â†•4  #   8/16/32/64
    'f', 2â‹†  5+â†•2  #        32/64
  âŸ©

  Vec â‡ {nğ•Št: !IsNat n â‹„ !IsType t â‹„ tVEC Type âŸ¨n,tâŸ©}
  Ptr â‡ { ğ•Št: !IsType t â‹„ tPTR Type t}

  Kindâ†{ğ•©.kind} â‹„ Datâ†{ğ•©.dat}
  _cases â† {
    c â† âŒŠâ€¿2â¥Šğ•—
    k â† âŠË˜c
    d â† (1âŠË˜c) âˆ¾ ((â‰ â¥Šc)â†“ğ•—)Â»âŸ¨!âˆ˜0âŸ©
    (kâŠ¸âŠâŒ¾< âŠ¢âŠ˜(â‰ â—¶âŠ¢â€¿Â¯1)â—‹Kind)â—¶({ğ•â—‹Dat}Â¨d) âŠ£ @â—‹(!IsType)
  }

  Size â‡ âŸ¨
    tPRIM, 1âŠ¸âŠ‘
    tVEC,  Ã—âŸœ{Sizeğ•©}Â´
    tTUP,  +Â´{Sizeğ•©}Â¨
  âŸ©_cases

  VCount â‡ âŸ¨ tVEC,âŠ‘, 1 âŸ© _cases

  _sub â† {
    L â† Â¯1âŠ¸âŠ‘
    ğ•¨ âŸ¨
      tVEC,  =â—‹âŠ‘ _and_ (ğ•Šâ—‹L)
      tTUP,  =â—‹â‰  _and_ (âˆ§Â´ğ•ŠÂ¨)
      tPRIM, â‰ â—‹âŠ‘â—¶âŸ¨ğ”½â—‹L, ('f'â‰ âŠ‘âˆ˜âŠ£)_and_(<â—‹L)âŸ©
      0
    âŸ© _cases ğ•©
  }
  Subtype  â‡ â‰¤ _sub
  SSubtype â‡ < _sub
}

# Other types:
# Instruction result (type, index)
# Generator, encoded as function

CallFn â† !  # Check types; emit call instruction


builtins â† âˆ¾â‰âŸ¨
  ShowÂ¨âŠ¸â‰ types.primTypes
  â‰> âŸ¨"call"â€¿CallFn,âŸ¨"vector",types.VecâŸ©âŸ©
âŸ©

scopes â† {
  nullâ†{Getâ‡"Undefined name: "âŠ¸âˆ¾!0Ë™}
  Newâ‡{
    nâ†âŸ¨âŸ© â‹„ PGâ†ğ•©.Get
    Addâ‡{ ("Duplicate definition: "âˆ¾ğ•©)!Â¬âˆ¨Â´â‰¡âŸœğ•©Â¨n â‹„ câ†â‰ n â‹„ nâˆ¾â†©<ğ•© â‹„ câŠ‘env.Vars }
    Getâ‡{ (nâŠ¸âŠâŒ¾<ğ•©) =âŸœ(â‰ n)â—¶{ğ•¨âŠ‘env.Vars}â€¿{(PGğ•©)âˆ˜env.Parent} ğ•© }
    Namesâ‡{ğ•¤â‹„n}
  }
  Initâ‡New nullË™
}
var â† {
  Newâ‡{ğ•¤â‹„ vâ†@ â‹„ Getâ‡{ğ•¤â‹„v} â‹„ Setâ‡{vâ†©ğ•©} }
  Getâ‡{ğ•©.Get@}
  Setâ‡{ğ•¨.Setğ•©}
}
env â† {
  Varsâ‡{ğ•©.vars}
  Parentâ‡{ğ•©.parent}
  Newâ‡{
    varsâ‡MakeVarÂ¨ ğ•¨.Names@
    parentâ‡ğ•©
  }
}

nodes â† {
  # Node operations
  o â† {
    Dump â‡ {ğ•©.Dump@}
    Disp â‡ {ğ•©.Disp@}
    Scopeâ‡ {ğ•Šsc :{ğ•©.Scope sc }}
    Eval â‡ {ğ•Šenv:{ğ•©.Eval  env}}
  }
  Defaults â† {
    nodeâ€¿visit â‡ ğ•©
    Dump â‡{ğ•¤â‹„âŸ¨node,Visit o.dumpâŸ©}
    Disp â‡{ğ•¤â‹„node <âŠ¸âˆ¾ "  "âŠ¸âˆ¾Â¨ âˆ¾âˆ¾ @ â¥Šâˆ˜<âˆ˜âŠ¢âŸ((2Ã—â‰¡)+â‰¡âŸœ@)Â¨â—‹Visit o.disp}
    Scopeâ‡{ğ•¤â‹„Visit o.Scope ğ•©â‹„@}
    Eval â‡{ğ•¤â‹„Visit o.evalâ‹„@}
  }

  # Node types
  Ident â† {
    nameâ‡ğ•©
    âŸ¨node,DumpâŸ©â‡Defaults "ident"â€¿âŸ¨âŸ©
    Dispâ‡{ğ•¤â‹„âŸ¨nameâŸ©}
    Evalâ‡!âˆ˜0 â‹„ Scopeâ‡{Evalâ†©var.Getâˆ˜(ğ•©.Get name)}
  }
  Value â† {
    nameâ‡ğ•¨
    evalâ‡ğ•©
    âŸ¨node,Dump,ScopeâŸ©â‡Defaults "value"â€¿âŸ¨âŸ©
    Dispâ‡{ğ•¤â‹„âŸ¨nameâŸ©}
  }
  bNameâ€¿bVal â† <Ë˜builtins
  Word â‡ {
    AWord â† bNameâŠ¸âŠâŒ¾< â‰¥âŸœ(â‰ bName)â—¶âŸ¨âŠ¢ Value âŠ‘âŸœbVal, Ident âŠ¢âŸ© âŠ¢
    (âˆ§Â´âˆŠâŸœ("."âˆ¾dig))â—¶âŸ¨AWord, ValueâŸœââŸ© ğ•©
  }
  Run â‡ {
    âŸ¨caller,paramsâŸ©â‡ğ•©
    Visitâ†{âŸ¨ğ•caller,ğ•Â¨paramsâŸ©}
    âŸ¨node,Dump,Disp,ScopeâŸ©â‡dâ†Defaults "run"â€¿visit
    Eval â‡ {ğ•ğ•©}Â´ d.Eval
  }
  Call â‡ Run (Word"call") â‰â—‹< <âŠ¸âˆ¾Â´
  Phrase â‡ {
    thingsâ‡ğ•©
    Visitâ†{âŸ¨ğ•Â¨thingsâŸ©}
    âŸ¨node,Dump,Disp,ScopeâŸ©â‡dâ†Defaults "phrase"â€¿visit
    Evalâ‡("TODO: operator parsing"!0Ë™)Â´d.Eval
  }
  Function â‡ {
    âŸ¨args,type,resultâŸ©â‡ğ•©
    Visitâ†{âŸ¨ğ•Â¨args,ğ•Â¨type,ğ•resultâŸ©}
    âŸ¨node,Dump,Disp,ScopeâŸ©â‡Defaults "function"â€¿visit
  }
  ParamEq â† Run (Word"match"){âŸ¨ğ•—,ğ•¨â€¿ğ•©âŸ©}
  Lambda â‡ {
    âŸ¨âŸ¨params,condsâŸ©,valueâŸ©â‡ğ•©
    condsâˆ¾Ëœâ†©âˆ¾<âŠ¸(WordâŠ¸ParamEqÂ¨)Â´Â¨params
    paramsâ†©âŠ‘Â¨params
    Visitâ†{paramsâˆ¾âŸ¨ğ•Â¨conds,ğ•valueâŸ©}
    âŸ¨node,Dump,DispâŸ©â‡Defaults "lambda"â€¿visit
    Scopeâ‡{
      ğ•©.AddÂ¨ params
      Visit o.Scope ğ•©
    }
  }
  Arg â‡ {
    âŸ¨name,typeâŸ©â‡ğ•©
    Visitâ†{âŸ¨name,ğ•typeâŸ©}
    âŸ¨node,Dump,DispâŸ©â‡Defaults "arg"â€¿visit
    Setâ†!âˆ˜0 â‹„ Scopeâ‡{ Set â†© (ğ•©.Add name)âŠ¸var.Set }
  }
  Assign â‡ {
    âŸ¨name,decl,type,valueâŸ©â‡ğ•©
    name {nâ†âŠ‘tâ†ğ•©.things â‹„ !1=â‰ t â‹„ !"ident"â‰¡n.node â‹„ n.name}Ëœâ†©@
    Visitâ†{âŸ¨nameâˆ¾decl/":",ğ•Â¨type,ğ•valueâŸ©}
    âŸ¨node,Dump,DispâŸ©â‡Defaults "assign"â€¿visit
    GetVarâ†!âˆ˜0 â‹„ Scopeâ‡{
      Visit o.Scope ğ•©
      getVar â†© declâ—¶âŸ¨ğ•©.Get, ğ•©.AddâŸ© name
    }
    Evalâ‡{
      u â† GetVar ğ•©
      v â† value.Evalğ•©
      u var.SetTypeâŸœ(â‰ â—¶âŸ¨TypeOf vË™, (o.Evalğ•©)âˆ˜âŠ‘âŸ©)âŸdecl type
      u Set v
    }
  }
  Define â‡ {
    âŸ¨name,valueâŸ©â‡ğ•©
    Visitâ†{âŸ¨name,ğ•valueâŸ©}
    scopedâ†"lambda"â€¿"function"(âˆ¨Â´â‰¡Â¨)<value.node
    âŸ¨node,Dump,DispâŸ©â‡Defaults "define"â€¿visit
    Setâ†!âˆ˜0 â‹„ scâ†@ â‹„ Scopeâ‡{
      Set â†© (ğ•©.Add name)âŠ¸var.Set
      value.Scope sc â†© scopes.NewâŸscoped ğ•©
    }
    Evalâ‡{
      ğ•© Set value.Eval sc env.NewâŸscoped ğ•©
    }
  }
  Export â‡ {
    âŸ¨name,valueâŸ©â‡ğ•©
    Visitâ†{âŸ¨name,ğ•valueâŸ©}
    âŸ¨node,Dump,Disp,ScopeâŸ©â‡Defaults "export"â€¿visit
    Evalâ‡"TODO:exports"!0Ë™
  }
  Body â‡ {
    statementsâ‡ğ•©
    Visitâ†{âŸ¨ğ•Â¨statementsâŸ©}
    âŸ¨node,Dump,Disp,ScopeâŸ©â‡dâ†Defaults "body"â€¿visit
    Evalâ‡Â¯1âŠ‘d.Eval
  }
  If â‡ {
    âŸ¨cond,then,elseâŸ©â‡ğ•©
    Visitâ†{âŸ¨ğ•cond,ğ•then,ğ•Â¨elseâŸ©}
    âŸ¨node,Dump,Disp,ScopeâŸ©â‡Defaults "if"â€¿visit
    Eval â‡ {ğ•¤
      c â† cond.Eval@
      lf â† Label@
      c GotoF lf
      then.Eval@
      GotoÂ¨ lt â† LabelÂ¨ else
      SetLabel lf
      { ğ•©.Eval@ â‹„ SetLabel lt }Â¨ else
    }
  }
  While â‡ {
    âŸ¨testFirst,cond,stmtâŸ©â‡ğ•©
    Visitâ†{âŸ¨ğ•cond,ğ•stmtâŸ©}
    âŸ¨node,Dump,Disp,ScopeâŸ©â‡Defaults "while"â€¿visit
    Eval â‡ {ğ•¤
      GotoÂ¨ lc â† LabelÂ¨â†•testFirst
      SetLabel lt â† Label@
      stmt.Eval@
      SetLabelÂ¨ lc
      (cond.Eval@) Goto lt
    }
  }
  Return â‡ {
    âŸ¨valueâŸ©â‡ğ•©
    Visitâ†{âŸ¨ğ•valueâŸ©}
    âŸ¨node,Dump,Disp,ScopeâŸ©â‡Defaults "return"â€¿visit
    Eval â‡ {ğ•¤
      râ†o.Eval value
      # ! r IsOfType fntype
      Emit "ret"â€¿r
    }
  }
}

ast â† Parse âŠ‘Tokenize â€¢FChars "tests/test.singeli"
â€¢Out âˆ¾âˆ¾âŸœlfÂ¨ ast.Disp @
