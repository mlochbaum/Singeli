cpuâ€¿libpathsâ€¿configs â† â€¢args

tabâ€¿lfâ†@+9â€¿10

dig â† '0'+â†•10
alphâ† "_"âˆ¾â¥Š"aA"+âŒœâ†•26
wc  â† digâˆ¾alphâˆ¾"."       # Word characters
oc  â† "!$%&*+-/<=>?\^|~" # Operator characters that can stick together

# Source to list of token strings
Tokenizeâ†{
  ğ•©+â†©ğ•©(=Ã—lfâŠ¸-)@+13                          # Convert CR to LF
  ğ•©âˆ¾â†©lf(â‰ â¥ŠâŠ£)Â¯1â†‘ğ•©                            # Trailing newline
  # Resolve comments and strings
  sâ€¿dâ€¿câ€¿nâ†ğ•©âŠ¸=Â¨"'""#"âˆ¾lfâ‹„sdâ†/Â¨sâ€¿d
  gâ†â‹qâ†(Â¯1â†“Â¨sd)âˆ¾âŠ¸âˆ¾/c â‹„qâ†©gâŠq                 # Open indices
  eâ† gâŠ( 1â†“Â¨sd)âˆ¾âŠ¸âˆ¾-âŸœÂ»âˆ˜âŠâŸœ(0âˆ¾+`c)âŠ¸//nâˆ¾1       # Matching close indices
  Seâ†â‰ (>/âŠ¢)âˆ¾âŸœâ‰ {(âŠËœğ•¨)ğ•ŠâŸ(â‰ â—‹(Â¯1âŠ¸âŠ‘))ğ•©âˆ¾ğ•©âŠğ•¨}âŸ¨0âŸ©Ë™  # Find reachable openings
  aâ€¿bâ†((â‰ ğ•©)â†‘Â·/â¼(Se qâ‹e)âŠ¸âŠ)Â¨qâ€¿e              # Open/close masks
  kâ†Â»â‰ `abâ†aâˆ¨b                               # Token continuation mask
  {âŸ¨âŠ‘/ğ•©,"Unclosed quote"âŸ©!0}âŸ(âˆ¨Â´)(sâˆ¨d)>kâˆ¨a
  ignâ†(ğ•©âˆŠ" "âˆ¾tab)âˆ¨â‰ `abâˆ§câˆ¨n                  # Ignored characters
  # Other stuff
  daâ†Â»âŠ¸â‰ Â«âŠ¸âˆ¨Â»âŠ¸âˆ§ğ•©='.'                         # >1 dots group alone
  kâˆ¨â†©da<âˆ¨Â´(Â»âŠ¸âˆ§k<ğ•©âŠ¸âˆŠ)Â¨wcâ€¿oc                  # Group names, numbers, and ops
  btâ†(âŒˆ`â†•âˆ˜â‰ Ã—Â¬)k â‹„ xdâ†ğ•©âˆŠdig
  kâˆ¨â†©Â»âŠ¸âˆ¨(Â»(btâŠxd)âˆ§ğ•©='e')âˆ§(ğ•©='-')âˆ§Â«xd        # Negative exponents 12e-3
  tsâ†nâˆ¨Â¬kâˆ¨ign                               # Token start mask
  lcâ†(1+/ğ•©=lf){(âŠ¢â‹ˆÂ¨ğ•©-âŠâŸœ(0âˆ¾ğ•¨))ğ•¨â‹ğ•©}/ts        # Line/column numbers
  âŸ¨ğ•©âŠ”Ëœ1-Ëœ(ign>â‰ `abâˆ§sâˆ¨d)Â¬âŠ¸Ã—+`ts, ğ•¨ Source ğ•©â€¿lcâŸ©
}

# Position handler for error reporting
Source â† { ğ•¨ ğ•Š srcâ€¿lc: fileâ†ğ•¨âŠ£""
  { pos ğ•Š disp:
    râ€¿câ†<Ë˜â‰>posâŠlc
    â€¢Out âˆ¾âŸ¨file, ":", â€¢Repr 1+eâ†Â¯1âŠ‘r, ":"âŸ©
    â€¢Out src/Ëœ(src=lf)(âŠ£<+`âŠ¸=)e
    Tr â† {
      e â† (+`(ğ•©â‰¤Â¯1Â»ğ•¨â‰ âŠ¸+Â¨ğ•©))âŠ”ğ•©â‹ˆÂ¨ğ•¨
      l â† "^"âŒ¾(1âŠ‘Â¯1âŠ‘âŠ‘) âŒ½ "|"âŒ¾(1âŠ¸âŠ‘)Â¨âŠ¸âˆ¾` (1+â‰ e)â†‘e
      {âˆ¾((-âŸœÂ»ğ•¨)âˆ¾â‰ Â¯1âŠ‘ğ•©)â†‘Â¨""<âŠ¸âˆ¾ğ•©}Ëâˆ˜â‰âˆ˜>Â¨ l
    }
    â€¢OutÂ¨ Â¯1â†“âŸ(âˆ§Â´' '=âŠ‘) disp Trâ—‹((r=e)âŠ¸/) c
  }
}
DispSource â† @âŠ¸â‰¢â—¶âŸ¨â€¢OutÂ¨âˆ˜"(unknown position!)"â€¿"", {ğ•ğ•©}Â´âŸ©
Err â† { (ğ•©â‰ âŠ¸â¥Šâ€¢Outâ€¿DispSource) {ğ•ğ•©}Â¨ ğ•© â‹„ â€¢Exit 1 }

AsrtGotGen â† {ğ•Š disp: {ğ”½ğ•© ? ğ•© ; !âˆ¾âŸ¨ğ•ğ•©," (got ",Dispğ•©,")"âŸ©}}
_asrtGotRâ€¿_asrtGotS â† AsrtGotGenÂ¨ â€¢Reprâ€¿{Showğ•©}

# Parameter checks for builtins (_p1 and _p2 to use BQN monad/dyad)
_e1 â† {ğ”½âŠ£"Expected one parameter"  1âŠ¸=_asrtGotR â‰ } â‹„ _p1â†{ğ”½âŠ‘_e1}
_e2 â† {ğ”½âŠ£"Expected two parameters" 2âŠ¸=_asrtGotR â‰ } â‹„ _p2â†{ğ”½Â´_e2}
_e3 â† {ğ”½âŠ£"Expected three parameters" 3âŠ¸=_asrtGotR â‰ }
_v1 â† {ğ”½âŠ£"Expected at least one parameter"  1âŠ¸â‰¤_asrtGotR â‰ }
_v2 â† {ğ”½âŠ£"Expected at least two parameters" 2âŠ¸â‰¤_asrtGotR â‰ }

numbers â† {knameâ‡"number"
  f â† â€¢Import "float2.bqn"
  NN â† 1â‰ â€¢Type  # Not native number
  Is â† knameâ‰¡{Kindğ•©}
  Wrap â† {kindâ‡knameâ‹„valueâ‡ğ•©â‹„Matchesâ‡Matchâ‹„Showsâ‡FmtLargeâˆ˜ğ•©}
  Unwrap â† {
    6=â€¢Typeğ•© ? knameâ‰¡ğ•©.kind ? ğ•©.value ;
    (ğ•¨âŠ£"Expected constant number") 0 _asrtGotS ğ•©
  }
  Promote â† NNâ—¶f.Toâ€¿Unwrap
  GetFloat â‡ f.Fromâˆ˜UnwrapâŸ(NNâŠ¢)
  _getter_ â† {(ğ•˜âˆ¾" expected")âŠ˜âŠ£ ğ”½_asrtGotR GetFloat}
  GetBool â‡ âŠ‘âˆ˜âˆŠâŸœ0â€¿1 _getter_ "Boolean"
  GetNat  â‡   |âˆ˜âŒŠâŠ¸= _getter_ "Natural number"
  GetInt  â‡     âŒŠâŠ¸= _getter_ "Integer"
  Match â‡ âˆ§â—‹Isâ—¶âŸ¨0,â‰¡â—‹PromoteâŸ©

  _cn â† {ğ”½ âŠ£ "Ill-formed number"!Â·âˆ§Â´'0'âŠ¸â‰¤âˆ§â‰¤âŸœ'9'}
  Nat â† â€¢ParseFloat _cn
  LC â† +âŸœ(32Ã—1="A["âŠ¸â‹) '_'âŠ¸â‰ âŠ¸/  # Lowercase, underscores removed
  da â† digâˆ¾'a'+â†•26
  Read â‡ {
    (â‰ ğ•©)>sâ†âŒŠÂ´ğ•©âŠ"bx" ? # Base n with 0x9abc or 31bNUMBER
      b â† ('b'=sâŠ‘ğ•©)â—¶âŸ¨16âŠ£"x can only appear in 0x in a number"!"0"âŠ¸â‰¡,NatâŸ© sâ†‘ğ•©
      (!"Invalid base (max "âˆ¾â€¢Reprâˆ¾")"Ë™)âŸ(bâŠ¸>) â‰ da
      d â† b ğ• (bâ†‘da) (â‰ âˆ˜âŠ£(âŠ¢âŠ£"Invalid digits"!âˆ§Â´âˆ˜>)âŠ) (1+s)â†“ğ•©
      E â† bâŠ¸Ã—âŠ¸+ËœÂ´âŒ½âˆ˜âŠ¢
      EE â† {hâ€¿lâ†f.Toâˆ˜EÂ¨ğ•¨-âŠ¸(â†“â‹ˆâ†‘)ğ•©â‹„Wrap l f.Add (f.To bâ‹†ğ•¨)f.Mul h}
      (âŒŠ53Ã·2â‹†â¼b) <âŸœâ‰ â—¶Eâ€¿EE d
    ;
      _n â† {('-'=âŠ‘)â—¶âŸ¨ğ”½, -âˆ˜ğ”½ 1âŠ¸â†“âŸ©}
      pe â† âŠ‘ğ•©âŠ'e' â‹„ e â† pe <âŸœâ‰ â—¶âŸ¨0,Nat _n+âŸœ1âŠ¸â†“âŸ© ğ•©
      m â† peâ†‘ğ•© â‹„ m /Ëœâ†© Â¬dmâ†m='.'
      (0â‰ âŠ¢Â´)â—¶âŸ¨âŠ‘,WrapâŸ© (e - (â‰ m)-âŠ‘dmâŠ1)âŠ¸f.ParseDec _cn _n 10 ğ• m
  }{
    # Pass digit repeater as ğ•
    âˆ¨Â´mâ†ğ•©âˆŠcâ†"rdw" ? # r repeat; d total digits; w total bits
    âˆ§Â´Â¬"bx"âˆŠËœğ•©/ËœÂ¬âˆ¨`m ? # Not part of the digit stream
      f â† {(ğ•©Ã—â‰ )âŠ¸ReâŠ¢}â€¿{ğ•©âŠ¸Re}â€¿{ğ•©_wf} â‹„ Reâ†{ğ•¨âŠ¸â¥ŠâŒ¾âŒ½ğ•©}
      p â† ğ•©âŠ”Ëœ(Â¬Ã—1+`âŠ¢)m  # âŸ¨codes, ...counts, restâŸ©
      n â† NatÂ¨ Â¯1â†“1â†“p   # Parsed counts
      wfmâ†"Repetition with w requires the base to be a power of two"
      _wfâ†{b n _ğ•£ ğ•©: wfm!âŒŠâŠ¸=lâ†2â‹†â¼b â‹„ (l|n) 2âŠ¸â‹†âŠ¸|âŒ¾âŠ‘âŸ(â‰ âŸœ0) (âŒˆnÃ·l) Re ğ•© }
      mmâ†"Digit repetition prefixes don't agree"
      ((1<â‰ )â—¶âŠ‘â€¿{(âŠ‘âŠ£mm!âŠ£`âŠ¸â‰¡)ğ•©{ğ•¨ğ•©{ğ•¨ğ•ğ•—}Â¨ğ•—}} n{ğ•ğ•©}Â¨ËœfâŠËœcâŠâŠ‘p) ğ”½ âŠ¢Â´p
    ;
      {âŠ¢} ğ”½ ğ•©
  }âŸœLCâŠ{ErrâŸ¨â€¢CurrentError@,ğ•¨âŸ©}

  InRange â† {1=âŠ‘0â‹Ëœ-ËœÂ´âŸœ(âŒ½ğ•¨)Â¨ğ•©}
  FmtFloat â† ('Â¯'(âŠ¢+=Ã—'-'-âŠ£)â€¢Repr){(âˆ>|)â—¶âŸ¨"/0"âˆ¾ËœÂ·ğ”½0(<->)âŠ¢,ğ”½âŸ©}
  MakeFmt â† {ğ•Š Absâ€¿InRangeâ€¿ToSmallâ€¿ToLarge: {
    âŒŠâŠ¸â‰¡ğ•© ? (aâ†Abs ğ•©) InRange 2â‹†48â€¿64 ? ğ•© InRange -âŒ¾âŠ‘2â‹†63â€¿64 ?
      ((ğ•©â‰¢a)/"-")âˆ¾"0x"âˆ¾daâŠËœâŒ½ 16â€¿16 f._repr ToLarge a ;
    FmtFloat ToSmall ğ•©
  }}
  FmtSmallâ€¿FmtLarge â† MakeFmtÂ¨ âŸ¨
    âŸ¨|,     1=âŠ‘âˆ˜â‹Ëœ,  âŠ¢,   f.ToâŸ©
    âŸ¨f.Abs, InRange, f.From, âŠ¢âŸ©
  âŸ©
  Fmt â‡ FmtSmall

  Cast â‡ {'f'â€¿lğ•Šn:1; qâ€¿lğ•Šn: # 1 if valid; error otherwise
    n NNâ—¶â‹ˆâ€¿Unwrapâ†© â‹„ aâ†AsrtGotGen {â€¢Repr+Â´}
    "Can't cast float to integer" âŒŠâŠ¸â‰¡_a n
    "Constant doesn't fit" (n InRange -âŸœ(1âŠ¸âŠ‘Ã·2Ë™)âŸ(q='i') âŸ¨0,2â‹†lâŸ©)_a n
  }
  _cmp â‡ {(f.Cmp ğ”½ 0Ë™)â—‹Promote}
  builtins â‡ {
    Wâ†Wrap â‹„ Pâ†{ğ•Š:Promoteğ•© ; ğ•Šâ¼:Wğ•©}
    Eâ†f.To 2â‹†GetFloat
    # B gives âŸ¨sign, 2's complement bitsâŸ©
    Compâ†(f.To Â¯1)âŠ¸f.Sub â‹„ IsNegâ†0>f.CmpâŸœ(f.To 0)
    Bâ†â‰ `âˆ˜(f.Bitsâˆ˜{ğ•Šâ¼:ğ•¨ğ•Šğ•©;ğ•Š:CompâŸğ•¨ğ•©}`)âˆ˜{ğ•Šâ¼:1âŠ‘ğ•©;ğ•Š:âŸ¨IsNegğ•©,ğ•©âŸ©}âˆ˜P
    [pr,val] â† â‰[
      ({NNâ—¶âŸ¨ğ•,Wâˆ˜ğ•â—‹UnwrapâŸ©}Â´)â€¿âŸ¨"neg"â€¿âŸ¨-,f.NegâŸ©, "abs"â€¿âŸ¨|,f.AbsâŸ©,
                              "floor"â€¿âŸ¨âŒŠ,f.FloorâŸ©, "ceil"â€¿âŸ¨âŒˆ,f.CeilâŸ©âŸ©
      âŠ¢          â€¿âŸ¨"not"â€¿(Â¬GetBool)âŸ©
      {ğ•âŒ¾P}      â€¿âŸ¨"add"â€¿f.Add, "sub"â€¿f.Sub, "mul"â€¿f.Mul, "div"â€¿f.Div, "mod"â€¿f.ModâŸ©
      {âŠ£âŸ(ğ•_cmp)}â€¿âŸ¨"min"â€¿â‰¤, "max"â€¿>âŸ©
      {W PâŠ¸ğ•âŸœE}  â€¿âŸ¨"shl"â€¿f.Mul, "shr"â€¿(f.Floor f.Div)âŸ©
      {ğ•âŒ¾B}      â€¿âŸ¨"and"â€¿âˆ§, "or"â€¿âˆ¨, "xor"â€¿â‰ âŸ©
    ]
    arg â† 2â€¿4/{ğ•_p1}â€¿{ğ•_p2}
    â‰>âˆ¾ (arg {ğ•âˆ˜{ğ•âš‡0}âˆ˜ğ•}Â¨ pr) {âŸ¨"__"âŠ¸âˆ¾,ğ•âŸ©âŠ¸({ğ•ğ•©}Â¨)Â¨ğ•©}Â¨ val
  }
}

ptrWidth â† cpu.width
architecture â† {
  featsâ€¿matâ€¿FeatInd â† cpu
  init â‡ cpu.baseArch
  # Look up a list of symbols
  Id â† {ğ•¨ FeatInd "Expected symbol for architecture feature"âŠ¸symbols.FromÂ¨ğ•©}
  # An architecture is a mask of supported features
  New â‡ { ğ•¨ âˆ¨Ë (1 Id ğ•©) âŠ mat }
  Contains â‡ âˆ§Â´â‰¥
  Intersect â‡ âˆ§ â‹„ Union â‡ âˆ¨
  Has â‡ âˆ§Â´{(0 Id ğ•©)âŠğ•¨âˆ¾0}  # Has all in list ğ•©
  List â‡ /âŸœfeats
  ListExt â‡ List initâŠ¸<
  # Architecture to be used for the next function created
  next â† init
  SeeNext â‡ {ğ•Š:next}
  NewFunction â‡ {ğ•Š: râ†next â‹„ nextâ†©init â‹„ r }
  With â‡ { NewFunction âŠ¢ (âŠ‘ğ•©){ğ”½} âŠ£ {nextâ†©ğ•©}âˆ˜(New 1â†“ğ•©) }_v1
}

MakeStack â† {ğ•¤
  stâ†@ â‹„ dâ†0
  Pushâ‡{   stâ†©ğ•©â€¿st â‹„ d+â†©1}
  Pop â‡{ğ•¤â‹„ râ€¿sâ†st â‹„ stâ†©s â‹„ d-â†©1 â‹„ r}
  Arr â‡{ğ•¤â‹„ âŠ‘Â¨ âŒ½ 1âŠ¸âŠ‘âŸ(â†•d) st}
  _while_â‡{Pop âŠ¢ ğ”½ âŠ£ Â·Pushğ•˜Ë™}
}

MakeStream â† {
  lenâ†â‰ srcâ†ğ•© â‹„ iâ†0
  Pos  â‡ {ğ•¤â‹„i}
  Inc  â† {ğ•¤â‹„i+â†©1}
  Rem  â‡ {ğ•¤â‹„i<len}
  Peek â‡ {ğ•¤â‹„iâŠ‘src}
  Next â‡ Inc âŠ¢ Peek
  Dec  â‡ {ğ•¤â‹„i-â†©1}
}

Parse â† {ğ•Š tokensâ€¿ShowTrace:
  sep â† âŸ¨";", â¥ŠlfâŸ©
  ! âŠ‘ (Â¯1âŠtokens) âˆŠ sep

  keywords â† "include"â€¿"config"â€¿"local"â€¿"if"â€¿"if_inline"â€¿"else"â€¿"while"â€¿"do"â€¿"match"â€¿"extend"â€¿"def"â€¿"fn"â€¿"main"â€¿"oper"â€¿"in"â€¿"over"â€¿"from"â€¿"to"â€¿"and"â€¿"or"â€¿"not"
             kInclude â€¿kConfig â€¿kLocal â€¿kIf â€¿kIf_inline â€¿kElse â€¿kWhile â€¿kDo â€¿kMatch â€¿kExtend â€¿kDef â€¿kFn â€¿kMain â€¿kOper â€¿kIn â€¿kOver â€¿kFrom â€¿kTo â€¿kAnd â€¿kOr â€¿kNot â† â†•â‰ keywords

  Asrt â† {ğ•¨ğ•Š1:@;
    [v, k] â† (<"") âˆ¾Ë˜Â´ {ğ•©âŠ¸â€¢ns.GetÂ¨âŠ¸â‰ â€¢ns.Keys ğ•©}Â¨ câ€¿tc
    ShowTraceâŸœ(vâŠ¸âŠ âŠ kË™)Â´ <Ë˜â‰>DumpStack@
    â€¢Out ""
    F â† (â¥Šlf)âŠ¸â‰¢â—¶âŸ¨"end of line", =â—¶âŸ¨"keyword "âˆ¾â€¢Reprâˆ˜âŠ‘âŸœkeywords, â€¢ReprâŸ©âŸ©
    â€¢Out {âˆ¾"Expected "â€¿ğ•¨â€¿" but saw "â€¿ğ•©}âŸœFÂ´âŸ(1<â‰¡) ğ•¨
    â€¢Exit 1
  }
  MakeTokStream â† {
    iâ†âŠğ•© â‹„ uâ†keywords{ğ•—âŠ¸âŠâŠ£âŸ(<âŸœ(â‰ ğ•—))Â¨âŠ¢}ğ•©/Ëœi>Â¯1Â»âŒˆ`i
    âŸ¨Incâ‡Next,PeekRawâ‡PeekâŸ©â†âŸ¨Pos,Rem,Backâ‡DecâŸ©â‡MakeStream i
    PeekRaw â†© PeekRaw âŠ£ "File ended unexpectedly" Asrt Rem
    Peek â† âŠ‘âŸœuâˆ˜PeekRaw
    Try  â‡ 1âˆ˜IncâŸâŠ¢ PeekâŠ¸â‰¡
    Get  â‡ Inc (â€¢ReprâŠ¸â‹ˆ Asrt 0Ë™)âŸâ‰¢âŸœPeek
    # Faster tests on raw tokens
    _test â‡ {(ğ”½Â¨u)âŠ‘ËœPeekRaw}
    firstâ†âŠ‘Â¨u
    _begin_ â‡ {tâ†ğ”½ first â‹„ Inc âŠ¢ (âŠ‘âŸœu (âŠ£ âŠ£ ğ•˜âŠ¸â‹ˆâŠ¸Asrt) âŠ‘âŸœt)âˆ˜PeekRaw}
    GetS â† âŠ¢ {Inc (((â€¢Reprğ•¨)â‹ˆâŠ‘âŸœu) Asrt 0Ë™)âŸ(ğ•©âŠ¸â‰¢)âˆ˜PeekRaw}Â¨ uâŠ¸âŠ
    _seq â‡ {aâ†3â‰ â€¢TypeÂ¨ğ•— â‹„ (Â¬a)/{ğ•@}Â¨âˆ˜(GetSâŒ¾(aâŠ¸/)ğ•—) }
    _opt_ â‡ {@_ğ•£_ğ•˜:
      tâ€¿c â† (1âŒ¾(Â¯1âŠ¸âŠ‘)2|â†•âˆ˜â‰ )âŠ¸âŠ” ğ•˜
      exp â† "one of "âˆ¾âˆ¾âŸœ", "âŠ¸âˆ¾Â´â€¢ReprÂ¨t
      (âŠ‘(uâŠt)âŠPeekRaw)â—¶(câˆ¾âŸ¨(expâ‹ˆPeek) Asrt 0Ë™âŸ©)
    }
    _optGet_ â‡ {@_opt_({ğ•âŠ£Inc}Â¨âŒ¾((2|â†•âˆ˜â‰ ğ•˜)âŠ¸/)ğ•˜)}
    _any â‡ {âŠ‘(uâŠğ•—)âˆŠËœPeekRaw}
    _anyTry â‡ {1âˆ˜IncâŸâŠ¢âˆ˜(ğ•—_any)}
  }
  âŸ¨Get,Try,Rem,Pos,Back,_test,_begin_,_seq,_opt_,_optGet_,_anyTry,_anyâŸ© â† MakeTokStream tokens

  # Node creation and error tracking
  c â† nodes â‹„ tc â† targetNodes
  âŸ¨_whileParse_â‡_while_, DumpStackâ‡ArrâŸ© â† MakeStack@
  _node_ â† {pâ†Pos@ â‹„ (ShowTraceâ—‹â‹ˆâŸœ""âŠ¢)â€¿p ğ”½ ğ”¾_whileParse_âŸ¨p,ğ•—âŸ© ğ•©}
  AsrtHere â† {ğ•¨ Asrt _whileParse_ âŸ¨Pos@,""âŸ© ğ•©}

  When  â† {Testâ€¿Cont:       ( â¥Šâˆ˜< Cont)âŸTest   âŸ¨âŸ©  }
  While â† {Testâ€¿Contâ€¿init: {(ğ•Šâˆ¾âŸœ<âŸœCont)âŸTestğ•©} ContÂ¨â†•init}

  _ifASCII â† {(@+128)âŠ¸â‰¤âˆ¨ğ”½}
  Name â† âˆŠâŸœalph _begin_ "name"
  Oper â† âˆŠâŸœoc _ifASCII _begin_ "operator"
  Symbol â† c.symbol _node_ ('''âŠ¸=_begin_"symbol")
  IsLogic â† âˆŠâŸœkAndâ€¿kOrâ€¿kNot

  LFs â† {ğ•ŠâŸTry âŸ¨lfâŸ©}
  Div â† {LFs@ â‹„ 1âˆ˜LFsâŸâŠ¢ Try ğ•©}  # Divider, allowing surrounding newlines
  TrySep â† sep _anyTry
  Seps â† {Rem@ ? TrySep@ ? ğ•Šğ•©â‹„1 ; 0}

  _decl_ â† { ğ”½"Declaration" â‹„ Declare ğ”¾ ğ•© }
  _exprStmt â† {AsrtStmt _ğ•£: @_opt_âŸ¨
  kIf,     { StIf ğ•© }
  kWhile,  { StWhile ğ•© }
  kDo,     { DoWhile ğ•© }
  kMatch,  { Options ğ•© }
  "@",     { For ğ•© }
  kExtend, { Extend ğ•© }
  kDef,    { Define ğ•© } âŠ£ AsrtStmtâˆ˜"def"
  kFn,     { DefFun ğ•© } âŠ£ AsrtStmtâˆ˜"fn"
  kMain,   { DefMainğ•© } âŠ£ AsrtStmtâˆ˜"main"
  kOper,   { OpDef ğ•© }  âŠ£ AsrtStmtâˆ˜"oper"
  "{",     @_optGet_âŸ¨"=>", c.lambda _node_ (â‹ˆâŸœ{Blockğ•©})
                     ":",  AsrtStmt _decl_ âŠ¢           âŸ© {Paramsğ•©}
           { AsrtStmt _decl_ ToIdâŸ(Try":") SimpExpr ğ•© }
  âŸ©}
  Expr â† (âˆ¾âŸœ" must appear on its own line" Asrt 0Ë™) _exprStmt
  Stmt â† âŠ¢ _exprStmt

  Vec â† c.run _node_ (c.consts.vec â‹ˆ "["â€¿Exprâ€¿"]"â€¿{Callableğ•©} _seq)
  ParEx â† âŠ‘ "("â€¿Exprâ€¿")" _seq
  EWord â† c.token _node_ (âŠ‘âŸœkeywordsâŸ(Â¬=) (IsLogicâˆ¨âˆŠâŸœ('''âˆ¾wcâˆ¾oc)_ifASCII) _begin_ "expression")
  Expr0 â† @_opt_âŸ¨"[",Vec, "(",ParEx, EWordâŸ©

  _spreadable â† {<âˆ˜âŠ¢âŸâŠ£âŸœğ”½âˆ˜Tryâˆ˜"..."}
  _args â† {ğ•— _argsFn_ (Expr _spreadable)}
  _divList â† {Divâˆ˜"," _and_ (ğ•—âŠ¸â‰¢_test)}
  _argsFn_ â† {ğ•¤
    Get âŠ‘ğ•—
    LFs@
    Try 1âŠ‘ğ•— ? âŸ¨âŸ© ;
    a â† While âŸ¨(1âŠ‘ğ•—)_divList, ğ”¾, 1âŸ©
    Get 1âŠ‘ğ•—
    a
  }
  ParC â† {ğ•¤ # Parameter in call
    s â† Try "..."
    p â† sâ—¶âŸ¨Tryâˆ˜".", (sepâˆ¾","â€¿"}")_anyâŸ© @  # Partial application
    <âŸs ExprâŸ(Â¬p) @
  }
  err_ex_gather â† "At most one variable-length parameter allowed"
  ParCs â† âŠ¢ â‹ˆ Â· (err_ex_gather Asrt 1â‰¥Â·+Â´(<@)âŠ¸â‰¡Â¨)âŠ¸âŠ¢ "{"â€¿"}"_argsFn_ ParC
  AddParams â† @_opt_âŸ¨"{", {AddParamsâˆ˜(c.run  _node_ ParCs           ) ğ•©}, âŠ¢âŸ©
  AddArgs   â† @_opt_âŸ¨"(", {          (c.call _node_ (âŠ¢â‹ˆ"("â€¿")"_args)) ğ•©}, âŠ¢âŸ©
  Callable â† AddParamsâˆ˜Expr0
  CanCall â† (Â¬ =â—¶âŸ¨IsLogicâŒ¾<, âˆ¨Â´(ocâˆ¾"[")=âŠâŸ©) _test
  StartsOp â† =â—¶âŸ¨IsLogicâŒ¾<, âŠ‘âˆ˜âˆŠâŸœoc _ifASCIIâˆ˜âŠ‘âŸ© _test
  Call â† { câ†CanCall @ â‹„ AddArgsâŸc Callableğ•© }

  ExprFromEnd â† {ğ•Š endTok:
    End â† (endTokâˆ¾sepâˆ¾â¥ŠÂ¨",:)}]")_any
    {
      o â† StartsOp ğ•©
      Cont â† {pâ†o â‹„ pâˆ¨oâ†©StartsOp ğ•©}_and_(Â¬End)
      c.phrase _node_ (Whileâˆ˜âŸ¨Cont, Call, 1âŸ©) ğ•©
    }
  }
  SimpExprâ€¿TypeExprâ€¿CondExpr â† ExprFromEndÂ¨ âŸ¨âŸ©â€¿âŸ¨"="âŸ©â€¿âŸ¨"&"âŸ©

  # ğ•© is the expression preceding ":"
  Declare â† c.declare _node_ {
    n â† ğ•©
    t â† When âŸ¨Â¬Try"=", Getâˆ˜"=" âŠ¢ TypeExprâŸ©
    âŸ¨n,t,Expr@âŸ©
  }
  ToId â† {"Unexpected "":"""AsrtHere@â‰¢ğ•© â‹„ ğ•©.IsDef@â‹„ğ•©} c.PhraseTryWord

  _lines_ â† { Line _ğ•£_ Cont ğ•©:
    Seps @ â‹„ s â† 1
    SepLine â† {"Expected separator" AsrtHere s â‹„ lâ†Lineğ•© â‹„ sâ†©Seps@ â‹„ l}
    While âŸ¨Cont, SepLine, 0âŸ©
  }
  _blockLines â† { âŠ‘ âŸ¨"{", ğ”½ _lines_ (Â¬Tryâˆ˜"}")âŸ©_seq }
  Body â† Stmt _blockLines
  Block â† @_opt_âŸ¨"{",c.body _node_ Body, ExprâŸ©

  AnyIf â† âŸ¨kIf, kIf_inlineâŸ©_anyTry
  _if â† {
    TrySeps â† {sâ†Seps@ â‹„ BackâŠ¸âŠ¢âŸ(s>âŠ¢) Remâ—¶0â€¿Try ğ•©}
    1â†“ AnyIfâ€¿"("â€¿Exprâ€¿")"â€¿ğ”½â€¿(Whenâˆ˜âŸ¨TrySepsâˆ˜kElse,ğ”½âŸ©)_seq
  }
  StIf â† c.if _node_ (Block _if)
  StWhile â† c.while _node_ (1 âˆ¾   kWhileâ€¿"("â€¿Exprâ€¿")"â€¿Block _seq)
  DoWhile â† c.while _node_ (0 âˆ¾âŸœâŒ½ kDoâ€¿Blockâ€¿kWhileâ€¿"("â€¿Exprâ€¿")" _seq)

  Options â† c.options _node_ {ğ•¤
    Get kMatch
    a â† @_opt_âŸ¨"(", â‹ˆ"("â€¿")"_args, âŸ¨âŸ©âŸ© @
    m â† c.lambda _node_ (Paramsâ€¿"=>"â€¿Block _seq) _blockLines @
    aâ€¿m
  }

  For â† c.for _node_ {ğ•¤
    OAâ† "@for: multiple variables must use ""over"""âŠ¸AsrtHere
    TAâ† "@for: ""from"" missing ""to"""âŠ¸Asrt
    NAâ† "@for: loop variable must be a name"âŠ¸Asrt
    Get "@"
    f â† Callable@
    Get "(" â‹„ LFs@
    toâ† SimpExpr@
    NEâ† {ğ•¤â‹„ nâ†â‹ˆâˆ˜{NA@â‰¢ğ•©â‹„ğ•©}âˆ˜c.PhraseTryNameâŸğ•© to â‹„ toâ†©SimpExpr@ â‹„ n}
    {Div kIn? toâ†©âŸ¨âŠ‘NE 1,toâŸ©; @}
    peâ† While âŸ¨Divâˆ˜",", Divâˆ˜kInâ—¶âŸ¨â‹ˆ,â‹ˆâŸœSimpExprâŸ© Name, 0âŸ©
    psâ† {Div kOver?(<NE 0==to)âˆ¾ğ•©; OA 0=â‰ ğ•©â‹„âŸ¨âŸ©} pe          # Pointers
    frâ† When âŸ¨Div kFrom, SimpExprâŸ©                        # Start index
    i â† {Â¬Div kTo?TA 0=â‰ frâ‹„âŸ¨âŸ©; 0<=to?psâˆ¾â†©<NE 0â‹„âŸ¨âŸ©; NE 1}  # Index variable
    LFs@ â‹„ Get ")"
    b â† Block@
    âŸ¨f,ps,i,fr,to,bâŸ©
  }

  # ğ•© indicates if preceding token was =
  Result â† c.body _node_ (@_opt_âŸ¨
    "{", Body
    "@", â‹ˆFor
         â‹ˆâˆ˜Expr "Missing = before body?"AsrtâŠ¢
  âŸ©)

  TargetList â† tc.list _node_ {ğ•¤
    Get "{"
    LFs@
    a â† {
      âˆŠâŸœ"}"â€¿"&"â€¿kIfâŒ¾<_test@ ? 0â¥Š<â†•2 ;
      Param â† âŸ¨Tryâˆ˜"...", TargetElemâŸ©_seq
      a â† While âŸ¨"}"_divList, Param, 1âŸ© â‹„ err_ex_gather Asrt 1â‰¥+Â´âŠ‘Â¨a â‹„ a
    }
    c â† @_optGet_âŸ¨kIf,â‹ˆExpr, While âŸ¨Divâˆ˜"&", CondExprâŠ£â€¢Outâˆ˜"Conditions with & are deprecated; use if/and", 0âŸ©âŸ© @
    Get "}"
    aâ€¿c
  }
  # Only destructure names not of primitive types
  # Matches old behavior but doesn't allow type destructuring
  notTypeVar â† types.primTypesâ‰ âŠ¸â†‘builtins.names
  TypeTarget â† c.PhraseTryNameâŠ¸(âˆŠâŸœ(âŸ¨@âŸ©âˆ¾notTypeVar)âŒ¾<âˆ˜âŠ£â—¶âŸ¨tc.NameâŠ£, tc.ConstantâŠ¢âŸ©)âˆ˜CondExpr
  # Note, == and : bind tighter [] and * than since it's more useful
  TargetWord â† tc.name _node_ Name
  TargetEq   â† tc.equals _node_ (â‹ˆâŸœCondExpr  )âŸ(Tryâˆ˜"==") âˆ˜ TargetWord
  TargetPlus â† tc.typed  _node_ (â‹ˆâŸœTypeTarget)âŸ(Tryâˆ˜":" ) âˆ˜ TargetEq
  TargetElem â† @_opt_âŸ¨
    "(", tc.constant _node_ ParEx
    "[", tc.vector _node_ {"["â€¿TargetElemâ€¿"]"â€¿TargetElem _seq ğ•©}
    "{", TargetList
    =â—¶âŸ¨0, âˆ§Â´'*'âŠ¸=âŸ©_testâ—¶âŸ¨  # Multiple *s group as one token
      TargetPlus
      tc.pointer _node_ {ğ•¤
        a â† '*'âŠ¸=_begin_"" @
        tc.pointerâŸ(1-Ëœâ‰ a) TargetElem@
      }
    âŸ©
  âŸ©
  Params â† c.target _node_ TargetList
  _withParams â† {
    Rec â† @_opt_âŸ¨"{",c.lambda _node_ (Paramsâ€¿{Recğ•©} _seq), ğ”½âŸ©
  }
  IdTarget â† c.newId _node_ Name
  Target â† @_opt_âŸ¨"{",Params, IdTargetâŸ©

  Arg â† c.arg _node_ ((Tryâˆ˜"...")â€¿Nameâ€¿":"â€¿SimpExpr _seq)
  Function â† c.function _node_ {ğ•¤
    a â† "("â€¿")" _argsFn_ Arg @
    r â† When âŸ¨Try":", TypeExprâŸ©
    b â† Result Try"="
    âŸ¨a,r,bâŸ©
  } _withParams
  DefFun â† c.define _node_ (kFnâ€¿IdTargetâ€¿Function _seq)
  DefMain â† c.main _node_ {ğ•¤
    Get kMain
    a â† @_opt_âŸ¨"(","("â€¿")" _argsFn_ Name, âŸ¨âŸ©âŸ© @
    "Main function can have at most two arguments" Asrt 2â‰¥â‰ a
    RT â† "Main result must be void or i32" AsrtHere âˆŠâŸœ"void"â€¿"i32"âŒ¾<
    r â† When âŸ¨Try":", RTâŠ¸âŠ¢ NameâŸ©
    b â† Result Try"="
    âŸ¨a,r,bâŸ©
  }

  ExtPar â† "{"â€¿"}" _argsFn_ Name
  Extender â† c.extender _node_ (ExtParâ€¿"="â€¿Body _seq)
  Extend â† c.extend _node_ (kExtendâ€¿Expr0â€¿ExtPar _seq)

  GenRes â† âŠ‘âŸ¨"=",Resultâˆ˜1âŸ©_seq
  Value â† @_opt_âŸ¨"=",GenRes, @âŸ©
  Generator â† @_opt_âŸ¨"{",GenRes _withParams, ValueâŸ©
  # Decide how to parse definition value based on what's after def
  Valuator â† @_optGet_âŸ¨kExtend,ExtenderË™, @_opt_âŸ¨"{",ValueË™,"_",ValueË™,GeneratorË™âŸ©âŸ©
  Define â† c.define _node_ {ğ•¤
    Get kDef
    v â† Valuator @
    âŸ¨Target, VâŸ©_seq @
  }
  confNameâ€¿confVal â† (âŠ‘Â¨â‹ˆ1âŠ¸âŠ‘Â¨)configs
  Config â† c.define _node_ {
    Get kConfig
    tâ€¿r â† âŸ¨IdTarget, "=", Resultâˆ˜1âŸ©_seq ğ•©
    n â† t.name
    tâ€¿{ (â‰ confName) > iâ†confNameâŠ¸âŠâŒ¾<n ? ("config "âˆ¾n) ast.Build iâŠ‘confVal ; r }
  }

  OpType â† @_optGet_âŸ¨
    "prefix", 'p'
    "infix",  @_optGet_(âŸ¨'n'âŸ©âˆ¾Ëœâˆ¾â‹ˆâŸœâŠ‘Â¨"none"â€¿"left"â€¿"right")
  âŸ©
  Number â† c.number _node_ (âˆŠâŸœdig _begin_ "number")
  OpName â† @_opt_âŸ¨"(",ParEx, NameâŸ©
  OpDef â† c.opDef _node_ (kOperâ€¿Operâ€¿OpNameâ€¿OpTypeâ€¿Number _seq)

  Include â† c.include _node_ (kIncludeâ€¿Symbol _seq)

  MultiLine â† {Lineğ•©} _blockLines
  TopIf â† c.topif _node_ (âˆ¾âŒ¾(Â¯1âŠ¸âŠ‘) @_opt_âŸ¨"{",MultiLine, â‹ˆ{Lineğ•©}âŸ© _if)
  SubLine â† @_opt_âŸ¨kIf,TopIfâŠ£â€¢Outâˆ˜"Top-level if is deprecated as it now means if_inline but will be a normal if; change to if_inline or parenthesize"
                   kInclude,Include, kIf_inline,TopIf, kConfig,Config, StmtâŸ©
  LocLine â† @_opt_âŸ¨kIf_inline,"localizable line"â€¿kIf_inline AsrtHere 0Ë™, kIf,StIf, SubLineâŸ©
  Line â† @_optGet_âŸ¨
    kLocal, @_opt_âŸ¨"{",c.body _node_ MultiLine, LocLineâŸ©
            {ğ•©.NonLocal@â‹„ğ•©}âˆ˜SubLine
  âŸ©

  Program â† c.body _node_ (Line _lines_ Rem)

  Program @
}

operator â† {
  Parse â‡ {
  âŸ¨opâŸ© ğ•Š âŸ¨vâŸ©: vâŠ£Â´{ğ•©.V v.pos}Â¨@âŠ¸â‰¢Â¨âŠ¸/op.leftâ€¿op.null ;
  ops ğ•Š val:
    Peekâ€¿Nextâ€¿Rem â† MakeStream ops {nullâ€¿leftâ€¿bindâ€¿Râ‡ğ•¨ â‹„ valueâ‡ğ•©}Â¨ val
    E â† {ğ•Štest: {ğ•Šâˆ˜{ğ•© LeD Next@}âŸ(Test Peek)âŸRem ğ•©} NuD Remâ—¶Misâ€¿Next@ }
    Run â† nodes.Run â‹„ P â† {ğ•©.value.pos}
    NuD â† { ğ•©.null â‰¢âŸœ@â—¶{ğ•©.value}â€¿{posâ†Pğ•© â‹„ pos Run âŸ¨ğ•©.R ğ•¨.V pos, âŸ¨E ğ•¨.tâŸ©âŸ©} ğ•© }
    LeD â† { posâ†Pğ•© â‹„ UnkâŸ(@â‰¡lâ†ğ•©.left)pos â‹„ pos Run âŸ¨ğ•©.R l.V pos, âŸ¨ğ•¨, E l.tâŸ©âŸ© }
    Unk â† { Err "Unknown infix operator"â€¿ğ•© }
    Mis â† {ğ•Š: Err "Missing right operand"â€¿(Â¯1âŠ‘val).pos }
    E 1
  }
  Run â‡ {ğ•¨ğ•ŠâŸ¨op,paramsâŸ©:
    Par â† ğ•¨ nodes.Run â‹ˆâŸœparams
    nullâ€¿left â‡ {âŸ¨TâŸ©â‡ğ•© â‹„ Vâ‡Parâˆ˜ğ•©.V}âŸ(@âŠ¸â‰¢)Â¨ op.nullâ€¿op.left
    bindâ€¿Râ‡op
  }
  Compose â† {preğ•Šin: âŸ¨nullâŸ©â‡pre â‹„ leftâ€¿bindâ‡in â‹„ Râ‡âŠ¢ }
  nil â‡ { nullâ‡leftâ‡@ â‹„ bindâ‡Â¯âˆ â‹„ Râ‡âŠ¢ }

  Tab â‡ { par ğ•Š new:
    pâ†nâ†oâ†âŸ¨âŸ©  # pos, name, output
    Ind â† { nâŠ¸âŠâŒ¾<ğ•© }
    Add â‡ {
      i â† Ind 1âŠ‘ğ•©
      i<â‰ n ? ErrâŸ¨"Duplicate operator definition:",âŠ‘ğ•©,"Previously defined here:",iâŠ‘pâŸ© ;
      pâ€¿nâ€¿o âˆ¾âŸœ<Â¨â†© râ†(1âŠ‘ğ•©)âŠ¸NewâŒ¾(2âŠ¸âŠ‘)ğ•© â‹„ 2âŠ‘r
    }
    Get â‡ { iâ†Indğ•© â‹„ (i=â‰ n)â—¶âŸ¨iâŠ‘oË™,par.GetâŸ© ğ•© }
  }
  NewScope â‡ {
    parent â‡ ğ•©
    Op â† {name ğ•Š Vâ€¿pâ€¿câ€¿a: Vâ‡
      AC â† { Err ("Associativity for operator "âˆ¾nameâˆ¾" must be disambiguated")â€¿ğ•¨.value.pos }âŸ(0âŠ¸>)
      T â‡ (p C {ğ•©.bind}){{âŠ£ACğ•}âŸağ•—}
    }
    tabs â‡ nulâ€¿lef â† parent.tabs TabÂ¨ âŸ¨
      {ğ•¨ğ•ŠâŸ¨value, precâŸ©: null â‡ ğ•¨ Op âŸ¨value, prec, <, 0âŸ© }
      {ğ•¨ğ•ŠâŸ¨value, prec, assocâŸ©:
        bind â‡ prec
        left â‡ ğ•¨ Op âŸ¨value, prec, ("lrn"âŠ¸âŠâŒ¾<assoc)âŠ‘âŸ¨<,â‰¤,<-=âŸ©, 'n'=assocâŸ©
      }
    âŸ©
    Add â‡ {ğ•¨ğ•Štypeâ€¿nameâ€¿valueâ€¿prec:
      lâ†typeâ‰ 'p'
      (lâŠ‘tabs).Add âŸ¨ğ•¨, name, valueâ€¿precâˆ¾lâ¥ŠtypeâŸ©
    }
    Lookup â‡ nul.Get Compose lef.Get
    # include statements also resolved in the operator pass
    includesâ†âŸ¨âŸ© â‹„ AlreadyIncludedâ‡{âˆŠâŸœincludesâŒ¾<ğ•© ? 1 ; includesâˆ¾â†©<ğ•©â‹„0}
  }
  nilScope â‡ { tabs â‡ 2â¥Š{Getâ‡nilË™} } # Lookup â‡ nilË™
}


# Runtime
# Kinds are:
# - BQN values tuple (list), number, generator (function)
# - Classes symbols, types, registers, constants, functions, blocks
_and_ â† { ğ”½â—¶âŸ¨0,ğ”¾âŸ© }
IsTup â† 0=â€¢Type
IsGen â† 3=â€¢Type

_tsel â† {â€¢Typeâˆ˜âŠ£â—¶(Â¯1((â†“Â»(6â¥ŠâŸ¨!âˆ˜"Unhandled kind"âŸ©)Ë™)âˆ¾â†‘)ğ•—)}
Kind  â† âŸ¨"tuple","number",@,"generator",{ğ•©.kind}âŸ©_tsel
Match â† {ğ•¨ âŸ¨â‰¡â—‹â‰¢â—¶âŸ¨0,âˆ§Â´ğ•ŠÂ¨âŸ©, numbers.Match,â‰¡,â‰¡, {ğ•¨ğ•¨.Matchesğ•©}âŸ©_tsel ğ•©}
IsTypedâ†âˆŠâŸœ"register"â€¿"constant"â€¿"function"âŒ¾< Kind
HasType â† IsTypedâˆ˜âŠ£ _and_ ({ğ•©.type}âŠ¸Match)
TypeOfâ† {âŸ¨types.Tup ğ•ŠÂ¨, {ğ•©.Type@}âŸ©_tsel ğ•©}
Showâ€¿Repr â† {
  UnEsc â† âŠ¢-128Ã—(' '+128)âŠ¸= # Non-breaking space to space
  FmtTup â† "tup{"âˆ¾"}"âˆ¾Ëœ1â†“Â·âˆ¾","âŠ¸âˆ¾Â¨
  FmtFn â† {(ğ•Ëœ@).name}
  ReprObj â† {ğ•©.Shows@}
  ObjType â† IsTypedâ—¶0â€¿{ğ•©.fmtType}â—¶""â€¿{":"âˆ¾Repr TypeOfğ•©}
  _ko â† {ğ”½â‰¡{ğ•©.kind}}
  ShowSub â† "type"_koâ—¶ReprObjâ€¿{ğ•©.TypeShow@}âˆ¾ObjType
  ShowObj â† ShowSubâŠ("error"_koâŠ0â—¶("("âˆ¾")"âˆ¾ËœKindâŠ"unknown")â€¿ReprObj)
  EChar â† "(char "âˆ¾â€¢Reprâˆ˜-âŸœ@âˆ¾", probably bug)"Ë™
  _disp_ â† {Râ†âŸ¨FmtTup {Rğ•©}Â¨, numbers.Fmt, ğ”¾, FmtFn, ğ”½âŸ©_tsel}
  Show â‡ UnEsc ShowObj _disp_ EChar
  Repr â‡       ReprObj _disp_ !
}
ShowMulti â† 2â†“Â·âˆ¾Â·", "âŠ¸âˆ¾Â¨ShowÂ¨

types â† {knameâ‡"type"
  New â† {kğ•Šd:
    kindâ‡kname
    typeKindâ€¿datâ‡ğ•¨â€¿ğ•©
    Showsâ€¿TypeShowâ‡{ğ•âˆ˜dat}Â¨typeKindâŠ‘dispfns
    Matchesâ‡{ğ•¨Isâˆ˜âŠ¢â—¶0â€¿Equivğ•©}
  }
  tVOIDâ€¿tPRIMâ€¿tVECâ€¿tPTRâ€¿tFUNâ€¿tTUP â† â†•6
  TypeKindâ‡{
    ReqTyp ğ•©
    ğ•©.typeKindâŠ‘"void"â€¿"primitive"â€¿"vector"â€¿"pointer"â€¿"function"â€¿"tuple"
  }
  dispfns â† {
    _v â† {{âˆ¾"["â€¿ğ•¨â€¿"]"â€¿ğ•©}â—‹ğ”½Â´}             # Vector
    _t â† {1â†“Â·âˆ¾(","âŠ¸âˆ¾âŸ(0<â‰ )ğ”½)Â¨}           # Type tuple, bare
    _ttâ† {"tuptype{"âˆ¾"}"âˆ¾Ëœğ”½_t}           # and for display
    _f â† {("("âˆ¾")"âˆ¾Ëœğ”½_t)âŠ¸{âˆ¾ğ•¨â€¿"->"â€¿ğ•©}âŸœğ”½Â´} # Function args
    {Reprâ€¿Show{dâ†ğ•©â‹„ğ•¨_d}âŸ(4=â€¢Typeâˆ˜âŠ¢)Â¨ğ•©}Â¨ âŸ¨
      <"void"    # Void:                     void
      âˆ¾âŸœâ€¢ReprÂ´   # Primitive:   qualâ€¿len     u8
      _v         # Vector:      countâ€¿t      [4]â€¦
      {"*"âˆ¾ğ”½}    # Pointer:     t            *â€¦
      _f         # Function:    âŸ¨qâ€¿râ€¿s, tâŸ©   (â€¦,â€¦,â€¦) -> â€¦
      _tâ€¿_tt     # Tuple:       qâ€¿râ€¿s        â€¦,â€¦,â€¦   /  tuptype{â€¦,â€¦,â€¦}
    âŸ©
  }
  IsVoid â‡ {tVOIDâ‰¡ğ•©.typeKind}

  void â‡ tVOID New âŸ¨âŸ©
  primTypes â‡ void âˆ¾ tPRIM NewÂ¨ qw â† âˆ¾â‹ˆÂ¨Â¨Ëâ‰ âˆ˜â€¿2â¥ŠâŸ¨
    'u', 2â‹†0âˆ¾3+â†•4  # 1/8/16/32/64
    'i', 2â‹†  3+â†•4  #   8/16/32/64
    'f', 2â‹†  5+â†•2  #        32/64
  âŸ©
  _getPrim â† {{ğ•@} (âŸ¨!âˆ˜ğ•—âŸ©Â«primTypes) âŠ‘Ëœ qwâŠ¸âŠâŒ¾<}

  Is â† knameâ‰¡Kind
  ReqTyp â‡ {"Expected type";ğ•¨âˆ¾" type wasn't type"Ë™} Is _asrtGotS âŠ¢
  Vec â† {nğ•Št:
    l â† "Vector size should be a constant integer" numbers.GetNat n
    "Vector" ReqTyp t
    tVEC New âŸ¨l,tâŸ©
  }
  Ptr â‡ { ğ•Št: "Pointer" ReqTyp t â‹„ tPTR New t}
  Tup â‡ { ğ•Št: !IsTup t â‹„ ReqTypÂ¨ t â‹„ tTUP New t}
  Fun â‡ tFUN New â‹ˆ
  _getâ‡ {IsTup ğ•© ? Tup ğ•ŠÂ¨ğ•© ; ğ•— ReqTyp ğ•©}

  _cases â† {
    Kindâ†{ğ•©.typeKind} â‹„ Datâ†{ğ•©.dat}
    c â† âŒŠâ€¿2â¥Šğ•—
    k â† âŠË˜c
    d â† (1âŠË˜c) âˆ¾ ((â‰ â¥Šc)â†“ğ•—)Â»âŸ¨!"Unhandled type "âˆ¾ReprâŸ©
    (kâŠ¸âŠâŒ¾< âŠ¢âŠ˜(â‰ â—¶âŠ¢â€¿Â¯1)â—‹Kind)â—¶({ğ•â—‹Dat}Â¨âŒ¾((â‰ k)âŠ¸â†‘)d) âŠ£ @â—‹ReqTyp
  }

  TypeErr â† {!âˆ¾âŸ¨ğ•¨," (type was ",Repr ğ•©,")"âŸ©}

  Quality â† âŸ¨tPRIM,{symbols.New â‹ˆâŠ‘ğ•©}, "Expected primitive type"âŠ¸TypeErrâŸ©_cases
  _isQual â† {âŸ¨tPRIM,ğ”½âŠ‘,0âŸ©_cases TypeOfâŸ(Â¬Is)}
  IsInt â‡ âŠ‘âˆ˜âˆŠâŸœ"iu"_isQual

  Unpack â‡ âŸ¨tTUP,{UnpackÂ¨ğ•©},âŠ¢âŸ©_cases
  Ungather â‡ âŸ¨tTUP,âŠ¢,"Gathered argument must have a tuple type"âŠ¸TypeErrâŸ©_cases
  Deref â‡ { Is ğ•© ? tPTR=ğ•©.typeKind ? ğ•©.dat ; "Expected pointer" TypeErr ğ•© }
  TupFrom â‡ { Is _and_ (tTUPâ‰¡{ğ•©.typeKind}) _asrtGotSâŸœ(ğ•©Ë™) ğ•¨ â‹„ ğ•©.dat }
  TupTry â‡ { Is ğ•© ? tTUPâ‰¡ğ•©.typeKind ? ğ•©.dat ; ğ•© }
  Merge â‡ {
    l â† (tTUPâ‰¡{ğ•©.typeKind})â—¶<â€¿TupFromÂ¨ ğ•©  # Assume ğ•© all types
    "Type parameters must include a tuple type" ! 0<âŒˆÂ´=Â¨l
    Tup âˆ¾ l
  }

  Width â† âŸ¨
    tPRIM, 1âŠ¸âŠ‘
    tVEC,  Ã—âŸœ{Widthğ•©}Â´
    tTUP,  +Â´{Widthğ•©}Â¨
    tPTR,  ptrWidth
    {!âˆ¾âŸ¨"Can't find width of ",TypeKindğ•©," type ",Reprğ•©âŸ©}
  âŸ©_cases

  VCount â† âŸ¨ tVEC,âŠ‘, 1 âŸ© _cases
  VType â† âŸ¨ tVEC,1âŠ¸âŠ‘, tPTR,âŠ¢ âŸ© _cases
  vecDecompParams â‡ âŸ¨Is _and_ {tVECâ‰¡ğ•©.typeKind}, {ğ•©.dat}âŸ©
  ptrDecompParams â‡ âŸ¨Is _and_ {tPTRâ‰¡ğ•©.typeKind}, {ğ•©.dat}âŸ©

  FnCast â‡ {
    argsâ€¿ret â† âŸ¨tFUN,âŠ¢, "Calling non-function"âŠ¸TypeErrâŸ©_cases ğ•¨
    args (!"Expected "âˆ¾âŠ£âˆ¾" arguments, got "âˆ¾âŠ¢)â—‹â€¢ReprâŸâ‰¢â—‹â‰  ğ•©
    âŸ¨args CastÂ¨ ğ•©, retâŸ©
  }

  _typeRel_ â† {
    ğ•¨ âŸ¨
      tVOID, 1
      tPRIM, ğ”½
      tVEC,  =â—‹âŠ‘ _and_ (ğ•Šâ—‹(Â¯1âŠ¸âŠ‘))
      tPTR,  (@â‰¢ğ•˜)âŠ‘ğ•Šâ€¿ğ•˜
      tTUP,  MTup â† =â—‹â‰  _and_ (âˆ§Â´ğ•ŠÂ¨)
      tFUN,  ğ•Šâ—‹(1âŠ¸âŠ‘) _and_ (MTupâ—‹âŠ‘)
      0
    âŸ© _cases ğ•©
  }
  _cmpPrim â† {
    Lâ†Â¯1âŠ¸âŠ‘ â‹„ â‰ â—‹âŠ‘â—¶âŸ¨ğ”½â—‹L, ('f'â‰ âŠ‘âˆ˜âŠ£)_and_(<â—‹L)âŸ©
  }
  Equiv    â† â‰¡          _typeRel_ @
  Subtype  â‡ â‰¤ _cmpPrim _typeRel_ 1
  SSubtype â‡ < _cmpPrim _typeRel_ 0

  _asCast â† {
    "Cast" ReqTyp ğ•¨
    Fail â† {!âˆ¾âŸ¨"Can't cast ",Kindğ•©," to ",Reprğ•¨âŸ©}
    Num â† {tğ•Šn:
      âŸ¨ tPRIM,numbers.CastâŸœn, FailâŸœn âŸ© _cases t
      t constants.New n
    }
    Cast â† ğ•Š
    Tup â† {
      ptr â† 0
      c â† âŸ¨ tTUP,âŠ¢, tPTR,{ptrâ†©1â‹„ğ•©}, FailâŸœğ•© âŸ©_casesâŸ(0â‰ â€¢Type) ğ•¨
      ğ•¨ functions.ArrayâŸptr c CastÂ¨ ğ•©
    }
    Obj â† ("number"â‰¢{ğ•©.kind})â—¶âŸ¨Num,IsTypedâˆ˜âŠ¢â—¶âŸ¨FailËœ,ğ”½âŸ©âŸ©
    # _tsel selects on ğ•¨; swap to use ğ•©
    ğ•¨ âŸ¨TupËœ, NumËœ, FailËœ, FailËœ, ObjËœâŸ©_tselËœ ğ•©
  }
  _cc â† { Testâ€¿Convâ€¿Fail _ğ•£:
    (Conv âŠ£ Failâ—‹ReprâŸ(Â¬TestËœ)âŸœTypeOf)âŸ(Â¬EquivâŸœTypeOf)_asCast
  }
  Cast â‡ âŸ¨
    0, !
    {!âˆ¾âŸ¨"Explicit conversion required to change ",ğ•©," to ",ğ•¨âŸ©}
  âŸ©_cc
  Promote â† âŸ¨
    Subtype, {functions.EmitâŸ¨ğ•¨, symbols.New "^promote", ğ•¨, ğ•©âŸ©}
    {!âˆ¾âŸ¨"Can't promote from type ",ğ•©," to non-superset ",ğ•¨âŸ©}
  âŸ©_cc
  Reinterpret â† âŸ¨
    â‰¡â—‹Width, {functions.EmitâŸ¨ğ•¨, symbols.New "^bitcast", ğ•¨, TypeOf ğ•©, ğ•©âŸ©}
    {!âˆ¾âŸ¨"Can't reinterpret type ",ğ•©," as different-width type ",ğ•¨âŸ©}
  âŸ©_cc
  IsBool â‡ (tPRIM New 'u'â€¿1)âŠ¸Equiv

  GetWidth â† "Type width must be a natural number"âŠ˜âŠ£ numbers.GetNat âŠ¢
  IncWidth â† {
    nâ†"First parameter must be a type or natural number" GetWidth ğ•¨
    tâ†TypeOf ğ•©
    (1 + n Ã—âˆ˜- Width t)â—¶âŸ¨
      !âˆ˜"Can't decrease width in promotion"
      âŠ¢
      âŸ¨
        tPRIM, "Invalid width"_getPrim ğ•¨âŒ¾(1âŠ¸âŠ‘)
        !âˆ˜"Can't increase width of non-primitive type"
      âŸ©_casesâˆ˜tâŠ¸Promote
    âŸ© ğ•©
  }
  GetQual â† {
    e â† "Quality must be 'i', 'u', or 'f'"
    n â† e symbols.From ğ•© â‹„ e!1=â‰ n
    âŠ‘n
  }
  PrimType â† "Invalid primitive type specification"_getPrim GetQualâ€¿GetWidth {ğ•ğ•©}Â¨ âŠ¢

  builtins â‡ âˆ¾Ë˜â‰âˆ˜â€¿2â¥ŠâŸ¨
    âŸ¨"cast"   ,             "promote"   ,"reinterpret"âŸ©
    âŸ¨ Cast _p2,Isâˆ˜âŠ£â—¶IncWidthâ€¿Promote _p2, Reinterpret _p2âŸ©
    âŸ¨"eltype"   ,"vcount"   ,"width"   ,"__vec"   ,"__pnt"âŸ©
    âŸ¨ VType _p1 , VCount _p1, Width _p1,   Vec _p2,   Ptr _p1âŸ©
    âŸ¨"primtype"   ,"quality","isfloat","issigned","isint"âŸ©
    âŸ¨ PrimType _e2, Quality _p1âŸ©âˆ¾{ğ•©_isQual _p1}Â¨âŸ¨'f'âŠ¸â‰¡ â‹„ 'i'âŠ¸â‰¡ â‹„ âŠ‘âˆ˜âˆŠâŸœ"iu"âŸ©
  âŸ©
  pp_u8 â‡ PtrâŸ2 @_getPrim 'u'â€¿8  # **u8, for main
}

registers â† {knameâ‡"register"
  Is â† kname â‰¡ Kind
  Transient â‡ {
    ownerâ‡functions.current â‹„ labcâ‡owner.labc
    kindâ‡kname â‹„ showsâ‡"(temp)" â‹„ typeâ‡ğ•© â‹„ fmtTypeâ‡1 â‹„ Matchesâ‡â‰¡
    nameâ†âŸ¨âŸ© â‹„ AddNameâ‡{nameâˆ¾â†©<ğ•©}
    mutâ‡0 â‹„ refâ‡0 â‹„ Useâ‡{ğ•¤â‹„ref+â†©1} â‹„ SetMutâ‡!
    ShowRegâ‡{showRegâ†©âˆ¾âŸ¨ğ•@âŸ©âˆ¾"_"âŠ¸âˆ¾Â¨(ref=1)/name}
  }
  Declare â‡ { name ğ•Š typeâ€¿val:
    ownerâ‡functions.current â‹„ labcâ‡owner.labc
    kindâ‡kname â‹„ showsâ‡name â‹„ typeâ‡ â‹„ fmtTypeâ‡1 â‹„ Matchesâ‡â‰¡
    addNameâ‡@ â‹„ {ğ•©.AddName name}âŸIs val
    mutâ‡0 â‹„ refâ‡0 â‹„ Useâ‡{ğ•¤â‹„ref+â†©1}
    SetMutâ‡{ğ•¤â‹„mutâ†©1}  # Changed (for blocks, and transient elimination)
    ShowRegâ‡{showRegâ†©ğ•©}âˆ˜{
      Is val? Â¬val.mut? (Â¬mut)âˆ¨1=val.ref? labc=val.labc?
        ref+â†©val.ref-1 â‹„ val.ShowRegğ•© ;
      âˆ¾âŸ¨ğ•@,"_",nameâŸ©
    }
  }
  Mutable â‡ { Is ğ•© ? {!}â‰¢ğ•©.setMut ; 0 }
  Mutated â‡ { Is ğ•© ? ğ•©.mut ; 0 }
  MarkUse â‡ {ğ•©.Use@}âŸIs
  CheckAppend â‡ { "Register used outside its owning function"!ğ•¨â‰¡ğ•©.owner }âŸ(IsâŠ¢)
}
constants â† {knameâ‡"constant"
  New â‡ {
    kindâ‡kname â‹„ typeâ‡ğ•¨ â‹„ valueâ‡ğ•©
    showsâ‡âˆ¾"!:"âˆ¾Â¨ReprÂ¨ğ•©â€¿ğ•¨ â‹„ fmtTypeâ‡0 â‹„ Matchesâ‡â‰¡
  }
  Static â‡ {
    kindâ‡kname â‹„ typeâ€¿handleâ‡ğ•©
    showsâ‡"$c"âˆ¾(("_"âˆ¾ğ•¨)âŠ£"")âˆ¾Ëœâ€¢Repr handle â‹„ fmtTypeâ‡1 â‹„ Matchesâ‡â‰¡
  }
  Undefined â‡ {
    kindâ‡kname â‹„ typeâ‡ğ•¨âŠ¢âŠ˜(types.PtrâŠ¢)ğ•© â‹„ fmtTypeâ‡0 â‹„ Matchesâ‡â‰¡
    showsâ‡âˆ¾âŸ¨"?",(â€¢Reprğ•¨)âŠ£"",":",Repr typeâŸ©
  }
  Exportable â‡ (knameâ€¿"function"âŠ¸âŠâŒ¾< Kind)â—¶{"?:"â‰¢2â†‘ğ•©.shows}â€¿1â€¿0
}

labels â† {knameâ‡"label"
  New â‡ { kindâ‡kname â‹„ showsâ‡"l"âˆ¾â€¢Reprğ•© â‹„ Matchesâ‡â‰¡ }
}
symbols â† {knameâ‡"symbol"
  Is â† kname â‰¡ Kind
  From â‡ {Is _asrtGotSâŸœ(ğ•©Ë™) ğ•¨ â‹„ ğ•©.symstr}
  M â† Isâˆ˜âŠ¢_and_(â‰¡â—‹From)
  Enc â† "'"(âˆ¾âˆ¾âŠ£)âŠ¢+128Ã—' 'âŠ¸= # Space to non-breaking space
  New â‡ { kindâ‡kname â‹„ symstrâ‡ğ•© â‹„ Showsâ‡Encâˆ˜symstr â‹„ Matchesâ‡M }
}

functions â† {knameâ‡"function"
  currentâ‡nofnâ†{
    Appendâ‡NextLabelâ‡Returnâ‡SetArchâ‡!âˆ˜"No function active"
    archâ‡architecture.init â‹„ labcâ‡0
  }
  New â† {ğ•¤
    kindâ‡kname â‹„ Matchesâ‡â‰¡ â‹„ Typeâ‡!âˆ˜"Explicit function result type needed"
    idâ‡ğ•© â‹„ showsâ‡("$f"âˆ¾(â€¢Repr id)âˆ¾"_"âŠ¸âˆ¾âŸ(0<â‰ )ğ•¨)âŠ£"$main"
    archâ‡architecture.NewFunction@ â‹„ SetArchâ‡{archâ†©ğ•©}
    labelâ†Â¯1 â‹„ slabelâ†âŸ¨âŸ© â‹„ argsâ†atypesâ†ctypesâ†âŸ¨âŸ© â‹„ rTypeâ‡@
    labcâ‡0 â‹„ IncLabâ‡{ğ•Š:labc+â†©1}  # Labels set: don't alias through label
    NextLabelâ‡{ğ•¤â‹„ labels.New label+â†©1 }
    UseSymLabelâ‡{
      âˆŠâŸœslabelâŒ¾<ğ•© ? !âˆ¾"Label "â€¿ğ•©â€¿" used in this function already" ;
      slabelâˆ¾â†©<ğ•© â‹„ ğ•©
    }
    NextArgâ‡{ nameâ€¿gather ğ•Š type:
      a â† (name registers.Declare â‹ˆâŸœ@)âš‡0 types.Unpack type
      atypesâˆ¾â†©<type â‹„ ctypesâˆ¾â†©gatherâ—¶<â€¿types.Ungather type â‹„ argsâˆ¾â†©<a
      a
    }
    âŸ¨Push,ArrâŸ©â†MakeStack@
    Instrsâ‡Arr
    Appendâ‡{ current registers.CheckAppendÂ¨ 1â†“ğ•© â‹„ Pushğ•© â‹„ @ }
    SetRTypeâ‡{
      SetRTypeâ†©!âˆ˜0 â‹„ "Result" types.ReqTyp rTypeâ†©ğ•©
      type â†© ctypes types.Fun rType
    }
    _ret_â†{
      Void â† types.IsVoid
      r â† rType â‰¢âŸœ@â—¶âŸ¨ğ”½âˆ˜âŠ¢, Voidâˆ˜âŠ£â—¶âŸ¨types.Cast,âŠ‘types.primTypesË™âŸ©âŸ© ğ•©
      ğ•˜â—¶âŸ¨Â¬Void,1âŸ© rType ? Append âŸ¨"ret", râŸ© ; @
    }
    Returnâ‡{
      A â† !âˆ˜"Early return from function with no explicit result type"
      A _ret_ 1 @âŠ£Â´ğ•©
      {Showsâ‡!âˆ˜"Can't use return result as value"â‹„kindâ‡"error"}
    }
    Finishâ‡{
      e â† "Explicit function result type needed, as result is untyped"
      e IsTyped _asrtGotS ğ•©
      SetRtype TypeOf ğ•©â‹„ğ•©
    } _ret_ 0
    Protâ‡{ğ•Š showReg:
      ext â† (0<â‰ )â—¶âŸ¨âŸ©â€¿(â‹ˆÂ·'+'âŒ¾âŠ‘Â·âˆ¾','âŠ¸âˆ¾Â¨) architecture.ListExt arch
      at â† âˆ¾ args {IsTupğ•¨ ? âˆ¾ğ•¨ğ•ŠÂ¨ğ•© ; â‹ˆâŸ¨ShowRegğ•¨,Reprğ•©âŸ©}âŸœtypes.UnpackÂ¨ atypes
      1â†“âˆ¾" "âŠ¸âˆ¾Â¨âŸ¨1â†“shows,Repr rTypeâŸ©âˆ¾((<âˆ˜â€¢Reprâˆ˜â‰ âˆ¾âˆ¾)at)âˆ¾ext
    }
  }
  _with_ â‡ {
    # ğ•¨ passed in by nodes.Define if not main, pretty hacky
    fsâ†current
    fâ†currentâ†©(1âŠ‘ğ•¨) program.AddFunction new
    {(âŠ‘ğ•©).Set f} ğ•¨
    f (f.Finish ğ”½)program._trace_ ğ•˜ ğ•©
    currentâ†©fs
    f
  }
  NextArg â‡ { ğ•¨ current.NextArg ğ•© }
  Label â‡ { current.NextLabel ğ•© }
  UseSymLabel â‡ { current.UseSymLabel ğ•© }
  Append â† { current.Append ğ•© }
  _appendReg â† { (1âŠ¸âŠ‘âŠ£Append) âŸ¨"new",ğ”½ğ•¨âŸ©âˆ¾{kindâ‡@â‹„showsâ‡ğ•©}âŒ¾âŠ‘ğ•© }
  AppendNew â† registers.Transient _appendReg
  Return â‡ { current.Return ğ•© }
  GetArch â† {ğ•Š: current.arch }
  SetArch â† { current.SetArch ğ•© }
  Emit â‡ { (âŠ‘ğ•©) AppendNew "emit" <âŠ¸âˆ¾ ğ•© }
  Array â‡ {
    Â¬âˆ¨Â´("register"â‰¡Kind)Â¨ğ•© ? ğ•¨ constants.New ğ•© ;
    ğ•¨ AppendNew "array"â€¿ğ•¨ âˆ¾ ğ•©
  }
  Declare â‡ {
    currentâ‰¡nofn ? ğ•¨ program.AddConstant ğ•© ;
    tâ†TypeOfğ•© â‹„ ğ•¨ registers.DeclareâŸœtâ€¿ğ•© _appendReg "val"â€¿tâ€¿ğ•©
  }
  _destructure â† {
    0â‰ â€¢Typeğ•© ? ğ•¨ğ”½âš‡0ğ•©;
    "Single assignment target but multiple values" ! 0=â€¢Typeğ•¨
    "Assignment tuple length mismatch" ! ğ•¨ â‰¡â—‹â‰¢ ğ•©
    ğ•¨ğ•ŠÂ¨ğ•©
  }
  Mut  â‡ {
    "Can't assign to non-register" registers.Mutable _asrtGotS ğ•¨
    Append "mut"â€¿ğ•¨â€¿(ğ•¨.type types.Cast ğ•©)
    ğ•¨.SetMut@
    ğ•¨
  }_destructure
  Call â‡ {
    f â† âŠ‘ğ•©
    "Calling non-function" IsTyped _asrtGotS f
    aâ€¿t â† (TypeOf f) types.FnCast 1â†“ğ•©
    t AppendNew âŸ¨"call",t,fâŸ© âˆ¾ â‰ âŠ¸âˆ¾ {IsTupğ•© ? âˆ¾ğ•ŠÂ¨ğ•© ; âŸ¨ğ•©âŸ©} a
  }
  _instr â† { Append (ğ•¨ğ”½ğ•©)<âŠ¸âˆ¾ğ•¨â‹ˆğ•© â‹„ ğ•© }
  SetLabel â‡ "lbl"_instr âŠ£ { current.IncLab ğ•© }
  Goto     â‡ "goto"âŠ˜"gotoT"_instr
  GotoF    â‡ "gotoF"_instr
  ReadLabel â† {
    l â† "Label or symbol expected" symbols.From ğ•©
    symbols.New "l_" âˆ¾ UseSymLabelâŸğ•¨ l
  }âŸ("label"â‰¢Kindâˆ˜âŠ¢)
  builtins â‡ â‰> âŸ¨
    âŸ¨"call",Call _v1âŸ©, âŸ¨"emit",Emit _v2âŸ©, âŸ¨"return",ReturnâŸ©
    âŸ¨"makelabel",LabelâŸ©, âŸ¨"goto",(Goto 0âŠ¸ReadLabel) _p1âŸ©
    âŸ¨"setlabel",(SetLabel 1âŠ¸ReadLabel) _p1 â‹ˆâˆ˜LabelâŸ(0=â‰ )âŸ©
  âŸ© âˆ¾ { Newâ€¿Unionâ€¿Hasâ€¿List â† architecture â‹„ Sâ†SetArch â‹„ Gâ†GetArch â‹„ âŸ¨
    âŸ¨"setarch",S NewâŸ©
    âŸ¨"addarch",S G Union NewâŸ©
    âŸ¨"hasarch",GâŠ¸HasâŸ©
    âŸ¨"listarch",symbols.NewÂ¨Listâˆ˜GâŸ©
  âŸ©}
}

blocks â† {
  New â‡ {ğ•Š indâ€¿ptrsâ€¿bodyâ€¿lsâ€¿e:
    {
      "Wrong number of pointer arguments to @for body" ! ptrsâ‰¡â—‹â‰ 1âŠ‘ğ•©
      r â† body.Eval be â† âŸ¨â‰ ind,ls,ğ•©,ptrsâŸ© env.Block e
      be.Stores @
      r
    }_e2
  }
}

MemoMap â† {ğ•¤
  argsâ†resâ†archesâ†âŸ¨âŸ© â‹„ ANâ†architecture.SeeNext
  SetArgs â‡ { argsâˆ¾â†©<ğ•© â‹„ archesâˆ¾â†©<AN@ â‹„ ğ•© }
  SetRes â‡ { resâˆ¾â†©<ğ•© â‹„ ğ•© }
  _cached â‡ {
    i â† (ğ•©âŠ¸((=â—‹â‰ )â—¶âŸ¨0,âˆ§Â´MatchÂ¨âŸ©)Â¨args) âˆ§ archesâ‰¡Â¨<AN@
    âˆ¨Â´i ? (âŠ‘/i)âŠ‘res ; ğ”½ğ•©
  }
  _memoize â‡ { SetResâˆ˜ğ”½âˆ˜SetArgs _cached }
}

builtins â† {
  # Parameter checking
  _exp_ â† {
    Il â† 1â†“Â·â¥Š<âŠ¸(â‰Ë˜)
    num â† ğ•—âŠ"zero"â€¿"one"â€¿"two"â€¿"three"
    err â† âˆ¾" " Il "Expected" <âŠ¸âˆ¾ ("or" Il num) âˆ¾âŸœ< "parameters"
    ğ”¾âŠ£ err ({ğ•âˆ¨ğ•}Â´{ğ•âŠ¸=}Â¨ğ•—)_asrtGotR â‰ 
  }
  AsTup â† { # Returns tuple and a function to go back to original kind
    IsTup ğ•© ? ğ•©â€¿âŠ¢ ;
    "type" â‰¡ Kind ğ•© ? âŸ¨ğ•¨ types.TupFrom ğ•©, types.TupâŸ© ;
    âŸ¨ğ•¨ symbols.From ğ•©, symbols.NewâŸ©
  }
  MustBe â† âˆ¾âŸœ"arameter must be a "âŠ¸âˆ¾
  _req_ â† {(ğ•© MustBe ğ•˜) ğ”½ _asrtGotS âŠ¢}
  AsTupPâ€¿AsTup0 â† {(ğ•© MustBe "tuple or symbol")âŠ¸AsTup}Â¨ "P"â€¿"First p"
  âŸ¨RT0âŸ© â† ("type"â‰¡Kind)_req_"type"Â¨ âŸ¨"First p"âŸ©
  RGPâ€¿RG0â€¿RGL â† IsGen _req_"generator"Â¨ "P"â€¿"First p"â€¿"Last p"
  âŸ¨RL1âŸ© â† IsTup _req_"tuple"Â¨ âŸ¨"Second p"âŸ©
  âŸ¨Symâ‡New,FromSymâ‡FromâŸ© â† symbols
  SymP â† ("P" MustBe "symbol")âŠ¸FromSym
  ReqSym â† "Expected symbol"âŠ¸FromSym

  Kinds â† {
    E â† "Unhandled type" ! 0Ë™
    (e{kâ€¿oâ†ğ•¨â‹„âˆ§â—‹(kâ‰¡âŠ¢)â—¶âŸ¨ğ•,OË™âŸ©}Â´ğ•©){oâ†ğ•¨ğ”½â—‹Kindğ•©â‹„ğ•¨Oğ•©}
  }
  Ty2 â† {ğ•âš‡0 _p2}âˆ˜Kinds âŠ£âˆ¾âŸœ(<Â·"symbol"âŒ¾âŠ‘âŠ¢Â´)âˆ˜âŠ¢âŸ(âŠ‘âˆŠâŸœ=â€¿â‰ )"number"â€¿"type"â‹ˆÂ¨{ğ•numbers._cmp}âŠ¸â‹ˆ
  Merge â† {
    0<(0=â‰ ğ•©)âŒˆÂ´=Â¨ğ•© ? âˆ¾ğ•© ;
    âˆ§Â´("type"â‰¡Kind)Â¨ğ•© ? types.Merge ğ•© ;
    mâ†"Parameters must include a tuple, or be all types or all symbols"
    Sym âˆ¾ mâŠ¸FromSymÂ¨ğ•©
  }
  Slice â† 2â€¿3 _exp_ {
    lâ€¿Ret â† AsTup0 âŠ‘ğ•©
    iâ†lâ‰ âŠ¸(0âŒˆâŠ£âŒŠ+âŸ(0âŠ¸>)Â¨)numbers.GetIntÂ¨1â†“ğ•© â‹„ Ret (âŠ‘i)â†“(1â†“i)â†‘Â´Ëœl
  }
  Select â† { arg ğ•Š ind:
    lâ€¿Wrap â† AsTup0 arg
    sm â† "Indices must be a flat tuple when selecting from a symbol"
    { argâ‰¢l ? "symbol"â‰¡Kind arg ? sm (1=â‰¡)_asrtGotS ind ; @}
    (numbers.GetIntâŠ‘lË™){IsTup ğ•©? Wrap ğ•ŠÂ¨ğ•© ; ğ”½ğ•©} ind
  }_p2
  UD â† constants.Undefined{(1<â‰ )â—¶âŸ¨ğ”½âŠ‘,ğ”½ËœâŸœnumbers.GetNatÂ´âŸ©}
  Undefined â† 1â€¿2 _exp_ (UD âŠ£ RT0âˆ˜âŠ‘)
  # Load/store
  AccessPtr â† {
    t â† types.Deref TypeOf ğ•©
    "Can't access void pointer" (Â¬types.IsVoid t)_asrtGotS ğ•©
    t
  }
  GetIndex â† {
    "number"â‰¡Kindğ•© ? numbers.GetInt ğ•© ;
    IsTypedğ•© ? types.IsInt ğ•© ? ğ•© ;
    "Index must be numeric" 0 _asrtGotS ğ•©
  }
  Load â† { ğ•Š ptrâ€¿i  : functions.Emit âŸ¨AccessPtr ptr, Sym "^load",  ptr, GetIndex iâŸ© } _e2
  Storeâ† { ğ•Š ptrâ€¿iâ€¿v: tâ†AccessPtr ptr â‹„ functions.Emit âŸ¨types.void, Sym "^store", ptr, GetIndex i, vcâ†t types.Cast vâŸ© â‹„ vc } _e3

  namesâ€¿values â‡ <Ë˜âˆ¾â‰âŸ¨
    ReprÂ¨âŠ¸â‰ types.primTypes
    â‰> âŸ¨
      âŸ¨"__set",functions.Mut _p2âŸ©
      âŸ¨"show",(1â‰ â‰ )â—¶âŠ‘â€¿{Showsâ‡!âˆ˜"Multiple show used improperly"â‹„kindâ‡"error"}âŠ£â€¢Outâˆ˜ShowMultiâŸ©
      âŸ¨"is",Match _p2âŸ©, âŸ¨"hastype",1â€¿2 _exp_ ((1â‰ â‰ )â—¶âŸ¨IsTypedâŠ‘, HasTypeÂ´âŸ©)âŸ©
      âŸ¨"undefined",UndefinedâŸ©, âŸ¨"load",LoadâŸ©, âŸ¨"store",StoreâŸ©
      âŸ¨"type",TypeOf _p1âŸ©, âŸ¨"kind",Sym Kind _p1âŸ©
      âŸ¨"typekind",Sym types.TypeKind _p1âŸ©, âŸ¨"tuptype",types.TupâŸ©
      âŸ¨"tup",âŠ¢âŸ©, âŸ¨"select",SelectâŸ©, âŸ¨"length",(â‰ âŠ‘âˆ˜AsTupP)_p1âŸ©
      âŸ¨"merge",MergeâŸ©, âŸ¨"slice",SliceâŸ©, âŸ¨"range",â†•numbers.GetNat _p1âŸ©
      âŸ¨"symchars",(Symâˆ˜â‹ˆÂ¨SymP)_p1âŸ©
      âŸ¨"fmtnat",Symâˆ˜â€¢Repr numbers.GetNat _p1âŸ©
      âŸ¨"bind",âŠ‘RG0âŠ¸{ğ•_neğ•©âŠ¸âˆ¾}1âŠ¸â†“_v1âŸ©, âŸ¨"each",âŠ‘{ğ•Â¨_ne<Ë˜â‰>ğ•©}1âŠ¸â†“_v2âŸ©
      âŸ¨"apply",RG0âŠ¸{ğ•_neğ•©}âŸœRL1 _p2âŸ©
      âŸ¨"export",{ğ•¨ ReqSymâŠ¸program.Exportâš‡0 ğ•©}_p2âŸ©
      âŸ¨"require",{program.Requireâˆ˜ReqSymâš‡0 ğ•©}âŸ©
      âŸ¨"witharch",architecture.WithâŸ©
      âŸ¨"withenv",{eâ†program.envâ‹„e.Push 2â†‘ğ•©â‹„râ†âŸ¨âŸ©{ğ•_neğ•©}ËœRGL 2âŠ‘ğ•©â‹„e.Pop@â‹„r}_e3âŸ©
      âŸ¨"getenv",{program.env.Get ğ•©}_p1âŸ©
      âŸ¨"memoize",({ğ• (MemoMap@)._memoize} RGP)_p1âŸ©
      # Deprecated
      âŸ¨"tupsel",numbers.GetIntâŠ¸âŠ‘âš‡0â€¿âˆ _p2 âŠ£ â€¢Outâˆ˜"tupsel{} is deprecated; use select{}"âŸ©
      âŸ¨"tuplen",â‰ _p1 âŠ£ â€¢Outâˆ˜"tuplen{} is deprecated; use length{}"âŸ©
    âŸ©
    functions.builtins
    numbers.builtins
    types.builtins
    >âŸ¨
      "__eq"â€¿"__ne"â€¿"__lt"â€¿"__gt"â€¿"__le"â€¿"__ge"
      =â€¿â‰ â€¿<â€¿>â€¿â‰¤â€¿â‰¥ Ty2Â¨ âŸ¨Match,Â¬MatchâŸ© âˆ¾ Â·â¥Šâ‰Ë˜âŸœ({ğ•Ëœ}Â¨) âŸ¨types.SSubtype,types.SubtypeâŸ©
    âŸ©
  âŸ©
  _ne â† {ğ”½âŠ{ğ•Š:!":"âˆ¾â€¢CurrentError@}} # Protect error from ReErr if builtin runs generator
  ReErr â† {! (':'â‰ âŠ‘)â—¶âŸ¨1âŠ¸â†“, ğ•© âˆ¾ (âˆ¨`':'âŠ¸=>Â·âˆ¨`'('âŠ¸=)âŠ¸(âˆ¨Â´âˆ˜âŠ£â—¶âŸ¨": "âŠ¸âˆ¾,/âŸ©)âŸ© â€¢CurrentError@}
  values {nâ†ğ•¨â‹„ğ•âŠ(ReErrâˆ˜n)âŠ˜{nameâ‡n}}âŸ(3=â€¢Typeâˆ˜âŠ¢)Â¨Ëœâ†© names
}

var â† {
  Getâ‡{ğ•©.Get ğ•¨}
  Fixedâ‡{ kindâ‡"var" â‹„ Getâ‡ğ•©Ë™ }
  Newâ‡{ğ•Š: NGâ†"generator"â‰¢Kind â‹„ kindâ‡"var"
    Getâ‡{! program._trace_ ğ•© "Variable definition not yet reached"}
    Setâ‡{
      {ğ•Š:Setâ†©!âˆ˜"Can't extend a non-generator"}âŸNG ğ•©
      Get â†© ğ•©Ë™
      ğ•©
    }
  }
}
GenUnhandled â† !âˆ˜"Unhandled case"
scopes â† {
  noLambda â† var.Fixed genUnhandled
  nullâ†{Getâ‡{ErrâŸ¨"Undefined name: "âˆ¾ğ•©,ğ•¨âŸ©} â‹„ GetLamâ‡noLambdaË™}
  Newâ‡{
    pâ†@Â¨nâ†ğ•¨âŠ£âŸ¨âŸ© â‹„ Namesâ‡{ğ•¤â‹„n}
    parent â‡ ğ•©  # For nonlocal
    Sel â†{ğ•©âŠ‘env.Vars}
    Makeâ†{câ†â‰ nâ‹„pâ€¿nâˆ¾âŸœ<Â¨â†©ğ•©â‹„c}
    Dup â†{ErrâŸ¨"Duplicate definition:",âŠ‘ğ•©,"Previously defined here:",ğ•¨âŠ‘pâŸ©}
    Par â†{ğ•âˆ˜env.Parent}
    _find â† { (nâŠ¸âŠâŒ¾<ğ•©) =âŸœ(â‰ n)â—¶ğ•— ğ•¨â€¿ğ•© }
    Get â‡ âŸ¨SelâŠ£, Par ğ•©.GetÂ´âˆ˜âŠ¢âŸ© _find
    Add â‡ Sel Dupâ€¿Make _find
    Lam â† ParâŸ(noLambdaâŠ¸â‰¢) ğ•©.GetLamÂ´âˆ˜âŠ¢
    AddLam â‡ âŸ¨â‹ˆËœSelâˆ˜âŠ£, Lamâ‹ˆSelâˆ˜MakeâŸ© _find
    GetLam â‡ âŸ¨SelâŠ£, LamâŸ© _find
  }
  Initâ‡New nullË™

  queue â† âŸ¨âŸ©
  _defer â‡ { queueâˆ¾â†©<ğ”½â€¿ğ•© }
  _run â‡ {
    ğ”½ _defer ğ•©
    _while_ â† {ğ”½âŸğ”¾âˆ˜ğ”½_ğ•£_ğ”¾âˆ˜ğ”½âŸğ”¾ğ•©}
    {ğ•Š:dâ†âŠ‘queueâ‹„queueâ†“Ëœâ†©1â‹„{ğ•ğ•©}Â´d}_while_{ğ•Š:0<â‰ queue} @
  }
}
env â† {
  Vars  â‡{ğ•©.vars}
  Parentâ‡{ğ•©.parent}
  Make â†{ varsâ‡ğ•¨ â‹„ parentâ‡ğ•© }
  Aliasâ‡Make
  New  â‡{ (var.NewÂ¨   ğ•¨) Make ğ•© }
  Fixedâ‡{ (var.FixedÂ¨ ğ•¨) Make ğ•© }
  Blockâ‡{âŸ¨ni,Loadâ€¿Store,indâ€¿ptrs,namesâŸ© ğ•Š par:
    Reg â† "register"â‰¡Kind
    pv â† names functions.DeclareâŸ(RegâŠ¢)âš‡âˆâ€¿0âŸœ(Loadâˆ˜â‹ˆâŸœind)Â¨ ptrs
    varsâ€¿parent â‡ (var.FixedÂ¨(niâ¥Š<ind)âˆ¾pv) Make par
    Stores â‡ {ğ•¤
      ptrs {IsTup ğ•© ? ğ•¨ğ•ŠÂ¨ğ•© ; registers.Mutated ğ•© ? Store ğ•¨â€¿indâ€¿ğ•© ;@}Â¨ pv
    }
  }
}

program â† {
  AddFunctionâ‡AddConstantâ‡Exportâ‡Requireâ‡!âˆ˜0 â‹„ envâ‡traceâ‡@
  _with â‡ {
    fnsâ†âŸ¨âŸ© â‹„ AddFunction â†© { f â† ğ•¨ ğ• â‰ fns â‹„ fnsâˆ¾âŸœ<â†©f â‹„ f }
    cnsâ†âŸ¨âŸ© â‹„ AddConstant â†© { c â† ğ•¨ constants.Static âŸ¨tâ†TypeOfğ•©, â‰ cnsâŸ© â‹„ cnsâˆ¾âŸœ<â†©âŸ¨Repr c,t,ğ•©âŸ© â‹„ c }
    expâ†âŸ¨âŸ© â‹„ Export â†© { CheckExport ğ•© â‹„ exp âˆ¾âŸœ<â†© ğ•¨â€¿ğ•© }
    reqâ†âŸ¨âŸ© â‹„ Require â†© { req âˆ¾âŸœ<â†© ğ•© }
    env â†© DynamicEnv@
    âŸ¨_trace_âŸ©â†©sâ†Stack@
    ğ•¨ ğ”½âŠs.Report ğ•©
    AddFunctionâ†©AddConstantâ†©Exportâ†©Requireâ†©!âˆ˜0 â‹„ envâ†©traceâ†©@
    âˆ¾ âŸ¨DispHeaderÂ¨req, DispConstants cns, âˆ¾DispFunctionÂ¨fns, DispExportÂ¨expâŸ©
  }
  CheckExport â† {
    "Exports must be typed" IsTyped _asrtGotS ğ•©
    "Exports must be global fixed values" constants.Exportable _asrtGotS ğ•©
  }
  Stack â† {ğ•¤
    âŸ¨_trace_â‡_while_âŸ© â‡ âŸ¨Dumpâ‡ArrâŸ© â† MakeStack@
    Report â‡ {ğ•¤
      â€¢Out (âˆ§`lfâŠ¸â‰ )âŠ¸/âŠâ€¢Repr â€¢CurrentError@
      â€¢Out ""
      # DispSourceÂ¨ âŒ½ Dump@
      # ^ would be the easy way, but we want to compress repeats
      l â† â‰ s â† Dump@
      n â† (â†•l)-Ëœ lâŠ¸=âŠ¸+ â·âŠ¸(âŠ£â‰ âŠ¸â†“âŠ¢âŠ’âˆ¾)âŠs  # Distance to next repetition
      n âŠËœâ†© i â† /Â»âŠ¸â‰ n                 # Split into blocks of equal distance
      e â† n+lÂ«i                       # Last possible endpoint
      Sc â† {ğ•¨ğ•Šnâ€¿iâ€¿e:e-n|âŸ(+ËœâŠ¸â‰¤)e-ğ•¨âŒˆi} # Full reps (if â‰¥2) not overlapping previous
      i âŒˆâ†©Â» e â†© 0 Sc` <Ë˜â‰>âŸ¨n,i,eâŸ©     # Adjust start and end
      iâ€¿nâ€¿e (i<e)âŠ¸/Â¨â†©                 # Filter out empties
      f â† i+n                         # End of displayed reps
      df â† {DispSource ğ•©Ë™}Â¨ s
      rt â† (1<n) ("Repeated "âˆ¾â€¢Reprâˆ˜âŠ¢âˆ¾" times:"âˆ¾/âŸœ" {{{")Â¨ (e-i)Ã·n
      df rtâŠ¸({ğ•âŠ£Â·â€¢Outğ•¨Ë™}Â¨)âŒ¾((f-1)âŠ¸âŠ)â†©
      df {â€¢Outâˆ˜("}}}"âˆ¾@+10)âŠ¢ğ•}Â¨âŒ¾((i/Ëœ1<n)âŠ¸âŠ)â†©
      {ğ•@}Â¨ âŒ½ df /Ëœ 1â‰ `eâ‰ â—‹(lâ†‘/â¼)f     # Remove extra iterations
      â€¢Exit 1
    }
  }
  DynamicEnv â† {ğ•¤
    stack â† @
    Sym â† "Environment label must be a symbol"âŠ¸symbols.From
    Pushâ‡ {   stack â†© ğ•©â€¿stack} SymâŒ¾âŠ‘
    Pop â‡ {ğ•Š: stack â†© 1âŠ‘stack}
    Get â‡ {
      ğ•Šğ•©:stackğ•Šğ•© ;
      @â‰¡ğ•¨? !âˆ¾"Environment value "â€¿ğ•©â€¿" hasn't been set" ;
      ğ•©â‰¡âŠ‘vâ†âŠ‘ğ•¨? 1âŠ‘v ; (1âŠ‘ğ•¨)ğ•Šğ•©
    } Sym
  }
  J â† 1â†“Â·âˆ¾" "âŠ¸âˆ¾Â¨
  DispHeaderâ†{ "require " âˆ¾ "'"(âˆ¾âˆ¾âŠ£)ğ•© }
  DispConstantsâ†{ âˆ¾âŸœ(<âŸ¨âŸ©)âŸ(0<â‰ ) (J"constant"<âŠ¸âˆ¾ReprÂ¨âŒ¾(1âŠ¸â†“))Â¨ ğ•© }
  DispFunctionâ†{
    ShowReg â† {hâ†Â¯1â‹„{ğ•Š:"v"âˆ¾â€¢Repr h+â†©1}}{ğ•©.ShowRegğ•—}
    ProcInstrs â† {
      # Mark each register with the number of times it's used after definition
      (registers.MarkUseÂ¨(1+âŠâˆŠ"new"â€¿"mut"Ë™)â†“âŠ¢)Â¨ ğ•©
      # Combine new into next mut call if that's the only use
      nm â† / âˆ§âŸœÂ«Ë "new"â€¿"mut" â‰¡âŒœ âŠ‘Â¨ğ•©
      nm (â‰¡â—¶0â€¿{1=ğ•©.ref}Â¨Ë1â€¿2âŠ‘Â¨ğ•©âŠËœ0â€¿1+âŒœâŠ¢)âŠ¸/â†©
      ğ•© â†© (Â¬(â‰ ğ•©)â†‘/â¼1+nm) / (1âŒ½ğ•©) (âŠ£âŒ¾(2âŠ¸â†‘)Â¨âŒ¾(nmâŠ¸âŠ)) ğ•©
      # Convert to names, performing register numbering
      ğ•© ("register"â‰¡Kind)â—¶Reprâ€¿ShowRegÂ¨âŒ¾(1âŠ¸â†“)Â¨â†©
      # Registers are aliased when possible, leading to no-op new
      # instructions removed here
      {"new"â‰¡âŠ‘ğ•© ? "val"â‰¡2âŠ‘ğ•© ? â‰¡Â´1â€¿4âŠğ•© ? 0 ; 1}Â¨âŠ¸/ ğ•©
    }
    âˆ¾âŸ¨
      âŸ¨"beginFn "âˆ¾ğ•©.Prot showRegâŸ©
      JÂ¨ ProcInstrs ğ•©.Instrs@
      âŸ¨"endFn",""âŸ©
    âŸ©
  }
  DispExportâ†{ "export " âˆ¾ J (<"'"âŠ¸(âˆ¾âˆ¾âŠ£))âŠ¸âˆ¾âŸœ(TypeOfâ‹ˆâ—‹ReprâŠ¢)Â´ ğ•© }
}

nodes â† {
  # Node operations
  o â† {
    Verify â‡ {ğ•©.node}
    Dump â‡ {ğ•©.Dump@}
    Disp â‡ {ğ•©.Disp@}
    Oper â‡ {ğ•Šop :{ğ•©.Oper  op }}
    Scopeâ‡ {ğ•Šsc :{ğ•©.Scope sc }}
    Eval â‡ {ğ•Šenv:{ğ•©.Eval  env}}
  }
  Defaults â† {
    nodeâ€¿visit â‡ ğ•©
    Visit o.verify
    Dump â‡ {ğ•¤â‹„âŸ¨node,Visit o.dumpâŸ©}
    Disp â‡ {ğ•¤â‹„node <âŠ¸âˆ¾ "  "âŠ¸âˆ¾Â¨ âˆ¾âˆ¾ @ â¥Šâˆ˜<âˆ˜âŠ¢âŸ((2Ã—â‰¡)+â‰¡âŸœ@)Â¨â—‹Visit o.disp}
    Oper â‡ {Visit o.Oper  ğ•© â‹„ operator.nil}
    Scopeâ‡ {Visit o.Scope ğ•©â‹„@}
    Eval â‡ {Visit o.Eval  ğ•©}
    NonLocal â‡ âŠ¢
  }

  # Node types
  Word â‡ {
    nameâ‡ğ•© â‹„ posâ‡ğ•¨âŠ£@
    âŸ¨node,Dump,NonLocalâŸ©â‡dâ†Defaults "word"â€¿âŸ¨âŸ©
    Dispâ‡{ğ•¤â‹„âŸ¨nameâŸ©}
    Operâ‡{ğ•©.Lookup name}
    Evalâ‡!âˆ˜0 â‹„ Scopeâ‡{Evalâ†©pos var.Get (pos ğ•©.Get name){ğ”½}}
    # Modify so it defines the variable instead of getting the value
    v0â†@â‹„Vâ†!âˆ˜0 â‹„ IsDefâ‡{ğ•Š:
      âŸ¨OperâŸ©â†©d
      Scopeâ†©{
        1ğ•Šğ•©: v0â€¿v â†© pos ğ•©.AddLam name ;
        v â†© pos ğ•©.Add name
      }
      Evalâ†©{valâ€¿decl ğ•Š ğ•©: uâ†Vğ•© â‹„ u.Set nameâŠ¸functions.Declareâš‡0âŸdecl val}
    }
    {nameâ‰¢"_"?@; # _ does nothing on assignment, and errors on access
      scopeâ†©@ â‹„ Evalâ†©!âˆ˜"Can't get value of _"
      IsDefâ†©{ğ•Š:evalâ†©@â‹„Vâ†©{Setâ‡âŠ¢}Ë™}
    }
    # If fâ‰¡1, set value in Eval for function recursion
    RunEval â‡ {ğ• âŸ¨@, nameâŸ©}
    DefEval â‡ { fâ€¿ValEval ğ•Š e:
      uâ†V e â‹„ u.Set program._trace_ posâŸ(Â¬f) ValEval âŸ¨fâ—¶âŸ¨V0,uË™âŸ© e, nameâŸ©
    }
  }
  NewId â‡ {ğ•©.IsDef@â‹„ğ•©}âˆ˜Word
  _value â† {
    nameâ†ğ•© â‹„ posâ‡ğ•¨âŠ£@
    Evalâ‡(ğ•¨ğ”½ğ•©)Ë™
    âŸ¨node,Dump,NonLocal,Oper,ScopeâŸ©â‡Defaults "value"â€¿âŸ¨âŸ©
    Dispâ‡{ğ•¤â‹„âŸ¨nameâŸ©}
  }
  Number â‡ numbers.Read _value
  Symbol â‡ (symbols.New 1â†“Â¯1â†“âŠ¢)_value
  Token â‡ ('''â‰ âŠ‘âˆ˜âŠ¢)â—¶âŸ¨Symbol,(âŠ‘âŠâˆ˜âŠ¢âˆŠdigË™)â—¶Wordâ€¿NumberâŸ©
  consts â‡ {
    âŸ¨vâ‡values,nâ‡namesâŸ© â† builtins
    Make â† {ğ•©Ë™_value ğ•¨}
    callâ€¿i32â€¿vec â‡ MakeÂ¨âŸœ(vâŠËœnâŠâŠ¢) "call"â€¿"i32"â€¿"__vec"
    n0 â‡ Number "0"
    pp_u8 â‡ "**u8" Make types.pp_u8
  }
  Run â‡ {
    ğ•¨ğ•ŠâŸ¨âŸ¨Â·â‡evbâŸ©,paramsâŸ©: ğ•¨ CondOper ğ•©;
    âŸ¨caller,paramsâŸ©â†ğ•© â‹„ posâ‡ğ•¨
    spread â† 0=â€¢TypeÂ¨params â‹„ params âŠ‘Â¨â†©
    Sp â† âŠ£â—¶âŸ¨â‹ˆâŠ¢, "Spread input must be tuple" IsTup _asrtGotS âŠ¢âŸ©
    # Partial parameters .
    realpar â† params /ËœÂ¬ pp â† @âŠ¸â‰¡Â¨params
    em â† {Â¬âˆ¨Â´pp? {ğ”½};
      Proc â† (pp/spread){
        Â¬âˆ¨Â´ğ•— ? ((â‹â‹pp)âŠâˆ¾) âŠ£ (ğ•˜!(â‰ ğ•—)=â‰ âˆ˜âŠ¢) ;
        c â† +Â´ppâˆ§Â»âˆ¨`psâ†ppâˆ§spread
        i â† (â‹ˆâ¼/ps)(â†‘â‹ˆâ†“)(âŠ¢-â‰ Ã—(c-Ëœâ‰ )âŠ¸â‰¤)â‹â‹psÂ¬âŠ¸/pp
        (âˆ¾0â€¿2â€¿1âŠ(iâŠÂ¨<âˆ˜âˆ¾)âˆ¾âŸœ<(c-Ëœ0â‹ˆÂ¯1+Â´pp)â†“Â´ËœâŠ¢) âŠ£ (ğ•˜!câ‰¤â‰ âˆ˜âŠ¢)
      }"Partial and given parameter counts don't match"
      {ğ”½ ğ•©âŠ¸Proc}
    }
    DeSpread â† (pp<spread){âˆ¨Â´ğ•—? âˆ¾ğ•—SpÂ¨âŠ¢; âŠ¢}
    Visitâ†{âŸ¨ğ•caller,ğ•Â¨realparâŸ©}
    âŸ¨node,Dump,Disp,NonLocal,ScopeâŸ©â‡dâ†Defaults "run"â€¿visit
    Oper â‡ {ğ•¤â‹„ pos operator.Run âŸ¨âŠ‘Visit o.Oper ğ•©, paramsâŸ©}
    Eval â‡ {
      (3=â€¢Typeğ•¨)â—¶âŸ¨!âˆ˜"Running non-generator", ğ•âˆ˜DeSpreadâŸ© program._trace_ pos _em ğ•©
    }Â´ d.Eval
  }
  Call â‡ { ğ•¨ Run âŸ¨consts.call , <âŠ¸âˆ¾Â´ğ•©âŸ© }
  Phrase â‡ {
    thingsâ†ğ•© â‹„ posâ‡ğ•¨
    ToWordâ‡{ğ•¤â‹„ (1=â‰ )â—¶âŸ¨@,@âŸ("word"â‰¢{ğ•©.node})âŠ‘âŸ© things }
    Visitâ†{âŸ¨ğ•Â¨thingsâŸ©}
    âŸ¨node,Dump,Disp,NonLocal,Scope,EvalâŸ©â‡Defaults "phrase"â€¿visit
    Operâ‡{
      âŸ¨nodeâŸ©â†©n â† (o.Oper ğ•©)Â¨âŠ¸operator.Parse things
      Scopeâ†©{ğ•¨n.Scopeğ•©} â‹„ Evalâ†©{ğ•¨(Evalâ†©n.Eval)ğ•©} â‹„ Dispâ†©{ğ•¨n.Dispğ•©} # fields of n can change
      operator.nil
    }
  }
  PhraseTryWord â‡ {"phrase"â‰¡ğ•©.node}â—¶@â€¿{ğ•©.ToWord@}
  PhraseTryName â‡ {ğ•©.name}âŸ(@âŠ¸â‰¢)PhraseTryWord
  Target â‡ {
    posâ†ğ•¨
    namesâ€¿eqsâ€¿condsâ€¿ProcEâ€¿ProcT â† pos targetNodes.GetProcs ğ•©
    ns â† posâŠ¸NewIdÂ¨ names
    exprs â† eqs âˆ¾ conds
    Visitâ†{âŸ¨ğ•Â¨ns,ğ•Â¨exprsâŸ©}
    âŸ¨node,Dump,Disp,NonLocal,Oper,ScopeâŸ©â‡Defaults "params"â€¿visit
    VisitLambda â‡ {âŸ¨names,ğ•Â¨exprsâŸ©}
    ScopeLambda â‡ {names scopes.New ğ•©}
    GB â† "Generator condition must evaluate to boolean" numbers.GetBool âŠ¢
    GetTry â‡ {ğ•Š e:
      Try â‡ {
        0==ğ•© ? @ ; # Error from static checking
        vâ€¿q â† ğ•©
        ts â† (q {ğ•©Ë™âŠ¸Match}âŠ¸â‹ˆÂ¨ eqs) âˆ¾ GBË™âŠ¸â‹ˆÂ¨conds
        t â† {âŠ¢} {fâ€¿nğ•Šğ•©:fâŸœn.Evalâ—¶@â€¿ğ•}Â´ ts
        ğ•¨ T v env.Fixed e
      }âŸœProcT
    }
    CC â† "Destructuring condition failed" ! GB
    Eval â‡ { valâ€¿decl ğ•Š e:
      vâ€¿q â† ProcE val
      ns {ğ•©â€¿decl ğ•¨.Eval e}Â¨ v
      CQ â† {ğ•¨ Match ğ•©.Eval e? @ ; ! program._trace_ ğ•©.pos "Destructuring match check failed" }
      q CQÂ¨ eqs
      { CC program._trace_ ğ•©.pos ğ•©.Eval e }Â¨ conds
    }
    RunEval â‡ {ğ• <ns}
    DefEval â‡ { fâ€¿ValEval ğ•Š e: âŸ¨RunEval valEval,0âŸ© Eval e }
  }
  _errNoMatch â† {
    â€¢Out (âˆ¾âŸœ": "âŸ(0<â‰ )ğ•¨)âŠ¢âŠ˜âˆ¾"No matching "âˆ¾ğ•—
    ! "Parameters: "âˆ¾(0<â‰ )â—¶âŸ¨"none",ShowMultiâŸ©ğ•©
  }
  _unmatchedGen â‡ {
     n _ğ•£ğ•©: ğ•— "generator definition"_errNoMatch ğ•© ;
    ğ•¨n _ğ•£ğ•©: {nameâ‡n}
  }
  Lambda â‡ {
    âŸ¨par,resultâŸ©â†ğ•© â‹„ posâ†ğ•¨
    Visitâ†{lâ†par.VisitLambda ğ•©â‹„lâˆ¾âŸ¨ğ•resultâŸ©}  # Call par.VisitLambda first
    âŸ¨node,Dump,Disp,NonLocal,OperâŸ©â‡Defaults "lambda"â€¿visit
    Scopeâ‡{ Visit scopes._defer o.Scope par.ScopeLambda ğ•© }
    Evalâ‡{ğ•¨ ğ•Š e: # ğ•¨ is previous value and name, from Define
      name â† (1âŠ‘ğ•¨)âŠ£""
      next â† ({ğ•©.Get pos}âŠ‘ğ•¨) âŠ£âŸ(genUnhandledË™â‰¢âŠ£) {name _unmatchedGen}
      âŸ¨TryâŸ©â†par.GetTry e
      Execâ€¿_cached â† { result.nodeâ‰¢"function"?
        Exec â‡ result.Evalâˆ˜âŠ¢ â‹„ _cached â‡ {ğ”½}
      ;
        SetArgsâ€¿SetResâ€¿_cached â† MemoMap@ â‹„ cachedâ‡
        Exec â‡ {
          SetArgs ğ•¨
          n â† (128âŒŠâ‰ )âŠ¸â†‘ nameâˆ¾âˆ¾('_'âˆ¾Â·âˆŠâŸœ(digâˆ¾1â†“alph)âŠ¸/Repr)Â¨ğ•¨
          {Setâ‡SetRes}â€¿n result.Eval ğ•©
        }
      }
      {
        ğ•© @âŠ¸â‰¢â—¶âŸ¨NextâŠ£, ExecâŸ© Try ğ•©
      }_cachedâŠ˜{ğ•Š: {nameâ‡ğ•©} "(generator)"âŸ(0=â‰ ) name}
    }
  }
  Extender â‡ {
    âŸ¨names,resultâŸ©â†ğ•© â‹„ posâ†ğ•¨
    Visitâ†{namesâˆ¾âŸ¨ğ•Â¨resultâŸ©}
    âŸ¨node,Dump,Disp,NonLocal,OperâŸ©â‡Defaults "extender"â€¿visit
    Scopeâ‡{ Visit scopes._defer o.Scope names scopes.New ğ•© }
    Evalâ‡{ğ•¨ğ•Še: {
      A â† ! program._trace_ pos
      "Wrong number of parameters in extension" A namesâ‰¡â—‹â‰ ğ•©
      "Generator defined with extend must be called with extend" A âˆ§Â´ ("var"â‰¡Kind)Â¨ ğ•©
      (0<â‰ )â—¶âŸ¨emptyBody,âŠ¢Â´âŸ© result {ğ•¨.Evalğ•©}Â¨ <ğ•© env.Alias e
    }âŠ˜{ğ•Š: {nameâ‡ğ•©} "(extender)"âŸ(0=â‰ ) (1âŠ‘ğ•¨)âŠ£""}}
  }
  Extend â‡ {
    âŸ¨ext,namesâŸ©â†ğ•© â‹„ posâ†ğ•¨
    Visitâ†{âŸ¨ğ•ext,namesâŸ©}
    âŸ¨node,Dump,Disp,OperâŸ©â‡Defaults "extend"â€¿visit
    Nâ†âŠ¢ â‹„ NonLocalâ‡{ğ•Š:Nâ†©{ğ•©.parent}}
    vâ†@ â‹„ Scope â‡ { ext.Scopeğ•© â‹„ v â†© posâŠ¸(Nğ•©).AddLamÂ¨ names }
    Eval â‡ {
      slots â† {ğ•©.Set ğ•¨.Get posâ‹„ğ•©}âŸâ‰¢â—‹({ğ•ğ•©}âŸœ(Nğ•©))Â´Â¨ v
      (ext.Evalğ•©){ğ”½} program._trace_ pos slots
    }
  }
  Arg â‡ {
    âŸ¨gather,name,typeâŸ©â†ğ•© â‹„ posâ†ğ•¨
    Visitâ†{âŸ¨name,ğ•typeâŸ©}
    âŸ¨node,Dump,Disp,NonLocal,OperâŸ©â‡Defaults "arg"â€¿visit
    vâ†@ â‹„ Scopeâ‡{ type.Scope ğ•© â‹„ v â†© pos ğ•©.Add name }
    Evalâ‡{
      u â† V ğ•©
      Add â† functions.NextArgâŸœ("Argument" types._get)
      u.Set nameâ€¿gather Add program._trace_ pos type.Eval ğ•©
    }
  }
  Function â‡ {
    âŸ¨args,type,resultâŸ©â†ğ•© â‹„ posâ†ğ•¨
    Visitâ†{âŸ¨ğ•Â¨args,ğ•Â¨type,ğ•resultâŸ©}
    âŸ¨node,Dump,Disp,NonLocal,OperâŸ©â‡Defaults "function"â€¿visit
    Scopeâ‡{ Visit scopes._defer o.Scope scopes.New ğ•© }
    Evalâ‡{
      evâ†o.Eval args env.New ğ•©
      EvÂ¨ args
      ğ•¨.SetRTypeâˆ˜EvÂ¨ type
      Ev result
    } functions._with_ pos
  }
  Main â‡ {
    ty â† consts.i32â€¿consts.pp_u8
    ğ•¨ Function âŸ¨(â‰ â†‘tyË™)(ğ•¨Arg{âŸ¨0,ğ•©,ğ•@âŸ©})Â¨âŠ¢, WordÂ¨, âŠ¢âŸ© {ğ•ğ•©}Â¨ ğ•©
  }
  _setType â† { pos typeâ€¿env _ğ•£ v:
    { â‰ type ?
      t â† "Variable" types._get (âŠ‘type).Eval ğ•©
      t types.Cast v
    ;
      "Explicit type needed for untyped initial value" {=ğ•©?âˆ§Â´ğ•ŠÂ¨ğ•©;IsTypedğ•©} _asrtGotS v
      v
    } program._trace_ pos env
  }
  Declare â‡ {
    âŸ¨name,type,valueâŸ©â†ğ•© â‹„ posâ†ğ•¨
    Visitâ†{Â¯1âŒ½âŸ¨":",ğ•Â¨type,ğ•value,ğ•nameâŸ©}
    âŸ¨node,Dump,Disp,OperâŸ©â‡Defaults "declare"â€¿visit
    Nâ†âŠ¢ â‹„ NonLocalâ‡{ğ•Š:Nâ†©{ğ•©.parent}}
    Scopeâ‡{ {ğ•Â¨type â‹„ ğ•value} o.Scope ğ•© â‹„ name.Scope N ğ•© }
    Evalâ‡{ vâ†pos typeâ€¿ğ•© _setType value.Eval ğ•© â‹„ vâ€¿1 name.Eval N ğ•© }
  }
  Define â‡ {
    âŸ¨name,valueâŸ©â†ğ•© â‹„ posâ†ğ•¨
    value no_defË™âŸ(@âŠ¸â‰¡)â†©
    Visitâ†{âŸ¨ğ•name,ğ•valueâŸ©}
    âŸ¨node,Dump,Disp,OperâŸ©â‡Defaults "define"â€¿visit
    Nâ†âŠ¢ â‹„ NonLocalâ‡{ğ•Š:Nâ†©{ğ•©.parent}}
    Scope â‡ {
      value.Scope ğ•©
      ("lambda"â‰¡value.node) name.Scope N ğ•©
    }
    Evalâ‡{
      âŸ¨"function"â‰¡value.node, value.EvalâŸœğ•©âŸ© name.DefEval N ğ•©
    }
  }
  no_def â† {
    Evalâ‡{=ğ•¨ ? nâ†1âŠ‘ğ•¨ â‹„ n _unmatchedGen ; ğ•ŠâŸœğ•©{ğ•©.RunEval ğ•—}Â¨âŠ‘ğ•¨}
    âŸ¨node,Dump,NonLocal,Oper,ScopeâŸ©â‡Defaults "value"â€¿âŸ¨âŸ©
    Dispâ‡âŸ¨"(no definition)"âŸ©Ë™
  }
  OpDef â‡ {
    âŸ¨op,fn,type,precâŸ©â†ğ•© â‹„ posâ†ğ•¨
    prec â†© prec.Eval@
    Visitâ†{âŸ¨type,op,ğ•âŸ(0==)fn,â€¢Repr precâŸ©}
    âŸ¨node,Dump,Disp,Scope,EvalâŸ©â‡dâ†Defaults "opdef"â€¿visit
    Nâ†âŠ¢ â‹„ NonLocalâ‡{ğ•Š:Nâ†©{ğ•©.parent}}
    valueâ†{0<=fn?WordâŸœfn;
      vâ†var.New@
      Evalâ†©{v.Set fn.Eval ğ•©} # OpDef eval
      Evalâ‡{ğ•Š:v.Get pos}
      âŸ¨node,Dump,NonLocal,Oper,ScopeâŸ©â‡Defaults "value"â€¿âŸ¨âŸ©
      Dispâ‡{ğ•¤â‹„âŸ¨"(operator value)",opâŸ©}
    }
    Operâ‡{d.Oper ğ•© â‹„ pos (Nğ•©).Add typeâ€¿opâ€¿valueâ€¿prec}
  }
  Include â‡ {
    # Top-level if statements resolve in operator pass; expand then
    âŸ¨filenameâŸ© â† ğ•© â‹„ posâ†ğ•¨
    rp â† {âŸ¨Râ‡RealPathâŸ©:R; (Â¬Â·Â»âŠ¸âˆ¨'.'âŠ¸=âˆ§Â·(Â»âˆ§Â«)'/'âŠ¸=)âŠ¸/} â€¢file
    file â† RP pos files.Resolve symbols.From filename.Eval@
    Nâ†NLâ†âŠ¢ â‹„ NonLocalâ‡{ğ•Š:Nâ†©{ğ•©.parent}â‹„NLâ†©{ğ•©.NonLocal@â‹„ğ•©}}
    âŸ¨node,Dump,DispâŸ©â‡Defaults "include"â€¿{âŸ¨fileâŸ©} â‹„ Scopeâ‡Evalâ‡!
    Oper â‡ {ğ•¤
      (Nğ•©).AlreadyIncluded file ? Scopeâ†©Evalâ†©@Ë™ ;
      b â† NL files.Include file
      âŸ¨node,Dump,Disp,Oper,Scope,EvalâŸ© â†© b # Always a body so fields can't change
      b.Oper ğ•©
    }
  }
  Body â‡ {
    statementsâ†ğ•©
    Visitâ†{âŸ¨ğ•Â¨statementsâŸ©}
    âŸ¨node,Dump,DispâŸ©â‡dâ†Defaults "body"â€¿visit
    Nâ†âŠ¢ â‹„ NonLocalâ‡{ğ•Š:Nâ†©{ğ•©.parent}}
    Operâ‡{ d.Oper operator.NewScope N ğ•© }
    scâ†@ â‹„ Scopeâ‡{ d.Scope sc â†© scopes.New N ğ•© }
    Evalâ‡{ (0<â‰ )â—¶âŸ¨emptyBody,âŠ¢Â´âŸ© âŠ‘ d.Eval (sc.Names@) env.New N ğ•© }
  }
  emptyBody â† {Showsâ‡!âˆ˜"Empty body has no result"â‹„kindâ‡"error"}

  LazyLabel â† {ğ•¤
    label â‡ ğ•©
    GotoC â‡ {
      label functions.LabelâŸ(@âŠ¸â‰¡)â†©
      GotoC â†© {ğ•© ğ•¨â—¶functions.GotoFâ€¿functions.Goto label}
      ğ•¨GotoCğ•©
    }
  }
  BoolEval â† {
    E â† IsTypedâ—¶"Expected boolean"â€¿"Can't use runtime logic outside if() and while()"
    e numbers.GetBool ğ•¨.Eval ğ•©
  }
  CondEvalS â† {  # Return 0 or 1 for constant result and @ for unknown
    "cond_oper"â‰¡ğ•¨.node ? ğ•¨.Eval ğ•© ;
    nğ•ŠâŸ¨jvâ€¿label,eâŸ©:
    c â† n.Eval e
    { IsTyped c ? "Condition type must be u1" types.IsBool _asrtGotS TypeOf c
      jv label.GotoC c â‹„ @
    ; "If condition must evaluate to boolean" numbers.GetBool c }
  }
  CondEval â† âŠ‘âˆ˜âŠ‘âˆ˜âŠ¢ â‰¢ CondEvalS  # Return 1 if it might jump
  CondOper â† { pos ğ•Š âŸ¨nameâ€¿_evbâ€¿_evc, termsâŸ©: # Node created for and/or/not
    Evalâ‡{evâ†(=ğ•©)âŠ‘evbâ€¿evc â‹„ terms _ev program._trace_ pos ğ•©}
    Visitâ†{âŸ¨name,ğ•Â¨termsâŸ©}
    âŸ¨node,Dump,Disp,NonLocal,ScopeâŸ©â‡dâ†Defaults "cond_oper"â€¿visit
  }
  AddConds â‡ {
    ev_not â† {Â¬(âŠ‘ğ•—) BoolEval ğ•©}â€¿{=ğ•©? Â¬âŸ(@âŠ¸â‰¢) (âŠ‘ğ•—) CondEvalS Â¬âŒ¾(âŠ‘âŠ‘)ğ•©}
    CAccum â† {ğ•Šid: {Eâ†BoolEvalâŸœğ•© â‹„ (E 1âŠ‘ğ•—Ë™)âŸ(idâŠ¸â‰¡) E âŠ‘ğ•—}â€¿{
      ğ”½_ğ•£ âŸ¨jvâ€¿label,eâŸ©:
      l â† LazyLabel@
      i â† (âŠ‘ğ•—) CondEvalS âŸ¨Â¬id,lâŸ©âŒ¾âŠ‘âŸ(id=jv) ğ•©
      c â† (1âŠ‘ğ•—) CondEvalSâŸœğ•©âŸ((Â¬id)â‰¢âŠ¢) i
      functions.SetLabelâŸ(@âŠ¸â‰¢) l.label
      iâŸ(idâŠ¸â‰¡) c
    }}
    @ ğ•©.AddâŸœ{ğ•Štâ€¿nâ€¿e: tâ€¿nâ€¿{nameâ‡nâ‹„evbâ€¿evcâ‡e}â€¿Â¯âˆ}Â¨ âŸ¨
      'p'â€¿"not"â€¿ev_not
      'l'â€¿"and"â€¿(CAccum 1)
      'l'â€¿"or" â€¿(CAccum 0)
    âŸ©
  }
  If â‡ {
    âŸ¨cond,then,elseâŸ©â†ğ•© â‹„ posâ†ğ•¨
    Visitâ†{âŸ¨ğ•cond,ğ•then,ğ•Â¨elseâŸ©}
    âŸ¨node,Dump,Disp,NonLocal,Oper,ScopeâŸ©â‡Defaults "if"â€¿visit
    Eval â‡ {
      lf â† LazyLabel@
      c â† cond CondEval program._trace_ pos âŸ¨0â€¿lf, eâ†ğ•©âŸ©
      { Â¬c ?
        r â† {Showsâ‡!âˆ˜"Can't use if-0 statement result as value"â‹„kindâ‡"error"}
        functions.SetLabelâŸ(@âŠ¸â‰¢) lf.label
        r âŠ£Â´ { ğ•©.Eval e }Â¨ else
      ;
        r â† then.Eval e â‹„ @â‰¡lf.label ? r ;
        functions.GotoÂ¨ lt â† functions.LabelÂ¨ else
        functions.SetLabel lf.label
        lt { ğ•©.Eval e â‹„ functions.SetLabel ğ•¨ }Â¨ else
        {Showsâ‡!âˆ˜"Can't use runtime if statement result as value"â‹„kindâ‡"error"}
      }
    }
  }
  TopIf â‡ {
    âŸ¨cond,then,elseâŸ©â†ğ•© â‹„ posâ†ğ•¨
    Visitâ†{âŸ¨ğ•cond,ğ•Â¨then,ğ•Â¨elseâŸ©}
    âŸ¨node,Dump,Disp,NonLocalâŸ©â‡Defaults "topif"â€¿visit â‹„ Scopeâ‡Evalâ‡!
    Operâ‡{
      # Latest we can evaluate condition without scope circularity, so do it now
      cond.Oper ğ•©
      c â† {ğ•¨ BoolEval program._trace_ pos ğ•©}ast._runIfCond cond
      body â† c Â¬âŠ¸âŠ‘ thenâ€¿else
      âŸ¨Scope,EvalâŸ© â†© d â† Defaults "topif"â€¿{âŸ¨ğ•Â¨bodyâŸ©}
      d.Oper ğ•©
      operator.nil
    }
  }
  While â‡ {
    âŸ¨testFirst,cond,stmtâŸ©â†ğ•© â‹„ posâ†ğ•¨
    Visitâ†{âŸ¨ğ•cond,ğ•stmtâŸ©}
    âŸ¨node,Dump,Disp,NonLocal,Oper,ScopeâŸ©â‡Defaults "while"â€¿visit
    Eval â‡ { ğ•Š e:
      functions.SetLabel ll â† functions.Label@
      { testFirst ?
        lt â† LazyLabel@
        { cond CondEval program._trace_ pos âŸ¨0â€¿lt, eâŸ© ?
          stmt.Eval e
          functions.Goto ll
        ; @ }
        functions.SetLabelâŸ(@âŠ¸â‰¢) lt.label
      ;
        stmt.Eval e
        functions.Gotoâˆ˜llâŸÂ¬ cond CondEval âŸ¨1â€¿(LazyLabel ll), eâŸ©
      }
      {Showsâ‡!âˆ˜"Can't use while statement result as value"â‹„kindâ‡"error"}
    }
  }

  OptPlain â† {
    gensâ†ğ•©
    Visitâ†{âŸ¨ğ•Â¨gensâŸ©}
    âŸ¨node,Dump,Disp,NonLocal,Oper,ScopeâŸ©â‡Defaults "function"â€¿visit
    Eval â‡ { ğ•Š e:
      {"option"_errNoMatch} {ğ•©â€¿"(options)" ğ•¨.Eval e}âŸœ{Getâ‡ğ•©Ë™}Â´ gens
    }
  }
  Options â‡ { (ğ•¨Runâ‹ˆâŸœâŠ‘Ëœ)âŸ(â‰ âŠ£)âŸœ(ğ•¨OptPlainâŠ¢)Â´ ğ•© }

  For â‡ {
    âŸ¨fn,ptrs,ind,from,to,bodyâŸ©â†ğ•© â‹„ posâ†ğ•¨
    ptriâ†posâŠ¸WordÂ¨ptrnâ†âŠ‘Â¨ptrs
    ptrvâ†ptrs(1âŠ‘âˆ¾âŸœ<)Â¨ptri
    fromâ†©consts.n0âŠ£Â´from
    vardispâ†1â†“âˆ¾(","âŠ¸âˆ¾Â¨ptrn)âˆ¾" over "âŠ¸âˆ¾Â¨ind
    Visitâ†{âŸ¨ğ•fn,vardispâŠ£ğ•Â¨ptriâ‰Ë˜ptrv,ğ•from,ğ•to,ğ•bodyâŸ©}
    âŸ¨node,Dump,Disp,NonLocal,OperâŸ©â‡dâ†Defaults "for"â€¿visit
    lsâ†@
    Scope â‡ {
      (o.Scope ğ•©)Â¨ âˆ¾âŸ¨fnâŸ©â€¿ptrvâ€¿âŸ¨from,toâŸ©
      ls â†© (<pos) {ğ•}âˆ˜ğ•©.GetÂ¨ "load"â€¿"store"
      body.Scope scopes._defer (indâˆ¾ptrn) scopes.New ğ•©
    }
    Eval â‡ {
      eâ†o.Eval ğ•©
      Forâ†(E fn) program._trace_ pos
      lsvâ†(pos var.Get {ğ•ğ•©}âŸœğ•©)Â¨ ls
      For âŸ¨EÂ¨ptrv, E from, E to, blocks.New indâ€¿ptrnâ€¿bodyâ€¿lsvâ€¿ğ•©âŸ©
    }
  }
}

targetNodes â† {
  failedMatch â† {â‡}
  Name â‡ Constant â‡ {
    # If constant, "assign" to node to evaluate and compare and cond-time
    targs â‡ âŸ¨ğ•©âŸ©
    conds â‡ âŸ¨âŸ©
    ProcE â‡ ProcT â‡ â‹ˆ
  }
  Merge â† { ğ•¨ ğ•Š targets:
    tnâ€¿tcâ€¿teâ€¿tt â† {ğ•Â¨targets}Â¨ {ğ•©.targs}â€¿{ğ•©.conds}â€¿{ğ•©.ProcE}â€¿{ğ•©.ProcT}
    targsâ€¿conds â‡ âˆ¾Â¨ tnâ€¿tc
    conds âˆ¾â†© ğ•¨âŠ£âŸ¨âŸ©
    ProcE â‡ âˆ¾ te {ğ•ğ•©}Â¨ âŠ¢
    ProcT â‡ {âˆ¨Â´failedMatchâ‰¡Â¨ğ•© ? failedMatch ; âˆ¾ ğ•©} tt {ğ•ğ•©}Â¨ âŠ¢
  }
  AddTransform â† { tr ğ•Š t:
    targsâ€¿condsâ€¿ProcEâ€¿ProcT â‡ t
    ProcEâ€¿ProcT {ğ•âˆ˜Tr}Â¨â†©
  }
  _addCheck â† { pos errâ€¿Check _ğ•£ target:
    targsâ€¿conds â‡ target
    Fail â† {ğ•Š: ! program._trace_ pos "Destructuring: "âˆ¾err}
    ProcE â‡ Checkâ—¶âŸ¨Fail,         target.ProcEâŸ©
    ProcT â‡ Checkâ—¶âŸ¨failedMatchË™, target.ProcTâŸ©
  }
  _single â† { eâ€¿Câ€¿Tr _ğ•£: âŠ£ eâ€¿C _addCheck trË™ AddTransform âŠ¢ }
  _multi â† { ğ•—_singleâŸœMerge }
  Equals  â‡ { ğ•¨ Same ğ•¨âŠ¸ConstantÂ¨âŒ¾(1âŠ¸â†“) ğ•© }
  Same    â‡ { ({2=ğ•©?â‹ˆËœ;ğ•©â¥Š<}â‰ ğ•©) AddTransform Merge ğ•© }
  Typed   â‡ âŸ¨"type is required", IsTyped, â‹ˆâŸœ{ğ•©.type}âŸ©_multi
  Vector  â‡ (âŸ¨ "vector type required"âŸ©âˆ¾types.vecDecompParams)_multi
  Pointer â‡ (âŸ¨"pointer type required"âŸ©âˆ¾types.ptrDecompParams)_single
  List â‡ {
    âŸ¨ps, condsâŸ© â† ğ•© â‹„ [gather,params] â† â‰>ps â‹„ posâ†ğ•¨
    n â† +Â´ Â¬ gather  # Minimum length
    addLenCheck â† {
      n=â‰ gather ? âŸ¨"length doesn't match", n=â‰ âŸ©_addCheck
    ;
      G â† (0â€¿n-Ëœâ‹ˆâ¼/gather)âŠ¸(âˆ¾0â€¿2â€¿1âŠâ†‘Â¨âŸœ<âˆ¾âŸœ<Â·<â†“Â´Ëœ)
      âŸ¨"length too short", nâ‰¤â‰ , GâŸ©_single
    }
    t â† pos AddLenCheck conds Merge params
    types.tupTry AddTransform pos âŸ¨"tuple required", IsTupâŸ© _addCheck t
  }
  # Get functions for evaluating regular node from target node
  GetProcs â‡ { pos ğ•Š target:
    # An individual target might be a name, _, or a node
    # (which is evaluated and required to match the corresponding value)
    âŸ¨targsâŸ© â† target
    typ â† (0==Â¨targs) - "_"âŠ¸â‰¡Â¨targs
    nsâ€¿eqs â† 2â†‘typâŠ”targs â‹„ eqsâ‡ â‹„ namesâ‡â·ns
    tr â† {ğ•â‹ˆğ•}Â´ {âˆ§Â´ğ•©? âŠ¢ ; âˆ¨Â´ğ•©? ğ•©âŠ¸/ ; 0âŠ¸â†‘}Â¨ 0â€¿1 = <targs (1-ËœâˆŠâˆ˜âŠ£)âŒ¾((0=typ)âŠ¸/) typ
    AllEq â† âˆ§Â´âŠMatchÂ¨1âŠ¸â†“
    TrE â† Tr â‹„ ChT â† failedMatchË™âŠ¸â‰¢
    { namesâ‰¡ns ? @ ;
      c â† {ğ•âˆ§ğ•}Â´{AllEqğ•©âŠ¸âŠ}Â¨(1<â‰ Â¨)âŠ¸/(âŠns)âŠ”/0=typ
      Fail â† {ğ•Š: ! program._trace_ pos "Destructuring: values given the same name don't match"}
      TrE â†© Câ—¶âŸ¨Fail, TrEâŸ©
      ChT â†© ChTâ—¶0â€¿C
    }
    condsâ€¿ProcEâ€¿ProcT â‡ target
    ProcE â†© TrEâˆ˜ProcE
    ProcT â†© ChTâ—¶âŸ¨@,TrâŸ©âˆ˜ProcT
  }
}

files â† {
  pathâ†@ â‹„ logâ†âŸ¨âŸ©
  Load â† {
    path â†© (âˆ¨`âŒ¾âŒ½'/'âŠ¸=)âŠ¸/ ğ•©
    ğ•© ast.Build â€¢file.Chars ğ•©
  }
  lib â† ('/'âˆ¾ËœâŸ(â‰ âŸœ(Â¯1âŠ¸âŠ‘))âŸ(0<â‰ âˆ˜âŠ¢)âŒ¾âŠ‘Â¨libpaths)âˆ¾<âŸ¨"","include/"âŸ©
  Resolve â‡ {
    '/'=âŠ‘ğ•© ? â€¢file.Exists fâ†ğ•©âˆ¾".singeli" ? f ;
    search â† (â‰ â†‘ğ•©Ë™)âŠ¸â‰¡âˆ˜âŠ‘Â¨âŠ¸/ ('.'=âŠ‘ğ•©) âŠ‘ âŸ¨lib,âŸ¨""â€¿pathâŸ©âŸ©
    Get â† {preâ€¿pathğ•Šğ•©: path â€¢file.At pre â‰ âŠ¸(âŠ¢â†“ËœâŠ£+'/'=âŠ‘) ğ•©}âŸœ(ğ•©âˆ¾".singeli")
    fâ†@ â‹„ {fâ‰¡@? â€¢file.Exists ftâ†Getğ•©? fâ†©ft; @}Â¨ search
    Report â† {" (searched "âˆ¾"and Singeli library)"âˆ¾Ëœâˆ¾â¥Š(GetÂ¨Â¯1â†“ğ•©)âˆ¾Ë˜<", "}
    Errâˆ˜((1<â‰ )â—¶""â€¿Reportâˆ˜searchâŠ¸(âˆ¾Ëœ)âŒ¾âŠ‘)âŸ(fâ‰¡@) "File not found"â€¿ğ•¨
    f
  }
  Include â‡ { logâˆ¾â†©<ğ•© â‹„ pâ†path â‹„ aâ†Load ğ•© â‹„ pathâ†©p â‹„ a }
  Build â‡ { logâ†©âŸ¨âŸ© â‹„ Load ğ•© }
  WriteDeps â‡ { @â‰¢ğ•© ? ğ•© â€¢file.Lines log ; @ }
}

ast â† {
  Show â‡ {â€¢Out âˆ¾âˆ¾âŸœlfÂ¨ ğ•©.Disp @}
  baseScope â† builtins.names scopes.New scopes.Init@
  baseEnv   â† builtins.values env.Fixed @
  baseOper  â† operator.NewScope operator.nilScope
  nodes.AddConds baseOper
  @ baseOper.Add 'r'â€¿"="â€¿(nodes.WordâŸœ"__set")â€¿Â¯âˆ
  Build â‡ Parseâˆ˜Tokenize
  Compile â‡ {
    t â† files.Build ğ•©
    t.Oper operator.NewScope baseOper
    files.WriteDeps ğ•¨
    t.Scope scopes._run sc â† scopes.New baseScope
    t.Eval program._with (sc.Names@) env.New baseEnv
  }
  _runIfCond â‡ { # For top-level if condition
    ğ•©.Scope scopes._run baseScope
    eâ†@ â‹„ {eâ†©ğ•©}âˆ˜(ğ•©âŠ¸ğ”½) program._with baseEnv â‹„ e
  }
}

(âˆ¾âˆ¾âŸœlfÂ¨) ast.Compile
