tabâ€¿lfâ†@+9â€¿10

dig â† '0'+â†•10
alphâ† "_"âˆ¾â¥Š"aA"+âŒœâ†•26
wc  â† digâˆ¾alphâˆ¾"."       # Word characters
oc  â† "!$%&*+-/<=>?\^|~" # Operator characters that can stick together

# Source to list of token strings
Tokenizeâ†{
  # Resolve comments and strings
  sâ€¿dâ€¿câ€¿nâ†ğ•©âŠ¸=Â¨"'""#"âˆ¾lfâ‹„sdâ†/Â¨sâ€¿d
  gâ†â‹qâ†(Â¯1â†“Â¨sd)âˆ¾âŠ¸âˆ¾/c â‹„qâ†©gâŠq                 # Open indices
  eâ† gâŠ( 1â†“Â¨sd)âˆ¾âŠ¸âˆ¾-âŸœÂ»âˆ˜âŠâŸœ(0âˆ¾+`c)âŠ¸//nâˆ¾1       # Matching close indices
  Seâ†{(âŠËœğ•¨)Se 1Â¨âŒ¾((ğ•©/ğ•¨)âŠ¸âŠ)ğ•©}âŸ(0=Â¯1âŠ‘âŠ¢)       # Mark reachable openings
  aâ€¿bâ†((â‰ ğ•©)â†‘Â·/â¼((â‰ â†‘âˆ¾âŸœâ‰ Se 1âˆ¾0Â¨)qâ‹e)âŠ¸/)Â¨qâ€¿e   # Open/close masks
  kâ†Â»â‰ `abâ†aâˆ¨b                               # Token continuation mask
  {âŸ¨âŠ‘/ğ•©,"Unclosed quote"âŸ©!0}âŸ(âˆ¨Â´)(sâˆ¨d)>kâˆ¨a
  ignâ†(ğ•©âˆŠ" "âˆ¾tab)âˆ¨â‰ `abâˆ§câˆ¨n                  # Ignored characters
  # Other stuff
  kâˆ¨â†©âˆ¨Â´(Â»âŠ¸âˆ§k<ğ•©âŠ¸âˆŠ)Â¨wcâ€¿oc                     # Group names, numbers, and ops
  tsâ†nâˆ¨Â¬kâˆ¨ign                               # Token start mask
  âŸ¨ğ•©âŠ”Ëœ1-ËœignÂ¬âŠ¸Ã—+`ts, /tsâŸ©
}

MakeStack â† {ğ•¤
  stâ†@ â‹„ dâ†0
  Pushâ‡{   stâ†©ğ•©â€¿st â‹„ d+â†©1}
  Pop â‡{ğ•¤â‹„ râ€¿sâ†st â‹„ stâ†©s â‹„ d-â†©1 â‹„ r}
  Arr â‡{ğ•¤â‹„ âŠ‘Â¨ âŒ½ 1âŠ¸âŠ‘âŸ(â†•d) st}
  _while_â‡{Pop âŠ¢ ğ”½ âŠ£ Â·Pushğ•˜Ë™}
}

MakeStream â† {
  lenâ†â‰ srcâ†ğ•© â‹„ iâ†0
  Pos  â‡ {ğ•¤â‹„i}
  Inc  â† {ğ•¤â‹„i+â†©1}
  Rem  â‡ {ğ•¤â‹„(i+1)<len}
  Peek â‡ {ğ•¤â‹„iâŠ‘src}
  Next â‡ Inc âŠ¢ Peek
}

Parse â† {
  # Three kinds of token tests, distinguished by depth.
  Is â† â‰¡âˆ˜âŠ¢â—¶âŸ¨
    {ğ•ğ•¨}   # 0 Function to apply
    â‰¡      # 1 Token
    âŠ‘<âŠ¸âˆŠ   # 2 List of tokens
  âŸ©
  sep â† âŸ¨";", â¥ŠlfâŸ©

  ! (Â¯1âŠ‘ğ•©) Is sep

  Err â† {
    lâ†{ğ•¨âŠ¸âŠâŠğ•©Ë™}Ëâ‰âˆ˜â€¿2â¥ŠâŸ¨c.arg,"arg",c.assign,"assign",c.body,"body",c.call,"call",c.define,"define",c.export,"export",c.for,"for",c.function,"function",c.if,"if",c.lambda,"lambda",c.opdef,"opdef",c.phrase,"phrase",c.run,"run",c.while,"while",c.word,"word"âŸ©
    â€¢â†LâŒ¾(âŠâˆ˜âŒ½â‰)>DumpStack@
    ğ•¨!ğ•©
  }
  MakeTokStream â† {
    Posâ€¿Remâ€¿Peekâ‡sâ†MakeStream ğ•©
    Inc â† s.Next
    Next â‡ PeekâŠ¸Is
    Get  â‡ Inc âŠ¢ PeekâŠ¸(âŠ£âŠ£â‰â—‹<ErrâŸ(Â¬âŠ¢)Is)
    Try  â‡ 1âˆ˜IncâŸâŠ¢âˆ˜Next
  }
  âŸ¨Next,Get,Peek,Try,Rem,PosâŸ© â† MakeTokStream ğ•©

  # Node creation and error tracking
  c â† nodes
  âŸ¨_whileParse_â‡_while_, DumpStackâ‡ArrâŸ© â† MakeStack@
  _node_ â† {ğ”½ ğ”¾_whileParse_âŸ¨Pos@,ğ•—âŸ© ğ•©}

  When  â† {Testâ€¿Cont:       ( â¥Šâˆ˜< Cont)âŸTest   âŸ¨âŸ©  }
  While â† {Testâ€¿Contâ€¿init: {(ğ•Šâˆ¾âŸœ<âŸœCont)âŸTestğ•©} ContÂ¨â†•init}
  _seq â† {â‰¡Â¨âŠ¸((â‰ âŸœ1âˆ§(<sep)â‰¢Â¨âŠ¢)/>âŸœ0â—¶{ğ•@}â€¿GetÂ¨) ğ”½}

  _begin â† {Get (âŠ‘ğ•—âˆŠËœâŠ)Ë™}
  Name â† alph _begin
  Oper â† oc _begin
  Word â† c.word _node_ ((wcâˆ¾oc)_begin)
  Symbol â† c.symbol _node_ ("'"_begin)

  AddParams â† {ğ•Šâˆ˜(c.run  _node_ (âŠ¢â‰â—‹<"{"â€¿"}"_args))âŸ(Next"{") ğ•©}
  AddArgs   â† {  (c.call _node_ (âŠ¢â‰â—‹<"("â€¿")"_args))âŸ(Next"(") ğ•©}
  Expr0 â† {ğ•¤
    Vec â† c.run _node_ (âŸ¨c.Word"vector"âŸ© âˆ¾ "["â€¿Exprâ€¿"]"â€¿Expr0 _seq)
    Par â† âŠ‘ "("â€¿Exprâ€¿")" _seq
    (âŠ‘"[('"âŠâŠ)â—¶Vecâ€¿Parâ€¿Symbolâ€¿Word Peek@
  }
  Callable â† AddParamsâˆ˜Expr0
  _exprEnd â† {endTok _ğ•£:
    end â† endTokâˆ¾sepâˆ¾â¥ŠÂ¨",:=)}"
    Call â† { Opâ†âˆ¨Â´(ocâˆ¾"[")=âŠ â‹„ câ†Â¬Next op â‹„ AddArgsâŸc Callableğ•© }
    c.phrase _node_ (Whileâˆ˜âŸ¨Â¬Nextâˆ˜end, Call, 0âŸ©)
  }
  Expr â† âŸ¨âŸ©_exprEnd

  _args â† {ğ•¤
    Get âŠ‘ğ•—
    a â† While âŸ¨Tryâˆ˜",", Expr, 1âŸ©
    Get 1âŠ‘ğ•—
    a
  }

  Statement â† {
  "def":    Define@ ;
  "if":     c.if     _node_ ("if"â€¿"("â€¿Exprâ€¿")"â€¿Statementâ€¿(Whenâˆ˜âŸ¨Nextâˆ˜"else",StatementâŸ©)_seq)@ ;
  "while":  c.while  _node_ (1 âˆ¾   "while"â€¿"("â€¿Exprâ€¿")"â€¿Statement _seq)@ ;
  "do":     c.while  _node_ (0 âˆ¾âŸœâŒ½ "do"â€¿Statementâ€¿"while"â€¿"("â€¿Exprâ€¿")"â€¿sep _seq)@ ;
  "@":      For@ ;
  "{":      c.body   _node_ Body@ ;
  ğ•©:
    n â† Expr@
    d â† Try ":"
    e â† Try "="
    t â† When âŸ¨d>e, {eâ†©Try"="â‹„ğ•©}âˆ˜ExprâŸ©
    c.assign _node_ {âŸ¨ğ•©,d,t,Expr@âŸ©}âŸe n
  }âˆ˜Peek

  For â† c.for _node_ {ğ•¤
    Expr â† "over"â€¿"from"â€¿"to"_exprEnd # Shadow
    Get "@"
    f â† Callable@
    Get "("
    toâ† Expr@ â‹„ NEâ†{ğ•¤â‹„ nâ†c.PhraseToName to â‹„ toâ†©Expr@ â‹„ n}
    peâ† While âŸ¨Tryâˆ˜",", Name, 0âŸ©
    psâ† pe âŠ¢â—¶{!0=â‰ ğ•¨â‹„âŸ¨âŸ©}â€¿{(<NE@)âˆ¾ğ•¨} Try"over" # Pointers
    frâ† When âŸ¨Try"from", ExprâŸ©               # Start index
    i â† âŠ¢â—¶{ğ•¤â‹„!0=â‰ frâ‹„âŸ¨âŸ©}â€¿{ğ•¤â‹„âŸ¨NE@âŸ©} Try"to"    # Index variable
    Get ")"
    b â† Statement@
    âŸ¨f,ps,i,fr,to,bâŸ©
  }

  Seps â† {Tryâˆ˜sepâ—¶@â€¿ğ•Šğ•©}
  Body â† {ğ•¤
    Get "{"
    While âŸ¨Â¬Tryâˆ˜"}"âˆ˜Seps, Statement, 0âŸ©
  }
  # ğ•© indicates if preceding token was =
  Result â† c.body _node_ (Nextâˆ˜"{"â—¶âŸ¨Exprâ€¿sep _seq !, BodyâŸ©)

  Params â† {ğ•¤
    Param â† {ğ•¤
      n â† Name@
      e â† When âŸ¨Try"==", ExprâŸ©
      nâ€¿e
    }
    Get "{"
    a â† While âŸ¨Tryâˆ˜",", Param, 1âŸ©
    c â† While âŸ¨Tryâˆ˜"&", Expr, 0âŸ©
    Get "}"
    aâ€¿c
  }
  _withParams â† {ğ•¤
    (Next"{")â—¶âŸ¨ğ”½, c.lambda _node_ (Paramsâ€¿ğ•Š _seq)âŸ©@
  }

  Function â† c.function _node_ {ğ•¤
    Get "("
    Arg â† c.arg _node_ (Nameâ€¿":"â€¿Expr _seq)
    a â† While âŸ¨Tryâˆ˜",", Arg, 1âŸ©
    Get ")"
    r â† When âŸ¨Try":", ExprâŸ©
    b â† Result Try"="
    âŸ¨a,r,bâŸ©
  } _withParams
  Generator â† {ğ•¤â‹„ Get"=" â‹„ Result 1} _withParams
  DefFun â† c.define _node_ (      Nameâ€¿Function  _seq)
  Define â† c.define _node_ ("def"â€¿Nameâ€¿Generator _seq)

  Export â† c.export _node_ (Symbolâ€¿"="â€¿Callableâ€¿sep _seq)

  OpType â† {ğ•¤
    pre â† (âŠ‘â‰¢Get) "prefix"â€¿"infix"
    preâ—¶âŸ¨'p', Nextâ—¶âŸ¨'n', âŠ‘âˆ˜Getâˆ˜1âŸ©âŸ© "none"â€¿"left"â€¿"right"
  }
  OpDef â† c.opDef _node_ ("oper"â€¿OpTypeâ€¿Operâ€¿Nameâ€¿Word _seq)

  Program â† c.body _node_ {ğ•¤
    Line â† "def"â€¿"oper"âŠ¸âŠâŒ¾<â—¶âŸ¨Define, OpDef, ('''=âŠ‘)â—¶DefFunâ€¿ExportâŸ©âˆ˜Peek
    While âŸ¨Rem, Lineâˆ˜Seps, 0âŸ©
  }

  Program @
}

operator â† {
  Parse â‡ {ops ğ•Š val:
    Peekâ€¿Nextâ€¿Rem â† MakeStream ops {nullâ€¿leftâ€¿bindâ€¿Râ‡ğ•¨ â‹„ valueâ‡ğ•©}Â¨ val
    E â† {ğ•Štest: {ğ•Šâˆ˜{ğ•© LeD Next@}âŸ(Test Peek)âŸRem ğ•©} NuD Next@ }
    NuD â† { ğ•©.null â‰¢âŸœ@â—¶{ğ•©.value}â€¿{nodes.Run âŸ¨ğ•©.R ğ•¨.V@, âŸ¨E ğ•¨.tâŸ©âŸ©} ğ•© }
    LeD â† { !@â‰¢lâ†ğ•©.left â‹„ nodes.Run âŸ¨ğ•©.R l.V@, âŸ¨ğ•¨, E l.tâŸ©âŸ© }
    E 1
  }
  New â† {ğ•¤
    null â‡ left â‡ @
    bind â‡ Â¯âˆ
    R â‡ âŠ¢
    Op â† {valâ€¿pâ€¿câ†ğ•© â‹„ Vâ‡nodes.Wordâˆ˜val â‹„ Tâ‡p C {ğ•©.bind}}  # Value and test
    AddNull â‡ {ğ•ŠâŸ¨value, precâŸ©: AddNullâ†©!âˆ˜0
      null â†© Op âŸ¨value, prec, <âŸ©
    }
    AddLeft â‡ {ğ•ŠâŸ¨value, prec, assocâŸ©: AddLeftâ†©!âˆ˜0
      bind â†© prec
      left â†© Op âŸ¨value, prec, ("lrn"âŠ¸âŠâŒ¾<assoc)âŠ‘<â€¿â‰¤â€¿(!âˆ˜â‰ âŠ¢<)âŸ©
    }
  }
  Run â‡ {ğ•ŠâŸ¨op,paramsâŸ©: nullâ€¿leftâ€¿bindâ‡op â‹„ Râ‡nodes.Run op.Râ‰â—‹<paramsË™}
  nil â‡ New @

  Lookupâ‡Addâ‡!âˆ˜0
  _with â‡ {
    nâ†âŸ¨âŸ© â‹„ oâ†âŸ¨âŸ©
    _get â† {(nâŠ¸âŠâŒ¾<ğ•©) =âŸœ(â‰ n)â—¶{ğ•¨âŠ‘o}â€¿ğ”½ ğ•©}
    Lookup â†© nil _get
    Define â† {nâˆ¾â†©<ğ•© â‹„ oâˆ¾â†©<râ†New@ â‹„ r} _get
    Add â†© {ğ•Štypeâ€¿nameâ€¿valueâ€¿prec:
      p â† Define name
      (typeâ‰ 'p')â—¶âŸ¨p.AddNull, p.AddLeftâˆ¾âŸœtypeâŸ© âŸ¨value,precâŸ©
    }
    ğ•¨ğ”½ğ•©
    Lookupâ†©Addâ†©!âˆ˜0
  }
}


# Runtime
# Kinds are:
# - BQN values tuple (list), number, generator (function)
# - Classes symbols, types, registers, functions, blocks
_and_ â† { ğ”½â—¶âŸ¨0,ğ”¾âŸ© }
IsNum â† 1=â€¢Type
IsInt â† IsNum _and_ (âŒŠâŠ¸=)
IsNat â† IsInt _and_ (0âŠ¸â‰¤)
IsTup â† 0=â€¢Type

_tsel â† {â€¢Typeâˆ˜âŠ£â—¶(Â¯1((â†“Â»(6â¥ŠâŸ¨!âŸ©)Ë™)âˆ¾â†‘)ğ•—)}
Kind  â† âŸ¨"tuple","number",@,"generator",{ğ•©.kind}âŸ©_tsel
Show  â† {âŸ¨"tup{"âˆ¾"}"Â«Â·âˆ¾(","âˆ¾ğ•Š)Â¨, â•, {ğ•©.Shows@}âŸ©_tsel ğ•©}
Match â† {ğ•¨ âŸ¨âˆ§Â´ğ•ŠÂ¨, â‰¡, {ğ•¨ğ•¨.Matchesğ•©}âŸ©_tsel ğ•©}
TypeOfâ† {âŸ¨types.Tup ğ•ŠÂ¨, {ğ•©.Type@}âŸ©_tsel ğ•©}

types â† {knameâ‡"type"
  New â† {kğ•Šd:
    kindâ‡kname
    typeKindâ€¿datâ‡ğ•¨â€¿ğ•©
    Showsâ‡typeKindâ—¶âŸ¨
      "void"               # Void:                     void
      âˆ¾âŸœâ•Â´                 # Primitive:   qualâ€¿len     u8
      {âˆ¾"["â€¿ğ•¨â€¿"]"â€¿ğ•©}â—‹ShowÂ´ # Vector:      countâ€¿t      [4]â€¦
      "*"âˆ¾Show             # Pointer:     t            *â€¦
      {âˆ¾ğ•¨â€¿" -> "â€¿ğ•©}â—‹ShowÂ´  # Function:    âŸ¨t, qâ€¿râ€¿sâŸ©   (â€¦,â€¦,â€¦) -> â€¦
      Show                 # Tuple:       qâ€¿râ€¿s        (â€¦,â€¦,â€¦)
    âŸ©âˆ˜dat
    Matchesâ‡{ğ•¨MTğ•©}
  }
  tVOIDâ€¿tPRIMâ€¿tVECâ€¿tPTRâ€¿tFUNâ€¿tTUP â† â†•6

  primTypes â‡ (tVOID New âŸ¨âŸ©)âˆ¾âˆ¾(<(tPRIM New â‰)Â¨Â´)Ë˜ âˆ˜â€¿2â¥ŠâŸ¨
    'u', 2â‹†0âˆ¾3+â†•4  # 1/8/16/32/64
    'i', 2â‹†  3+â†•4  #   8/16/32/64
    'f', 2â‹†  5+â†•2  #        32/64
  âŸ©

  IsType â† knameâ‰¡Kind
  Vec â‡ {nğ•Št: !IsNat n â‹„ !IsType t â‹„ tVEC New âŸ¨n,tâŸ©}
  Ptr â‡ { ğ•Št: !IsType t â‹„ tPTR New t}
  Tup â‡ { ğ•Št: !IsTup t â‹„ !âˆ§Â´IsTypeÂ¨ t â‹„ tTUP New t}

  Deref â‡ { !IsType ğ•© â‹„ !tPTR=ğ•©.typeKind â‹„ ğ•©.dat }

  _cases â† {
    Kindâ†{ğ•©.typeKind} â‹„ Datâ†{ğ•©.dat}
    c â† âŒŠâ€¿2â¥Šğ•—
    k â† âŠË˜c
    d â† (1âŠË˜c) âˆ¾ ((â‰ â¥Šc)â†“ğ•—)Â»âŸ¨!âˆ˜0âŸ©
    (kâŠ¸âŠâŒ¾< âŠ¢âŠ˜(â‰ â—¶âŠ¢â€¿Â¯1)â—‹Kind)â—¶({ğ•â—‹Dat}Â¨d) âŠ£ @â—‹(!IsType)
  }

  Size â‡ âŸ¨
    tPRIM, 1âŠ¸âŠ‘
    tVEC,  Ã—âŸœ{Sizeğ•©}Â´
    tTUP,  +Â´{Sizeğ•©}Â¨
  âŸ©_cases

  VCount â‡ âŸ¨ tVEC,âŠ‘, 1 âŸ© _cases

  _sub â† {
    L â† Â¯1âŠ¸âŠ‘
    ğ•¨ âŸ¨
      tVEC,  =â—‹âŠ‘ _and_ (ğ•Šâ—‹L)
      tPTR,  ğ•Š
      tTUP,  =â—‹â‰  _and_ (âˆ§Â´ğ•ŠÂ¨)
      tPRIM, â‰ â—‹âŠ‘â—¶âŸ¨ğ”½â—‹L, ('f'â‰ âŠ‘âˆ˜âŠ£)_and_(<â—‹L)âŸ©
      0
    âŸ© _cases ğ•©
  }
  Subtype  â‡ â‰¤ _sub
  SSubtype â‡ < _sub
  MT â‡ Subtype âˆ§ SubtypeËœ

  Cast â‡ {
    Numâ†{tğ•Šn:
      Câ†{ğ•Šqâ€¿l:
        "Cannot cast float to integer"!IsInt n
        "Constant doesn't fit"!1=(-âŸœ(1âŠ¸âŠ‘Ã·2Ë™)âŸ(q='i')âŸ¨0,2â‹†lâŸ©)âŠ¸â‹âŒ¾<n
      }âŸ('f'â‰ âŠ‘)
      âŸ¨ tPRIM,C, 0!Ëœ"Cannot cast number to "âˆ¾Show âŸ© _cases t
      t constants.New n
    }
    Objâ†{
      ! ğ•© TypeOfâŠ¸MT ğ•¨
      ğ•©
    }
    ğ•¨ âŸ¨âŸ¨tTUP,âŠ¢âŸ©_casesâŠ¸(ğ•ŠÂ¨)Ëœ, NumËœ, ObjËœâŸ©_tselËœ ğ•©
  }
}

registers â† {knameâ‡"register"
  New â‡ {
    kindâ‡kname â‹„ typeâ‡ğ•¨ â‹„ handleâ‡ğ•©
    showsâ‡"v"âˆ¾â•ğ•© â‹„ Matchesâ‡â‰¡
    Getâ‡âŠ¢ â‹„ SetUsedâ‡{ğ•¤â‹„Getâ†©{ functions.Copy typeâ€¿ğ•© }}
  }
  Is â† "register"â‰¡Kind
  JoinNew â† (IsâŠ£)â—¶{ ğ•©.SetUsed@ â‹„ ğ•© }â€¿{ ğ•¨ functions.Mut ğ•© }
  Join â‡ JoinNewâŸœ{ ğ•©.Get ğ•© }âŸ(IsâŠ¢)
}
constants â† {knameâ‡"constant"
  New â‡ {
    kindâ‡kname â‹„ typeâ‡ğ•¨ â‹„ valueâ‡ğ•©
    showsâ‡âˆ¾"!:"âˆ¾âŸœShowÂ¨ğ•©â€¿ğ•¨ â‹„ Matchesâ‡â‰¡
  }
}

NewLabel  â† { showsâ‡"l"âˆ¾â•ğ•© }
symbols â† {knameâ‡"symbol"
  Mâ†(knameâ‰¡Kindâˆ˜âŠ¢)_and_(â‰¡â—‹Show)
  Newâ‡{ kindâ‡kname â‹„ showsâ‡ğ•© â‹„ Matchesâ‡M }
}

functions â† {knameâ‡"function"
  currentâ‡@
  New â† {ğ•¤
    kindâ‡kname â‹„ showsâ‡"f"âˆ¾â•idâ‡ğ•© â‹„ Matchesâ‡â‰¡
    handleâ†Â¯1 â‹„ labelâ†Â¯1 â‹„ argsâ†âŸ¨âŸ© â‹„ rTypeâ†@
    Nextâ‡{ ğ•© registers.New handle+â†©1 }
    NextLabelâ‡{ğ•¤â‹„ NewLabel label+â†©1 }
    NextArgâ‡{ argsâˆ¾â†©ğ•© â‹„ Next ğ•© }
    âŸ¨Push,ArrâŸ©â†MakeStack@
    Instrsâ‡Arr
    Appendâ‡{ Pushğ•©â‹„@ ; (1âŠ¸âŠ‘âŠ£ğ•Š) âŸ¨"new",Nextğ•¨âŸ©âˆ¾symbols.NewâŒ¾âŠ‘ğ•© }
    SetRTypeâ‡{ SetRTypeâ†©!âˆ˜0 â‹„ !IsType rTypeâ†©ğ•© }
    _retâ†{ Append âŸ¨"ret", rType â‰¢âŸœ@â—¶âŸ¨ğ”½âˆ˜âŠ¢, types.CastâŸ© ğ•©âŸ© }
    Returnâ‡!âˆ˜0 _ret âŠ‘
    Finishâ‡{SetRtype TypeOf ğ•©â‹„ğ•©} _ret
    Protâ‡{ğ•¤â‹„ 1â†“âˆ¾" "âŠ¸âˆ¾Â¨âŸ¨"f"âˆ¾â•id,Show rTypeâŸ©âˆ¾(â•âˆ˜â‰ âŠ¸âˆ¾ShowÂ¨args)}
  }
  IsType â† "type"â‰¡Kind
  _with â‡ {
    fsâ†current
    fâ†currentâ†©program.AddFunction new
    f.Finish f ğ”½ ğ•©
    currentâ†©fs
    f
  }
  NextHandle â‡ { current.Next ğ•© }
  NextArg â‡ { current.NextArg ğ•© }
  Label â‡ { current.NextLabel ğ•© }
  Append â† { ğ•¨ current.Append ğ•© }
  Return â‡ { current.Return ğ•© }
  Emit â‡ { (âŠ‘ğ•©) Append "emit" <âŠ¸âˆ¾ ğ•© }
  Copy â‡ { (âŠ‘ğ•©) Append "val" <âŠ¸âˆ¾ ğ•© }
  Mut  â‡ { Append "mut"â€¿ğ•¨â€¿ğ•© â‹„ ğ•¨ }
  Call â‡ {
    f â† âŠ‘ğ•©
    ! "function"â‰¡Kind f
    t â† f.rType
    t Append âŸ¨"call",t,f.idâŸ© âˆ¾ 1â†“ğ•©
  }
  _instr â† { Append (ğ•¨ğ”½ğ•©)<âŠ¸âˆ¾ğ•¨â‰â—‹<ğ•© }
  SetLabel â‡ "lbl"_instr
  Goto     â‡ "goto"âŠ˜"gotoT"_instr
  GotoF    â‡ "gotoF"_instr
}

blocks â† {knameâ‡"block"
  New â‡ {ğ•Š indâ€¿ptrsâ€¿bodyâ€¿e:
    kindâ‡kname
    showsâ‡"{block}" â‹„ Matchesâ‡â‰¡
    Execâ‡{
      ! ptrsâ‰¡â—‹â‰ 1âŠ‘ğ•©
      r â† body.Eval be â† âŸ¨â‰ ind,ğ•©âŸ© env.Block e
      be.Stores @
      r
    }
  }
  Exec â‡ {ğ•Š indâ€¿varsâ€¿block:
    ! "block"â‰¡Kind block
    block.Exec indâ€¿vars
  }
}
Load â† {  ğ•Š ptrâ€¿i: functions.Emit âŸ¨types.Deref TypeOf ptr, symbols.New "load", ptr, iâŸ© }
Storeâ† {v ğ•Š ptrâ€¿i: functions.Emit âŸ¨types.Deref TypeOf ptr, symbols.New "store", ptr, i, vâŸ© }


builtins â† {
  namesâ€¿values â‡ <Ë˜âˆ¾â‰âŸ¨
    ShowÂ¨âŠ¸â‰ types.primTypes
    â‰> âŸ¨
      âŸ¨"call",functions.CallâŸ©, âŸ¨"emit",functions.EmitâŸ©,
      âŸ¨"return",functions.ReturnâŸ©, âŸ¨"exec",blocks.ExecâŸ©
      âŸ¨"match",MatchÂ´âŸ©
      âŸ¨"type",TypeOfâˆ˜âŠ‘âŸ©, âŸ¨"kind",symbols.New Kindâˆ˜âŠ‘âŸ©
      âŸ¨"tup",âŠ¢âŸ©, âŸ¨"tupsel",âŠ‘Â´âŸ©
      âŸ¨"cast",types.CastÂ´âŸ©
      âŸ¨"__vec",types.Vecâˆ˜âŠ‘âŸ©, âŸ¨"__pnt",types.Ptrâˆ˜âŠ‘âŸ©
      âŸ¨"__neg",-âŸ©
      âŸ¨"__lt",<Â´âŸ©,  âŸ¨"__gt",>Â´âŸ©,  âŸ¨"__le",â‰¤Â´âŸ©,  âŸ¨"__ge",â‰¥Â´âŸ©
      âŸ¨"__add",+Â´âŸ©, âŸ¨"__sub",-Â´âŸ©, âŸ¨"__mul",Ã—Â´âŸ©, âŸ¨"__div",Ã·Â´âŸ©
    âŸ©
  âŸ©
}

scopes â† {
  nullâ†{Getâ‡"Undefined name: "âŠ¸âˆ¾!0Ë™}
  Newâ‡{
    nâ†ğ•¨âŠ£âŸ¨âŸ© â‹„ PGâ†ğ•©.Get
    Addâ‡{
      iâ†/â‰¡âŸœğ•©Â¨n
      c â† ğ•¨ (â‰ i)â—¶{câ†â‰ nâ‹„nâˆ¾â†©<ğ•©â‹„c}â€¿{("Duplicate definition: "âˆ¾ğ•©)!ğ•¨âŠ£0â‹„âŠ‘i} ğ•©
      câŠ‘env.Vars
    }
    Getâ‡{ (nâŠ¸âŠâŒ¾<ğ•©) =âŸœ(â‰ n)â—¶{ğ•¨âŠ‘env.Vars}â€¿{(PGğ•©)âˆ˜env.Parent} ğ•© }
    Namesâ‡{ğ•¤â‹„n}
  }
  Initâ‡New nullË™
}
var â† {
  Getâ‡{ğ•©.Get@}
  SetTypeâ‡{ğ•¨.SetTypeğ•©}
  Fixedâ‡{ Getâ‡ğ•©Ë™ }
  Newâ‡{
    vâ†ğ•© â‹„ Getâ‡{ğ•¤â‹„v} â‹„ Setâ‡{vâ†©v registers.Join ğ•©}
    SetTypeâ‡{SetTypeâ†©!âˆ˜0 â‹„ Setâ†©Set ğ•©âŠ¸types.Cast}
  }
  # Variable that tracks when it's been set, for block exec
  Markedâ‡{
    writeâ‡0 â‹„ âŸ¨GetâŸ©â‡vâ†New ğ•© â‹„ Setâ‡{writeâ†©1â‹„v.Setğ•©}
  }
}
env â† {
  Vars  â‡{ğ•©.vars}
  Parentâ‡{ğ•©.parent}
  Make â†{ varsâ‡ğ•¨ â‹„ parentâ‡ğ•© }
  New  â‡{ (var.Newâˆ˜@Â¨ ğ•¨) Make ğ•© }
  Fixedâ‡{ (var.FixedÂ¨ ğ•¨) Make ğ•© }
  Blockâ‡{âŸ¨ni,indâ€¿ptrsâŸ© ğ•Š par:
    pi â† ptrs â‰â—‹<Â¨ <ind
    pv â† LoadÂ¨ pi
    varsâ€¿parent â‡ ((var.NewÂ¨â†•ni)âˆ¾(var.MarkedÂ¨pv)) Make ğ•©
    Stores â‡ {ğ•¤
      mâ†{ğ•©.write}Â¨vâ†niâ†“vars
      v var.GetâŠ¸StoreÂ¨â—‹(mâŠ¸/) pi
    }
  }
}

program â† {
  AddFunctionâ‡Exportâ‡!âˆ˜0
  _with â‡ {
    fnsâ†âŸ¨âŸ© â‹„ AddFunction â†© { f â† ğ• â‰ fns â‹„ fnsâˆ¾âŸœ<â†©f â‹„ f }
    expâ†âŸ¨âŸ© â‹„ Export â†© { exp âˆ¾âŸœ<â†© ğ•© }
    ğ•¨ğ”½ğ•©
    AddFunctionâ†©Exportâ†©!âˆ˜0
    âˆ¾ âŸ¨âˆ¾DispFunctionÂ¨fns, DispExportÂ¨expâŸ©
  }
  J â† 1â†“Â·âˆ¾" "âŠ¸âˆ¾Â¨
  Disp â† J ShowÂ¨âŒ¾(1âŠ¸â†“)
  DispFunctionâ†{ âˆ¾âŸ¨"beginFn "âˆ¾ğ•©.Prot@âŸ©â€¿(DispÂ¨ ğ•©.Instrs@)â€¿âŸ¨"endFn",""âŸ© }
  DispExportâ†{ "export " âˆ¾ J {ğ•©.Prot@}âŒ¾âŠ‘ âŒ½ğ•© }
}

nodes â† {
  # Node operations
  o â† {
    Verify â‡ {ğ•©.node}
    Dump â‡ {ğ•©.Dump@}
    Disp â‡ {ğ•©.Disp@}
    Oper â‡ {ğ•©.Oper@}
    Scopeâ‡ {ğ•Šsc :{ğ•©.Scope sc }}
    Eval â‡ {ğ•Šenv:{ğ•©.Eval  env}}
  }
  Defaults â† {
    nodeâ€¿visit â‡ ğ•©
    Visit o.verify
    Dump â‡ {ğ•¤â‹„âŸ¨node,Visit o.dumpâŸ©}
    Disp â‡ {ğ•¤â‹„node <âŠ¸âˆ¾ "  "âŠ¸âˆ¾Â¨ âˆ¾âˆ¾ @ â¥Šâˆ˜<âˆ˜âŠ¢âŸ((2Ã—â‰¡)+â‰¡âŸœ@)Â¨â—‹Visit o.disp}
    Oper â‡ {ğ•¤â‹„Visit o.oper â‹„ operator.nil}
    Scopeâ‡ {Visit o.Scope ğ•©â‹„@}
    Eval â‡ {Visit o.Eval ğ•©}
  }

  # Node types
  Ident â† {
    nameâ‡ğ•©
    âŸ¨node,DumpâŸ©â‡Defaults "ident"â€¿âŸ¨âŸ©
    Dispâ‡{ğ•¤â‹„âŸ¨nameâŸ©}
    Operâ‡{ğ•¤â‹„operator.Lookup name}
    Evalâ‡!âˆ˜0 â‹„ Scopeâ‡{Evalâ†©var.Getâˆ˜(ğ•©.Get name)}
  }
  Value â† {
    nameâ†ğ•¨
    Evalâ‡ğ•©Ë™
    âŸ¨node,Dump,Oper,ScopeâŸ©â‡Defaults "value"â€¿âŸ¨âŸ©
    Dispâ‡{ğ•¤â‹„âŸ¨nameâŸ©}
  }
  Word â‡ (âˆ§Â´âˆŠâŸœ("."âˆ¾dig))â—¶âŸ¨Ident, ValueâŸœâ€¢BQNâŸ©
  Symbol â‡ ValueâŸœ(symbols.New 1â†“Â¯1â†“âŠ¢)
  Run â‡ {
    âŸ¨caller,paramsâŸ©â†ğ•©
    Visitâ†{âŸ¨ğ•caller,ğ•Â¨paramsâŸ©}
    âŸ¨node,Dump,Disp,ScopeâŸ©â‡dâ†Defaults "run"â€¿visit
    Oper â‡ {ğ•¤â‹„ operator.Run âŸ¨âŠ‘Visit o.oper,paramsâŸ©}
    Eval â‡ {ğ•ğ•©}Â´ d.Eval
  }
  Call â‡ { Run âŸ¨Ident"call" , <âŠ¸âˆ¾Â´ğ•©âŸ© }
  Phrase â‡ {
    thingsâ†ğ•©
    ToNameâ‡{ğ•¤â‹„ !1=â‰ things â‹„ nâ†âŠ‘things â‹„ !"ident"â‰¡n.node â‹„ n.name }
    Visitâ†{âŸ¨ğ•Â¨thingsâŸ©}
    âŸ¨node,Dump,Disp,Scope,EvalâŸ©â‡Defaults "phrase"â€¿visit
    Operâ‡{ğ•¤
      n â† o.OperÂ¨âŠ¸operator.Parse things
      Scopeâ†©{ğ•¨n.Scopeğ•©} â‹„ Evalâ†©{ğ•¨n.Evalğ•©} â‹„ Dispâ†©{ğ•¨n.Dispğ•©}
      operator.nil
    }
  }
  PhraseToName â‡ {!"phrase"â‰¡ğ•©.node â‹„ ğ•©.ToName@}
  ParamEq â† { Run âŸ¨Ident"match", ğ•¨â€¿ğ•©âŸ© }
  Lambda â‡ {
    âŸ¨âŸ¨params,condsâŸ©,resultâŸ©â†ğ•©
    condsâˆ¾Ëœâ†©âˆ¾<âŠ¸(IdentâŠ¸ParamEqÂ¨)Â´Â¨params
    uParâ€¿iParâ†(â·â‰â—‹<âŠ)âŠ‘Â¨params
    Visitâ†{(iParâŠuPar)âˆ¾âŸ¨ğ•Â¨conds,ğ•resultâŸ©}
    âŸ¨node,Dump,Disp,OperâŸ©â‡Defaults "lambda"â€¿visit
    Scopeâ‡{ Visit o.Scope uPar scopes.New ğ•© }
    Evalâ‡{ğ•¨ ğ•Š e: # ğ•¨ is previous value
      next â† ({ğ•©.Get@}ğ•¨)âŠ£{"No matching generator definition"!0Ë™}
      Check â† {iPar (â‰¡â—‹â‰¢)_and_(âˆ§Â´(âˆ§Â´âŠMatchÂ¨1âŠ¸â†“)Â¨âˆ˜âŠ”) ğ•©}
      Checkâ—¶Nextâ€¿{
        Fâ†Next ğ•©Ë™
        try â† result.eval{ğ•¨.Evalâ—¶Fâ€¿ğ•}Â´conds
        Try (iParâˆŠâŠ¸/ğ•©) env.Fixed e
      }
    }
  }
  Arg â‡ {
    âŸ¨name,typeâŸ©â†ğ•©
    Visitâ†{âŸ¨name,ğ•typeâŸ©}
    âŸ¨node,Dump,Disp,OperâŸ©â‡Defaults "arg"â€¿visit
    vâ†@ â‹„ Scopeâ‡{ type.Scope ğ•© â‹„ v â†© ğ•©.Add name }
    Evalâ‡{ uâ†Vğ•© â‹„ u.SetType tâ†type.Eval ğ•© â‹„ u.Set functions.NextArg t }
  }
  Function â‡ {
    âŸ¨args,type,resultâŸ©â†ğ•©
    Visitâ†{âŸ¨ğ•Â¨args,ğ•Â¨type,ğ•resultâŸ©}
    âŸ¨node,Dump,Disp,OperâŸ©â‡Defaults "function"â€¿visit
    Scopeâ‡{ Visit o.Scope scopes.New ğ•© }
    Evalâ‡{
      evâ†o.Eval args env.New ğ•©
      EvÂ¨ args
      ğ•¨.SetRTypeâˆ˜EvÂ¨ type
      Ev result
    }functions._with
  }
  Assign â‡ {
    âŸ¨name,decl,type,valueâŸ©â†ğ•©
    name PhraseToNameËœâ†©@
    Visitâ†{âŸ¨nameâˆ¾decl/":",ğ•Â¨type,ğ•valueâŸ©}
    âŸ¨node,Dump,Disp,OperâŸ©â‡Defaults "assign"â€¿visit
    GetVarâ†!âˆ˜0 â‹„ Scopeâ‡{
      Visit o.Scope ğ•©
      getVar â†© declâ—¶âŸ¨ğ•©.Get, ğ•©.AddâŸ© name
    }
    Evalâ‡{
      u â† GetVar ğ•©
      v â† value.Evalğ•©
      u var.SetTypeâŸœ(â‰ â—¶âŸ¨TypeOf vË™, (o.Evalğ•©)âˆ˜âŠ‘âŸ©)âŸdecl type
      u.Set v
    }
  }
  Define â‡ {
    âŸ¨name,valueâŸ©â†ğ•©
    Visitâ†{âŸ¨name,ğ•valueâŸ©}
    âŸ¨node,Dump,Disp,OperâŸ©â‡Defaults "define"â€¿visit
    isLambda â† "lambda"â‰¡value.node
    vâ†@ â‹„ Scopeâ‡{ v â†© isLambda ğ•©.Add name â‹„ value.Scope ğ•© }
    Evalâ‡{ uâ†Vğ•© â‹„ u.Set u value.Eval ğ•© }
  }
  OpDef â‡ {
    âŸ¨type,op,fn,precâŸ©â†ğ•©
    !"value"â‰¡prec.node â‹„ !IsNum precâ†©prec.Eval@
    Visitâ†{ğ•¤â‹„âŸ¨type,op,fn,â•precâŸ©}
    âŸ¨node,Dump,Disp,Scope,EvalâŸ©â‡Defaults "opdef"â€¿visit
    Operâ‡{ğ•¤â‹„ operator.Add typeâ€¿opâ€¿fnâ€¿prec}
  }
  Export â‡ {
    âŸ¨name,valueâŸ©â†ğ•© â‹„ nameâ†©Show name.Eval@
    Visitâ†{âŸ¨name,ğ•valueâŸ©}
    âŸ¨node,Dump,Disp,Oper,ScopeâŸ©â‡dâ†Defaults "export"â€¿visit
    Eval â‡ { program.Export d.Eval ğ•© }
  }
  Body â‡ {
    statementsâ†ğ•©
    Visitâ†{âŸ¨ğ•Â¨statementsâŸ©}
    âŸ¨node,Dump,Disp,OperâŸ©â‡dâ†Defaults "body"â€¿visit
    scâ†@ â‹„ Scopeâ‡{ Visit o.Scope sc â†© scopes.New ğ•© }
    Evalâ‡{ Â¯1âŠ‘âŠ‘d.Eval (sc.Names@) env.New ğ•© }
  }
  If â‡ {
    âŸ¨cond,then,elseâŸ©â†ğ•©
    Visitâ†{âŸ¨ğ•cond,ğ•then,ğ•Â¨elseâŸ©}
    âŸ¨node,Dump,Disp,Oper,ScopeâŸ©â‡Defaults "if"â€¿visit
    Eval â‡ {ğ•Še:
      c â† cond.Evalğ•©
      lf â† functions.Label@
      c functions.GotoF lf
      then.Evalğ•©
      functions.GotoÂ¨ lt â† functions.LabelÂ¨ else
      functions.SetLabel lf
      { ğ•©.Eval e â‹„ functions.SetLabel lt }Â¨ else
    }
  }
  While â‡ {
    âŸ¨testFirst,cond,stmtâŸ©â†ğ•©
    Visitâ†{âŸ¨ğ•cond,ğ•stmtâŸ©}
    âŸ¨node,Dump,Disp,Oper,ScopeâŸ©â‡Defaults "while"â€¿visit
    Eval â‡ {
      functions.GotoÂ¨ lc â† functions.LabelÂ¨â†•testFirst
      functions.SetLabel lt â† functions.Label@
      stmt.Evalğ•©
      functions.SetLabelÂ¨ lc
      (cond.Evalğ•©) functions.Goto lt
    }
  }
  n0 â† Word "0"
  For â‡ {
    âŸ¨fn,ptrs,ind,from,to,bodyâŸ©â†ğ•©
    fromâ†©n0âŠ£Â´from
    ptriâ†IdentÂ¨ptrs
    vardispâ†1â†“âˆ¾(","âŠ¸âˆ¾Â¨ptrs)âˆ¾" over "âŠ¸âˆ¾Â¨ind
    Visitâ†{âŸ¨ğ•fn,vardispâŠ£ğ•Â¨ptri,ğ•from,ğ•to,ğ•bodyâŸ©}
    âŸ¨node,Dump,Disp,OperâŸ©â‡dâ†Defaults "for"â€¿visit
    Scope â‡ {
      d.Scope ğ•©
      body.Scope (indâˆ¾ptrs) scopes.New ğ•©
    }
    Eval â‡ {
      eâ†o.Eval ğ•©
      forâ†E fn
      For âŸ¨EÂ¨ptri, E from, E to, blocks.New indâ€¿ptrsâ€¿bodyâ€¿ğ•©âŸ©
    }
  }
}

preamble â† 1â†“"
oper prefix      -  __neg 30
oper prefix      $  __vec 50
oper prefix      *  __pnt 60

oper infix none  <  __lt  20
oper infix none  >  __gt  20
oper infix none  <= __le  20
oper infix none  >= __ge  20
oper infix left  +  __add 30
oper infix left  -  __sub 30
oper infix left  *  __mul 40
oper infix left  /  __div 40
"

ast â† {
  Show â‡ {â€¢Out âˆ¾âˆ¾âŸœlfÂ¨ ğ•©.Disp @}
  baseScope â† builtins.names scopes.New scopes.Init@
  baseEnv   â† builtins.values env.Fixed @
  Build â‡ Parseâˆ˜âŠ‘ Tokenize
  Compile â‡ {
    t â† Build ğ•©
    t.Oper operator._with @
    t.Scope baseScope
    t.Eval program._with baseEnv
  }
}
â€¢OutÂ¨ ast.Compile preamble âˆ¾ âˆ¾ â€¢FCharsÂ¨ â€¢args
